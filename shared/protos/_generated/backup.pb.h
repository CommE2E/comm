// @generated by the protocol buffer compiler.  DO NOT EDIT!
// source: backup.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_backup_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_backup_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include <google/protobuf/empty.pb.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_backup_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_backup_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_backup_2eproto;
namespace backup {
class AddAttachmentsRequest;
struct AddAttachmentsRequestDefaultTypeInternal;
extern AddAttachmentsRequestDefaultTypeInternal _AddAttachmentsRequest_default_instance_;
class CreateNewBackupRequest;
struct CreateNewBackupRequestDefaultTypeInternal;
extern CreateNewBackupRequestDefaultTypeInternal _CreateNewBackupRequest_default_instance_;
class CreateNewBackupResponse;
struct CreateNewBackupResponseDefaultTypeInternal;
extern CreateNewBackupResponseDefaultTypeInternal _CreateNewBackupResponse_default_instance_;
class PullBackupRequest;
struct PullBackupRequestDefaultTypeInternal;
extern PullBackupRequestDefaultTypeInternal _PullBackupRequest_default_instance_;
class PullBackupResponse;
struct PullBackupResponseDefaultTypeInternal;
extern PullBackupResponseDefaultTypeInternal _PullBackupResponse_default_instance_;
class RecoverBackupKeyRequest;
struct RecoverBackupKeyRequestDefaultTypeInternal;
extern RecoverBackupKeyRequestDefaultTypeInternal _RecoverBackupKeyRequest_default_instance_;
class RecoverBackupKeyResponse;
struct RecoverBackupKeyResponseDefaultTypeInternal;
extern RecoverBackupKeyResponseDefaultTypeInternal _RecoverBackupKeyResponse_default_instance_;
class SendLogRequest;
struct SendLogRequestDefaultTypeInternal;
extern SendLogRequestDefaultTypeInternal _SendLogRequest_default_instance_;
class SendLogResponse;
struct SendLogResponseDefaultTypeInternal;
extern SendLogResponseDefaultTypeInternal _SendLogResponse_default_instance_;
}  // namespace backup
PROTOBUF_NAMESPACE_OPEN
template<> ::backup::AddAttachmentsRequest* Arena::CreateMaybeMessage<::backup::AddAttachmentsRequest>(Arena*);
template<> ::backup::CreateNewBackupRequest* Arena::CreateMaybeMessage<::backup::CreateNewBackupRequest>(Arena*);
template<> ::backup::CreateNewBackupResponse* Arena::CreateMaybeMessage<::backup::CreateNewBackupResponse>(Arena*);
template<> ::backup::PullBackupRequest* Arena::CreateMaybeMessage<::backup::PullBackupRequest>(Arena*);
template<> ::backup::PullBackupResponse* Arena::CreateMaybeMessage<::backup::PullBackupResponse>(Arena*);
template<> ::backup::RecoverBackupKeyRequest* Arena::CreateMaybeMessage<::backup::RecoverBackupKeyRequest>(Arena*);
template<> ::backup::RecoverBackupKeyResponse* Arena::CreateMaybeMessage<::backup::RecoverBackupKeyResponse>(Arena*);
template<> ::backup::SendLogRequest* Arena::CreateMaybeMessage<::backup::SendLogRequest>(Arena*);
template<> ::backup::SendLogResponse* Arena::CreateMaybeMessage<::backup::SendLogResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace backup {

// ===================================================================

class CreateNewBackupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backup.CreateNewBackupRequest) */ {
 public:
  inline CreateNewBackupRequest() : CreateNewBackupRequest(nullptr) {}
  ~CreateNewBackupRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateNewBackupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNewBackupRequest(const CreateNewBackupRequest& from);
  CreateNewBackupRequest(CreateNewBackupRequest&& from) noexcept
    : CreateNewBackupRequest() {
    *this = ::std::move(from);
  }

  inline CreateNewBackupRequest& operator=(const CreateNewBackupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNewBackupRequest& operator=(CreateNewBackupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNewBackupRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kUserID = 1,
    kDeviceID = 2,
    kKeyEntropy = 3,
    kNewCompactionHash = 4,
    kNewCompactionChunk = 5,
    DATA_NOT_SET = 0,
  };

  static inline const CreateNewBackupRequest* internal_default_instance() {
    return reinterpret_cast<const CreateNewBackupRequest*>(
               &_CreateNewBackupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CreateNewBackupRequest& a, CreateNewBackupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNewBackupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNewBackupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNewBackupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNewBackupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNewBackupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateNewBackupRequest& from) {
    CreateNewBackupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNewBackupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backup.CreateNewBackupRequest";
  }
  protected:
  explicit CreateNewBackupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kDeviceIDFieldNumber = 2,
    kKeyEntropyFieldNumber = 3,
    kNewCompactionHashFieldNumber = 4,
    kNewCompactionChunkFieldNumber = 5,
  };
  // string userID = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string deviceID = 2;
  bool has_deviceid() const;
  private:
  bool _internal_has_deviceid() const;
  public:
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // bytes keyEntropy = 3;
  bool has_keyentropy() const;
  private:
  bool _internal_has_keyentropy() const;
  public:
  void clear_keyentropy();
  const std::string& keyentropy() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_keyentropy(ArgT0&& arg0, ArgT... args);
  std::string* mutable_keyentropy();
  PROTOBUF_NODISCARD std::string* release_keyentropy();
  void set_allocated_keyentropy(std::string* keyentropy);
  private:
  const std::string& _internal_keyentropy() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_keyentropy(const std::string& value);
  std::string* _internal_mutable_keyentropy();
  public:

  // bytes newCompactionHash = 4;
  bool has_newcompactionhash() const;
  private:
  bool _internal_has_newcompactionhash() const;
  public:
  void clear_newcompactionhash();
  const std::string& newcompactionhash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newcompactionhash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newcompactionhash();
  PROTOBUF_NODISCARD std::string* release_newcompactionhash();
  void set_allocated_newcompactionhash(std::string* newcompactionhash);
  private:
  const std::string& _internal_newcompactionhash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newcompactionhash(const std::string& value);
  std::string* _internal_mutable_newcompactionhash();
  public:

  // bytes newCompactionChunk = 5;
  bool has_newcompactionchunk() const;
  private:
  bool _internal_has_newcompactionchunk() const;
  public:
  void clear_newcompactionchunk();
  const std::string& newcompactionchunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_newcompactionchunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_newcompactionchunk();
  PROTOBUF_NODISCARD std::string* release_newcompactionchunk();
  void set_allocated_newcompactionchunk(std::string* newcompactionchunk);
  private:
  const std::string& _internal_newcompactionchunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_newcompactionchunk(const std::string& value);
  std::string* _internal_mutable_newcompactionchunk();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:backup.CreateNewBackupRequest)
 private:
  class _Internal;
  void set_has_userid();
  void set_has_deviceid();
  void set_has_keyentropy();
  void set_has_newcompactionhash();
  void set_has_newcompactionchunk();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr keyentropy_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newcompactionhash_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr newcompactionchunk_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backup_2eproto;
};
// -------------------------------------------------------------------

class CreateNewBackupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backup.CreateNewBackupResponse) */ {
 public:
  inline CreateNewBackupResponse() : CreateNewBackupResponse(nullptr) {}
  ~CreateNewBackupResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateNewBackupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateNewBackupResponse(const CreateNewBackupResponse& from);
  CreateNewBackupResponse(CreateNewBackupResponse&& from) noexcept
    : CreateNewBackupResponse() {
    *this = ::std::move(from);
  }

  inline CreateNewBackupResponse& operator=(const CreateNewBackupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateNewBackupResponse& operator=(CreateNewBackupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateNewBackupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateNewBackupResponse* internal_default_instance() {
    return reinterpret_cast<const CreateNewBackupResponse*>(
               &_CreateNewBackupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CreateNewBackupResponse& a, CreateNewBackupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateNewBackupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateNewBackupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateNewBackupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateNewBackupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateNewBackupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateNewBackupResponse& from) {
    CreateNewBackupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateNewBackupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backup.CreateNewBackupResponse";
  }
  protected:
  explicit CreateNewBackupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackupIDFieldNumber = 1,
  };
  // string backupID = 1;
  void clear_backupid();
  const std::string& backupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backupid();
  PROTOBUF_NODISCARD std::string* release_backupid();
  void set_allocated_backupid(std::string* backupid);
  private:
  const std::string& _internal_backupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backupid(const std::string& value);
  std::string* _internal_mutable_backupid();
  public:

  // @@protoc_insertion_point(class_scope:backup.CreateNewBackupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backup_2eproto;
};
// -------------------------------------------------------------------

class SendLogRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backup.SendLogRequest) */ {
 public:
  inline SendLogRequest() : SendLogRequest(nullptr) {}
  ~SendLogRequest() override;
  explicit PROTOBUF_CONSTEXPR SendLogRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendLogRequest(const SendLogRequest& from);
  SendLogRequest(SendLogRequest&& from) noexcept
    : SendLogRequest() {
    *this = ::std::move(from);
  }

  inline SendLogRequest& operator=(const SendLogRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendLogRequest& operator=(SendLogRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendLogRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kUserID = 1,
    kBackupID = 2,
    kLogHash = 3,
    kLogData = 4,
    DATA_NOT_SET = 0,
  };

  static inline const SendLogRequest* internal_default_instance() {
    return reinterpret_cast<const SendLogRequest*>(
               &_SendLogRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SendLogRequest& a, SendLogRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendLogRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendLogRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendLogRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendLogRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendLogRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendLogRequest& from) {
    SendLogRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendLogRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backup.SendLogRequest";
  }
  protected:
  explicit SendLogRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kBackupIDFieldNumber = 2,
    kLogHashFieldNumber = 3,
    kLogDataFieldNumber = 4,
  };
  // string userID = 1;
  bool has_userid() const;
  private:
  bool _internal_has_userid() const;
  public:
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string backupID = 2;
  bool has_backupid() const;
  private:
  bool _internal_has_backupid() const;
  public:
  void clear_backupid();
  const std::string& backupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backupid();
  PROTOBUF_NODISCARD std::string* release_backupid();
  void set_allocated_backupid(std::string* backupid);
  private:
  const std::string& _internal_backupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backupid(const std::string& value);
  std::string* _internal_mutable_backupid();
  public:

  // bytes logHash = 3;
  bool has_loghash() const;
  private:
  bool _internal_has_loghash() const;
  public:
  void clear_loghash();
  const std::string& loghash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_loghash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_loghash();
  PROTOBUF_NODISCARD std::string* release_loghash();
  void set_allocated_loghash(std::string* loghash);
  private:
  const std::string& _internal_loghash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_loghash(const std::string& value);
  std::string* _internal_mutable_loghash();
  public:

  // bytes logData = 4;
  bool has_logdata() const;
  private:
  bool _internal_has_logdata() const;
  public:
  void clear_logdata();
  const std::string& logdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logdata();
  PROTOBUF_NODISCARD std::string* release_logdata();
  void set_allocated_logdata(std::string* logdata);
  private:
  const std::string& _internal_logdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logdata(const std::string& value);
  std::string* _internal_mutable_logdata();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:backup.SendLogRequest)
 private:
  class _Internal;
  void set_has_userid();
  void set_has_backupid();
  void set_has_loghash();
  void set_has_logdata();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backupid_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr loghash_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logdata_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backup_2eproto;
};
// -------------------------------------------------------------------

class SendLogResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backup.SendLogResponse) */ {
 public:
  inline SendLogResponse() : SendLogResponse(nullptr) {}
  ~SendLogResponse() override;
  explicit PROTOBUF_CONSTEXPR SendLogResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendLogResponse(const SendLogResponse& from);
  SendLogResponse(SendLogResponse&& from) noexcept
    : SendLogResponse() {
    *this = ::std::move(from);
  }

  inline SendLogResponse& operator=(const SendLogResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendLogResponse& operator=(SendLogResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendLogResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendLogResponse* internal_default_instance() {
    return reinterpret_cast<const SendLogResponse*>(
               &_SendLogResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SendLogResponse& a, SendLogResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendLogResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendLogResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SendLogResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SendLogResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendLogResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SendLogResponse& from) {
    SendLogResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendLogResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backup.SendLogResponse";
  }
  protected:
  explicit SendLogResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLogCheckpointFieldNumber = 1,
  };
  // string logCheckpoint = 1;
  void clear_logcheckpoint();
  const std::string& logcheckpoint() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logcheckpoint(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logcheckpoint();
  PROTOBUF_NODISCARD std::string* release_logcheckpoint();
  void set_allocated_logcheckpoint(std::string* logcheckpoint);
  private:
  const std::string& _internal_logcheckpoint() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logcheckpoint(const std::string& value);
  std::string* _internal_mutable_logcheckpoint();
  public:

  // @@protoc_insertion_point(class_scope:backup.SendLogResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logcheckpoint_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backup_2eproto;
};
// -------------------------------------------------------------------

class RecoverBackupKeyRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backup.RecoverBackupKeyRequest) */ {
 public:
  inline RecoverBackupKeyRequest() : RecoverBackupKeyRequest(nullptr) {}
  ~RecoverBackupKeyRequest() override;
  explicit PROTOBUF_CONSTEXPR RecoverBackupKeyRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecoverBackupKeyRequest(const RecoverBackupKeyRequest& from);
  RecoverBackupKeyRequest(RecoverBackupKeyRequest&& from) noexcept
    : RecoverBackupKeyRequest() {
    *this = ::std::move(from);
  }

  inline RecoverBackupKeyRequest& operator=(const RecoverBackupKeyRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoverBackupKeyRequest& operator=(RecoverBackupKeyRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoverBackupKeyRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoverBackupKeyRequest* internal_default_instance() {
    return reinterpret_cast<const RecoverBackupKeyRequest*>(
               &_RecoverBackupKeyRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(RecoverBackupKeyRequest& a, RecoverBackupKeyRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoverBackupKeyRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoverBackupKeyRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoverBackupKeyRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecoverBackupKeyRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecoverBackupKeyRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecoverBackupKeyRequest& from) {
    RecoverBackupKeyRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecoverBackupKeyRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backup.RecoverBackupKeyRequest";
  }
  protected:
  explicit RecoverBackupKeyRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:backup.RecoverBackupKeyRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backup_2eproto;
};
// -------------------------------------------------------------------

class RecoverBackupKeyResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backup.RecoverBackupKeyResponse) */ {
 public:
  inline RecoverBackupKeyResponse() : RecoverBackupKeyResponse(nullptr) {}
  ~RecoverBackupKeyResponse() override;
  explicit PROTOBUF_CONSTEXPR RecoverBackupKeyResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RecoverBackupKeyResponse(const RecoverBackupKeyResponse& from);
  RecoverBackupKeyResponse(RecoverBackupKeyResponse&& from) noexcept
    : RecoverBackupKeyResponse() {
    *this = ::std::move(from);
  }

  inline RecoverBackupKeyResponse& operator=(const RecoverBackupKeyResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RecoverBackupKeyResponse& operator=(RecoverBackupKeyResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RecoverBackupKeyResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RecoverBackupKeyResponse* internal_default_instance() {
    return reinterpret_cast<const RecoverBackupKeyResponse*>(
               &_RecoverBackupKeyResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(RecoverBackupKeyResponse& a, RecoverBackupKeyResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RecoverBackupKeyResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RecoverBackupKeyResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RecoverBackupKeyResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RecoverBackupKeyResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RecoverBackupKeyResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RecoverBackupKeyResponse& from) {
    RecoverBackupKeyResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RecoverBackupKeyResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backup.RecoverBackupKeyResponse";
  }
  protected:
  explicit RecoverBackupKeyResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBackupIDFieldNumber = 4,
  };
  // string backupID = 4;
  void clear_backupid();
  const std::string& backupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backupid();
  PROTOBUF_NODISCARD std::string* release_backupid();
  void set_allocated_backupid(std::string* backupid);
  private:
  const std::string& _internal_backupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backupid(const std::string& value);
  std::string* _internal_mutable_backupid();
  public:

  // @@protoc_insertion_point(class_scope:backup.RecoverBackupKeyResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backup_2eproto;
};
// -------------------------------------------------------------------

class PullBackupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backup.PullBackupRequest) */ {
 public:
  inline PullBackupRequest() : PullBackupRequest(nullptr) {}
  ~PullBackupRequest() override;
  explicit PROTOBUF_CONSTEXPR PullBackupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullBackupRequest(const PullBackupRequest& from);
  PullBackupRequest(PullBackupRequest&& from) noexcept
    : PullBackupRequest() {
    *this = ::std::move(from);
  }

  inline PullBackupRequest& operator=(const PullBackupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullBackupRequest& operator=(PullBackupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullBackupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PullBackupRequest* internal_default_instance() {
    return reinterpret_cast<const PullBackupRequest*>(
               &_PullBackupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PullBackupRequest& a, PullBackupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PullBackupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullBackupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullBackupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullBackupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PullBackupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PullBackupRequest& from) {
    PullBackupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullBackupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backup.PullBackupRequest";
  }
  protected:
  explicit PullBackupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kBackupIDFieldNumber = 2,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string backupID = 2;
  void clear_backupid();
  const std::string& backupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backupid();
  PROTOBUF_NODISCARD std::string* release_backupid();
  void set_allocated_backupid(std::string* backupid);
  private:
  const std::string& _internal_backupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backupid(const std::string& value);
  std::string* _internal_mutable_backupid();
  public:

  // @@protoc_insertion_point(class_scope:backup.PullBackupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backupid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backup_2eproto;
};
// -------------------------------------------------------------------

class PullBackupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backup.PullBackupResponse) */ {
 public:
  inline PullBackupResponse() : PullBackupResponse(nullptr) {}
  ~PullBackupResponse() override;
  explicit PROTOBUF_CONSTEXPR PullBackupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PullBackupResponse(const PullBackupResponse& from);
  PullBackupResponse(PullBackupResponse&& from) noexcept
    : PullBackupResponse() {
    *this = ::std::move(from);
  }

  inline PullBackupResponse& operator=(const PullBackupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PullBackupResponse& operator=(PullBackupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PullBackupResponse& default_instance() {
    return *internal_default_instance();
  }
  enum IdCase {
    kBackupID = 1,
    kLogID = 2,
    ID_NOT_SET = 0,
  };

  enum DataCase {
    kCompactionChunk = 3,
    kLogChunk = 4,
    DATA_NOT_SET = 0,
  };

  static inline const PullBackupResponse* internal_default_instance() {
    return reinterpret_cast<const PullBackupResponse*>(
               &_PullBackupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PullBackupResponse& a, PullBackupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PullBackupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PullBackupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PullBackupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PullBackupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PullBackupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PullBackupResponse& from) {
    PullBackupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PullBackupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backup.PullBackupResponse";
  }
  protected:
  explicit PullBackupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttachmentHoldersFieldNumber = 5,
    kBackupIDFieldNumber = 1,
    kLogIDFieldNumber = 2,
    kCompactionChunkFieldNumber = 3,
    kLogChunkFieldNumber = 4,
  };
  // optional string attachmentHolders = 5;
  bool has_attachmentholders() const;
  private:
  bool _internal_has_attachmentholders() const;
  public:
  void clear_attachmentholders();
  const std::string& attachmentholders() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_attachmentholders(ArgT0&& arg0, ArgT... args);
  std::string* mutable_attachmentholders();
  PROTOBUF_NODISCARD std::string* release_attachmentholders();
  void set_allocated_attachmentholders(std::string* attachmentholders);
  private:
  const std::string& _internal_attachmentholders() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_attachmentholders(const std::string& value);
  std::string* _internal_mutable_attachmentholders();
  public:

  // string backupID = 1;
  bool has_backupid() const;
  private:
  bool _internal_has_backupid() const;
  public:
  void clear_backupid();
  const std::string& backupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backupid();
  PROTOBUF_NODISCARD std::string* release_backupid();
  void set_allocated_backupid(std::string* backupid);
  private:
  const std::string& _internal_backupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backupid(const std::string& value);
  std::string* _internal_mutable_backupid();
  public:

  // string logID = 2;
  bool has_logid() const;
  private:
  bool _internal_has_logid() const;
  public:
  void clear_logid();
  const std::string& logid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logid();
  PROTOBUF_NODISCARD std::string* release_logid();
  void set_allocated_logid(std::string* logid);
  private:
  const std::string& _internal_logid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logid(const std::string& value);
  std::string* _internal_mutable_logid();
  public:

  // bytes compactionChunk = 3;
  bool has_compactionchunk() const;
  private:
  bool _internal_has_compactionchunk() const;
  public:
  void clear_compactionchunk();
  const std::string& compactionchunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_compactionchunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_compactionchunk();
  PROTOBUF_NODISCARD std::string* release_compactionchunk();
  void set_allocated_compactionchunk(std::string* compactionchunk);
  private:
  const std::string& _internal_compactionchunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_compactionchunk(const std::string& value);
  std::string* _internal_mutable_compactionchunk();
  public:

  // bytes logChunk = 4;
  bool has_logchunk() const;
  private:
  bool _internal_has_logchunk() const;
  public:
  void clear_logchunk();
  const std::string& logchunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logchunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logchunk();
  PROTOBUF_NODISCARD std::string* release_logchunk();
  void set_allocated_logchunk(std::string* logchunk);
  private:
  const std::string& _internal_logchunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logchunk(const std::string& value);
  std::string* _internal_mutable_logchunk();
  public:

  void clear_id();
  IdCase id_case() const;
  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:backup.PullBackupResponse)
 private:
  class _Internal;
  void set_has_backupid();
  void set_has_logid();
  void set_has_compactionchunk();
  void set_has_logchunk();

  inline bool has_id() const;
  inline void clear_has_id();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr attachmentholders_;
    union IdUnion {
      constexpr IdUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backupid_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logid_;
    } id_;
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr compactionchunk_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logchunk_;
    } data_;
    uint32_t _oneof_case_[2];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backup_2eproto;
};
// -------------------------------------------------------------------

class AddAttachmentsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:backup.AddAttachmentsRequest) */ {
 public:
  inline AddAttachmentsRequest() : AddAttachmentsRequest(nullptr) {}
  ~AddAttachmentsRequest() override;
  explicit PROTOBUF_CONSTEXPR AddAttachmentsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddAttachmentsRequest(const AddAttachmentsRequest& from);
  AddAttachmentsRequest(AddAttachmentsRequest&& from) noexcept
    : AddAttachmentsRequest() {
    *this = ::std::move(from);
  }

  inline AddAttachmentsRequest& operator=(const AddAttachmentsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddAttachmentsRequest& operator=(AddAttachmentsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddAttachmentsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddAttachmentsRequest* internal_default_instance() {
    return reinterpret_cast<const AddAttachmentsRequest*>(
               &_AddAttachmentsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AddAttachmentsRequest& a, AddAttachmentsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddAttachmentsRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddAttachmentsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddAttachmentsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddAttachmentsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddAttachmentsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddAttachmentsRequest& from) {
    AddAttachmentsRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddAttachmentsRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "backup.AddAttachmentsRequest";
  }
  protected:
  explicit AddAttachmentsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kBackupIDFieldNumber = 2,
    kLogIDFieldNumber = 3,
    kHoldersFieldNumber = 4,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string backupID = 2;
  void clear_backupid();
  const std::string& backupid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_backupid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_backupid();
  PROTOBUF_NODISCARD std::string* release_backupid();
  void set_allocated_backupid(std::string* backupid);
  private:
  const std::string& _internal_backupid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_backupid(const std::string& value);
  std::string* _internal_mutable_backupid();
  public:

  // string logID = 3;
  void clear_logid();
  const std::string& logid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_logid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_logid();
  PROTOBUF_NODISCARD std::string* release_logid();
  void set_allocated_logid(std::string* logid);
  private:
  const std::string& _internal_logid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_logid(const std::string& value);
  std::string* _internal_mutable_logid();
  public:

  // string holders = 4;
  void clear_holders();
  const std::string& holders() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_holders(ArgT0&& arg0, ArgT... args);
  std::string* mutable_holders();
  PROTOBUF_NODISCARD std::string* release_holders();
  void set_allocated_holders(std::string* holders);
  private:
  const std::string& _internal_holders() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_holders(const std::string& value);
  std::string* _internal_mutable_holders();
  public:

  // @@protoc_insertion_point(class_scope:backup.AddAttachmentsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr backupid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr logid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr holders_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_backup_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CreateNewBackupRequest

// string userID = 1;
inline bool CreateNewBackupRequest::_internal_has_userid() const {
  return data_case() == kUserID;
}
inline bool CreateNewBackupRequest::has_userid() const {
  return _internal_has_userid();
}
inline void CreateNewBackupRequest::set_has_userid() {
  _impl_._oneof_case_[0] = kUserID;
}
inline void CreateNewBackupRequest::clear_userid() {
  if (_internal_has_userid()) {
    _impl_.data_.userid_.Destroy();
    clear_has_data();
  }
}
inline const std::string& CreateNewBackupRequest::userid() const {
  // @@protoc_insertion_point(field_get:backup.CreateNewBackupRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline void CreateNewBackupRequest::set_userid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_userid()) {
    clear_data();
    set_has_userid();
    _impl_.data_.userid_.InitDefault();
  }
  _impl_.data_.userid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.CreateNewBackupRequest.userID)
}
inline std::string* CreateNewBackupRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:backup.CreateNewBackupRequest.userID)
  return _s;
}
inline const std::string& CreateNewBackupRequest::_internal_userid() const {
  if (_internal_has_userid()) {
    return _impl_.data_.userid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateNewBackupRequest::_internal_set_userid(const std::string& value) {
  if (!_internal_has_userid()) {
    clear_data();
    set_has_userid();
    _impl_.data_.userid_.InitDefault();
  }
  _impl_.data_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::_internal_mutable_userid() {
  if (!_internal_has_userid()) {
    clear_data();
    set_has_userid();
    _impl_.data_.userid_.InitDefault();
  }
  return _impl_.data_.userid_.Mutable(      GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::release_userid() {
  // @@protoc_insertion_point(field_release:backup.CreateNewBackupRequest.userID)
  if (_internal_has_userid()) {
    clear_has_data();
    return _impl_.data_.userid_.Release();
  } else {
    return nullptr;
  }
}
inline void CreateNewBackupRequest::set_allocated_userid(std::string* userid) {
  if (has_data()) {
    clear_data();
  }
  if (userid != nullptr) {
    set_has_userid();
    _impl_.data_.userid_.InitAllocated(userid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.CreateNewBackupRequest.userID)
}

// string deviceID = 2;
inline bool CreateNewBackupRequest::_internal_has_deviceid() const {
  return data_case() == kDeviceID;
}
inline bool CreateNewBackupRequest::has_deviceid() const {
  return _internal_has_deviceid();
}
inline void CreateNewBackupRequest::set_has_deviceid() {
  _impl_._oneof_case_[0] = kDeviceID;
}
inline void CreateNewBackupRequest::clear_deviceid() {
  if (_internal_has_deviceid()) {
    _impl_.data_.deviceid_.Destroy();
    clear_has_data();
  }
}
inline const std::string& CreateNewBackupRequest::deviceid() const {
  // @@protoc_insertion_point(field_get:backup.CreateNewBackupRequest.deviceID)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline void CreateNewBackupRequest::set_deviceid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_deviceid()) {
    clear_data();
    set_has_deviceid();
    _impl_.data_.deviceid_.InitDefault();
  }
  _impl_.data_.deviceid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.CreateNewBackupRequest.deviceID)
}
inline std::string* CreateNewBackupRequest::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:backup.CreateNewBackupRequest.deviceID)
  return _s;
}
inline const std::string& CreateNewBackupRequest::_internal_deviceid() const {
  if (_internal_has_deviceid()) {
    return _impl_.data_.deviceid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateNewBackupRequest::_internal_set_deviceid(const std::string& value) {
  if (!_internal_has_deviceid()) {
    clear_data();
    set_has_deviceid();
    _impl_.data_.deviceid_.InitDefault();
  }
  _impl_.data_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::_internal_mutable_deviceid() {
  if (!_internal_has_deviceid()) {
    clear_data();
    set_has_deviceid();
    _impl_.data_.deviceid_.InitDefault();
  }
  return _impl_.data_.deviceid_.Mutable(      GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::release_deviceid() {
  // @@protoc_insertion_point(field_release:backup.CreateNewBackupRequest.deviceID)
  if (_internal_has_deviceid()) {
    clear_has_data();
    return _impl_.data_.deviceid_.Release();
  } else {
    return nullptr;
  }
}
inline void CreateNewBackupRequest::set_allocated_deviceid(std::string* deviceid) {
  if (has_data()) {
    clear_data();
  }
  if (deviceid != nullptr) {
    set_has_deviceid();
    _impl_.data_.deviceid_.InitAllocated(deviceid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.CreateNewBackupRequest.deviceID)
}

// bytes keyEntropy = 3;
inline bool CreateNewBackupRequest::_internal_has_keyentropy() const {
  return data_case() == kKeyEntropy;
}
inline bool CreateNewBackupRequest::has_keyentropy() const {
  return _internal_has_keyentropy();
}
inline void CreateNewBackupRequest::set_has_keyentropy() {
  _impl_._oneof_case_[0] = kKeyEntropy;
}
inline void CreateNewBackupRequest::clear_keyentropy() {
  if (_internal_has_keyentropy()) {
    _impl_.data_.keyentropy_.Destroy();
    clear_has_data();
  }
}
inline const std::string& CreateNewBackupRequest::keyentropy() const {
  // @@protoc_insertion_point(field_get:backup.CreateNewBackupRequest.keyEntropy)
  return _internal_keyentropy();
}
template <typename ArgT0, typename... ArgT>
inline void CreateNewBackupRequest::set_keyentropy(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_keyentropy()) {
    clear_data();
    set_has_keyentropy();
    _impl_.data_.keyentropy_.InitDefault();
  }
  _impl_.data_.keyentropy_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.CreateNewBackupRequest.keyEntropy)
}
inline std::string* CreateNewBackupRequest::mutable_keyentropy() {
  std::string* _s = _internal_mutable_keyentropy();
  // @@protoc_insertion_point(field_mutable:backup.CreateNewBackupRequest.keyEntropy)
  return _s;
}
inline const std::string& CreateNewBackupRequest::_internal_keyentropy() const {
  if (_internal_has_keyentropy()) {
    return _impl_.data_.keyentropy_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateNewBackupRequest::_internal_set_keyentropy(const std::string& value) {
  if (!_internal_has_keyentropy()) {
    clear_data();
    set_has_keyentropy();
    _impl_.data_.keyentropy_.InitDefault();
  }
  _impl_.data_.keyentropy_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::_internal_mutable_keyentropy() {
  if (!_internal_has_keyentropy()) {
    clear_data();
    set_has_keyentropy();
    _impl_.data_.keyentropy_.InitDefault();
  }
  return _impl_.data_.keyentropy_.Mutable(      GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::release_keyentropy() {
  // @@protoc_insertion_point(field_release:backup.CreateNewBackupRequest.keyEntropy)
  if (_internal_has_keyentropy()) {
    clear_has_data();
    return _impl_.data_.keyentropy_.Release();
  } else {
    return nullptr;
  }
}
inline void CreateNewBackupRequest::set_allocated_keyentropy(std::string* keyentropy) {
  if (has_data()) {
    clear_data();
  }
  if (keyentropy != nullptr) {
    set_has_keyentropy();
    _impl_.data_.keyentropy_.InitAllocated(keyentropy, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.CreateNewBackupRequest.keyEntropy)
}

// bytes newCompactionHash = 4;
inline bool CreateNewBackupRequest::_internal_has_newcompactionhash() const {
  return data_case() == kNewCompactionHash;
}
inline bool CreateNewBackupRequest::has_newcompactionhash() const {
  return _internal_has_newcompactionhash();
}
inline void CreateNewBackupRequest::set_has_newcompactionhash() {
  _impl_._oneof_case_[0] = kNewCompactionHash;
}
inline void CreateNewBackupRequest::clear_newcompactionhash() {
  if (_internal_has_newcompactionhash()) {
    _impl_.data_.newcompactionhash_.Destroy();
    clear_has_data();
  }
}
inline const std::string& CreateNewBackupRequest::newcompactionhash() const {
  // @@protoc_insertion_point(field_get:backup.CreateNewBackupRequest.newCompactionHash)
  return _internal_newcompactionhash();
}
template <typename ArgT0, typename... ArgT>
inline void CreateNewBackupRequest::set_newcompactionhash(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_newcompactionhash()) {
    clear_data();
    set_has_newcompactionhash();
    _impl_.data_.newcompactionhash_.InitDefault();
  }
  _impl_.data_.newcompactionhash_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.CreateNewBackupRequest.newCompactionHash)
}
inline std::string* CreateNewBackupRequest::mutable_newcompactionhash() {
  std::string* _s = _internal_mutable_newcompactionhash();
  // @@protoc_insertion_point(field_mutable:backup.CreateNewBackupRequest.newCompactionHash)
  return _s;
}
inline const std::string& CreateNewBackupRequest::_internal_newcompactionhash() const {
  if (_internal_has_newcompactionhash()) {
    return _impl_.data_.newcompactionhash_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateNewBackupRequest::_internal_set_newcompactionhash(const std::string& value) {
  if (!_internal_has_newcompactionhash()) {
    clear_data();
    set_has_newcompactionhash();
    _impl_.data_.newcompactionhash_.InitDefault();
  }
  _impl_.data_.newcompactionhash_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::_internal_mutable_newcompactionhash() {
  if (!_internal_has_newcompactionhash()) {
    clear_data();
    set_has_newcompactionhash();
    _impl_.data_.newcompactionhash_.InitDefault();
  }
  return _impl_.data_.newcompactionhash_.Mutable(      GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::release_newcompactionhash() {
  // @@protoc_insertion_point(field_release:backup.CreateNewBackupRequest.newCompactionHash)
  if (_internal_has_newcompactionhash()) {
    clear_has_data();
    return _impl_.data_.newcompactionhash_.Release();
  } else {
    return nullptr;
  }
}
inline void CreateNewBackupRequest::set_allocated_newcompactionhash(std::string* newcompactionhash) {
  if (has_data()) {
    clear_data();
  }
  if (newcompactionhash != nullptr) {
    set_has_newcompactionhash();
    _impl_.data_.newcompactionhash_.InitAllocated(newcompactionhash, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.CreateNewBackupRequest.newCompactionHash)
}

// bytes newCompactionChunk = 5;
inline bool CreateNewBackupRequest::_internal_has_newcompactionchunk() const {
  return data_case() == kNewCompactionChunk;
}
inline bool CreateNewBackupRequest::has_newcompactionchunk() const {
  return _internal_has_newcompactionchunk();
}
inline void CreateNewBackupRequest::set_has_newcompactionchunk() {
  _impl_._oneof_case_[0] = kNewCompactionChunk;
}
inline void CreateNewBackupRequest::clear_newcompactionchunk() {
  if (_internal_has_newcompactionchunk()) {
    _impl_.data_.newcompactionchunk_.Destroy();
    clear_has_data();
  }
}
inline const std::string& CreateNewBackupRequest::newcompactionchunk() const {
  // @@protoc_insertion_point(field_get:backup.CreateNewBackupRequest.newCompactionChunk)
  return _internal_newcompactionchunk();
}
template <typename ArgT0, typename... ArgT>
inline void CreateNewBackupRequest::set_newcompactionchunk(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_newcompactionchunk()) {
    clear_data();
    set_has_newcompactionchunk();
    _impl_.data_.newcompactionchunk_.InitDefault();
  }
  _impl_.data_.newcompactionchunk_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.CreateNewBackupRequest.newCompactionChunk)
}
inline std::string* CreateNewBackupRequest::mutable_newcompactionchunk() {
  std::string* _s = _internal_mutable_newcompactionchunk();
  // @@protoc_insertion_point(field_mutable:backup.CreateNewBackupRequest.newCompactionChunk)
  return _s;
}
inline const std::string& CreateNewBackupRequest::_internal_newcompactionchunk() const {
  if (_internal_has_newcompactionchunk()) {
    return _impl_.data_.newcompactionchunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CreateNewBackupRequest::_internal_set_newcompactionchunk(const std::string& value) {
  if (!_internal_has_newcompactionchunk()) {
    clear_data();
    set_has_newcompactionchunk();
    _impl_.data_.newcompactionchunk_.InitDefault();
  }
  _impl_.data_.newcompactionchunk_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::_internal_mutable_newcompactionchunk() {
  if (!_internal_has_newcompactionchunk()) {
    clear_data();
    set_has_newcompactionchunk();
    _impl_.data_.newcompactionchunk_.InitDefault();
  }
  return _impl_.data_.newcompactionchunk_.Mutable(      GetArenaForAllocation());
}
inline std::string* CreateNewBackupRequest::release_newcompactionchunk() {
  // @@protoc_insertion_point(field_release:backup.CreateNewBackupRequest.newCompactionChunk)
  if (_internal_has_newcompactionchunk()) {
    clear_has_data();
    return _impl_.data_.newcompactionchunk_.Release();
  } else {
    return nullptr;
  }
}
inline void CreateNewBackupRequest::set_allocated_newcompactionchunk(std::string* newcompactionchunk) {
  if (has_data()) {
    clear_data();
  }
  if (newcompactionchunk != nullptr) {
    set_has_newcompactionchunk();
    _impl_.data_.newcompactionchunk_.InitAllocated(newcompactionchunk, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.CreateNewBackupRequest.newCompactionChunk)
}

inline bool CreateNewBackupRequest::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void CreateNewBackupRequest::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline CreateNewBackupRequest::DataCase CreateNewBackupRequest::data_case() const {
  return CreateNewBackupRequest::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// CreateNewBackupResponse

// string backupID = 1;
inline void CreateNewBackupResponse::clear_backupid() {
  _impl_.backupid_.ClearToEmpty();
}
inline const std::string& CreateNewBackupResponse::backupid() const {
  // @@protoc_insertion_point(field_get:backup.CreateNewBackupResponse.backupID)
  return _internal_backupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateNewBackupResponse::set_backupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.backupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.CreateNewBackupResponse.backupID)
}
inline std::string* CreateNewBackupResponse::mutable_backupid() {
  std::string* _s = _internal_mutable_backupid();
  // @@protoc_insertion_point(field_mutable:backup.CreateNewBackupResponse.backupID)
  return _s;
}
inline const std::string& CreateNewBackupResponse::_internal_backupid() const {
  return _impl_.backupid_.Get();
}
inline void CreateNewBackupResponse::_internal_set_backupid(const std::string& value) {
  
  _impl_.backupid_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateNewBackupResponse::_internal_mutable_backupid() {
  
  return _impl_.backupid_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateNewBackupResponse::release_backupid() {
  // @@protoc_insertion_point(field_release:backup.CreateNewBackupResponse.backupID)
  return _impl_.backupid_.Release();
}
inline void CreateNewBackupResponse::set_allocated_backupid(std::string* backupid) {
  if (backupid != nullptr) {
    
  } else {
    
  }
  _impl_.backupid_.SetAllocated(backupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backupid_.IsDefault()) {
    _impl_.backupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.CreateNewBackupResponse.backupID)
}

// -------------------------------------------------------------------

// SendLogRequest

// string userID = 1;
inline bool SendLogRequest::_internal_has_userid() const {
  return data_case() == kUserID;
}
inline bool SendLogRequest::has_userid() const {
  return _internal_has_userid();
}
inline void SendLogRequest::set_has_userid() {
  _impl_._oneof_case_[0] = kUserID;
}
inline void SendLogRequest::clear_userid() {
  if (_internal_has_userid()) {
    _impl_.data_.userid_.Destroy();
    clear_has_data();
  }
}
inline const std::string& SendLogRequest::userid() const {
  // @@protoc_insertion_point(field_get:backup.SendLogRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline void SendLogRequest::set_userid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_userid()) {
    clear_data();
    set_has_userid();
    _impl_.data_.userid_.InitDefault();
  }
  _impl_.data_.userid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.SendLogRequest.userID)
}
inline std::string* SendLogRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:backup.SendLogRequest.userID)
  return _s;
}
inline const std::string& SendLogRequest::_internal_userid() const {
  if (_internal_has_userid()) {
    return _impl_.data_.userid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SendLogRequest::_internal_set_userid(const std::string& value) {
  if (!_internal_has_userid()) {
    clear_data();
    set_has_userid();
    _impl_.data_.userid_.InitDefault();
  }
  _impl_.data_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* SendLogRequest::_internal_mutable_userid() {
  if (!_internal_has_userid()) {
    clear_data();
    set_has_userid();
    _impl_.data_.userid_.InitDefault();
  }
  return _impl_.data_.userid_.Mutable(      GetArenaForAllocation());
}
inline std::string* SendLogRequest::release_userid() {
  // @@protoc_insertion_point(field_release:backup.SendLogRequest.userID)
  if (_internal_has_userid()) {
    clear_has_data();
    return _impl_.data_.userid_.Release();
  } else {
    return nullptr;
  }
}
inline void SendLogRequest::set_allocated_userid(std::string* userid) {
  if (has_data()) {
    clear_data();
  }
  if (userid != nullptr) {
    set_has_userid();
    _impl_.data_.userid_.InitAllocated(userid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.SendLogRequest.userID)
}

// string backupID = 2;
inline bool SendLogRequest::_internal_has_backupid() const {
  return data_case() == kBackupID;
}
inline bool SendLogRequest::has_backupid() const {
  return _internal_has_backupid();
}
inline void SendLogRequest::set_has_backupid() {
  _impl_._oneof_case_[0] = kBackupID;
}
inline void SendLogRequest::clear_backupid() {
  if (_internal_has_backupid()) {
    _impl_.data_.backupid_.Destroy();
    clear_has_data();
  }
}
inline const std::string& SendLogRequest::backupid() const {
  // @@protoc_insertion_point(field_get:backup.SendLogRequest.backupID)
  return _internal_backupid();
}
template <typename ArgT0, typename... ArgT>
inline void SendLogRequest::set_backupid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_backupid()) {
    clear_data();
    set_has_backupid();
    _impl_.data_.backupid_.InitDefault();
  }
  _impl_.data_.backupid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.SendLogRequest.backupID)
}
inline std::string* SendLogRequest::mutable_backupid() {
  std::string* _s = _internal_mutable_backupid();
  // @@protoc_insertion_point(field_mutable:backup.SendLogRequest.backupID)
  return _s;
}
inline const std::string& SendLogRequest::_internal_backupid() const {
  if (_internal_has_backupid()) {
    return _impl_.data_.backupid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SendLogRequest::_internal_set_backupid(const std::string& value) {
  if (!_internal_has_backupid()) {
    clear_data();
    set_has_backupid();
    _impl_.data_.backupid_.InitDefault();
  }
  _impl_.data_.backupid_.Set(value, GetArenaForAllocation());
}
inline std::string* SendLogRequest::_internal_mutable_backupid() {
  if (!_internal_has_backupid()) {
    clear_data();
    set_has_backupid();
    _impl_.data_.backupid_.InitDefault();
  }
  return _impl_.data_.backupid_.Mutable(      GetArenaForAllocation());
}
inline std::string* SendLogRequest::release_backupid() {
  // @@protoc_insertion_point(field_release:backup.SendLogRequest.backupID)
  if (_internal_has_backupid()) {
    clear_has_data();
    return _impl_.data_.backupid_.Release();
  } else {
    return nullptr;
  }
}
inline void SendLogRequest::set_allocated_backupid(std::string* backupid) {
  if (has_data()) {
    clear_data();
  }
  if (backupid != nullptr) {
    set_has_backupid();
    _impl_.data_.backupid_.InitAllocated(backupid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.SendLogRequest.backupID)
}

// bytes logHash = 3;
inline bool SendLogRequest::_internal_has_loghash() const {
  return data_case() == kLogHash;
}
inline bool SendLogRequest::has_loghash() const {
  return _internal_has_loghash();
}
inline void SendLogRequest::set_has_loghash() {
  _impl_._oneof_case_[0] = kLogHash;
}
inline void SendLogRequest::clear_loghash() {
  if (_internal_has_loghash()) {
    _impl_.data_.loghash_.Destroy();
    clear_has_data();
  }
}
inline const std::string& SendLogRequest::loghash() const {
  // @@protoc_insertion_point(field_get:backup.SendLogRequest.logHash)
  return _internal_loghash();
}
template <typename ArgT0, typename... ArgT>
inline void SendLogRequest::set_loghash(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_loghash()) {
    clear_data();
    set_has_loghash();
    _impl_.data_.loghash_.InitDefault();
  }
  _impl_.data_.loghash_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.SendLogRequest.logHash)
}
inline std::string* SendLogRequest::mutable_loghash() {
  std::string* _s = _internal_mutable_loghash();
  // @@protoc_insertion_point(field_mutable:backup.SendLogRequest.logHash)
  return _s;
}
inline const std::string& SendLogRequest::_internal_loghash() const {
  if (_internal_has_loghash()) {
    return _impl_.data_.loghash_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SendLogRequest::_internal_set_loghash(const std::string& value) {
  if (!_internal_has_loghash()) {
    clear_data();
    set_has_loghash();
    _impl_.data_.loghash_.InitDefault();
  }
  _impl_.data_.loghash_.Set(value, GetArenaForAllocation());
}
inline std::string* SendLogRequest::_internal_mutable_loghash() {
  if (!_internal_has_loghash()) {
    clear_data();
    set_has_loghash();
    _impl_.data_.loghash_.InitDefault();
  }
  return _impl_.data_.loghash_.Mutable(      GetArenaForAllocation());
}
inline std::string* SendLogRequest::release_loghash() {
  // @@protoc_insertion_point(field_release:backup.SendLogRequest.logHash)
  if (_internal_has_loghash()) {
    clear_has_data();
    return _impl_.data_.loghash_.Release();
  } else {
    return nullptr;
  }
}
inline void SendLogRequest::set_allocated_loghash(std::string* loghash) {
  if (has_data()) {
    clear_data();
  }
  if (loghash != nullptr) {
    set_has_loghash();
    _impl_.data_.loghash_.InitAllocated(loghash, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.SendLogRequest.logHash)
}

// bytes logData = 4;
inline bool SendLogRequest::_internal_has_logdata() const {
  return data_case() == kLogData;
}
inline bool SendLogRequest::has_logdata() const {
  return _internal_has_logdata();
}
inline void SendLogRequest::set_has_logdata() {
  _impl_._oneof_case_[0] = kLogData;
}
inline void SendLogRequest::clear_logdata() {
  if (_internal_has_logdata()) {
    _impl_.data_.logdata_.Destroy();
    clear_has_data();
  }
}
inline const std::string& SendLogRequest::logdata() const {
  // @@protoc_insertion_point(field_get:backup.SendLogRequest.logData)
  return _internal_logdata();
}
template <typename ArgT0, typename... ArgT>
inline void SendLogRequest::set_logdata(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_logdata()) {
    clear_data();
    set_has_logdata();
    _impl_.data_.logdata_.InitDefault();
  }
  _impl_.data_.logdata_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.SendLogRequest.logData)
}
inline std::string* SendLogRequest::mutable_logdata() {
  std::string* _s = _internal_mutable_logdata();
  // @@protoc_insertion_point(field_mutable:backup.SendLogRequest.logData)
  return _s;
}
inline const std::string& SendLogRequest::_internal_logdata() const {
  if (_internal_has_logdata()) {
    return _impl_.data_.logdata_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SendLogRequest::_internal_set_logdata(const std::string& value) {
  if (!_internal_has_logdata()) {
    clear_data();
    set_has_logdata();
    _impl_.data_.logdata_.InitDefault();
  }
  _impl_.data_.logdata_.Set(value, GetArenaForAllocation());
}
inline std::string* SendLogRequest::_internal_mutable_logdata() {
  if (!_internal_has_logdata()) {
    clear_data();
    set_has_logdata();
    _impl_.data_.logdata_.InitDefault();
  }
  return _impl_.data_.logdata_.Mutable(      GetArenaForAllocation());
}
inline std::string* SendLogRequest::release_logdata() {
  // @@protoc_insertion_point(field_release:backup.SendLogRequest.logData)
  if (_internal_has_logdata()) {
    clear_has_data();
    return _impl_.data_.logdata_.Release();
  } else {
    return nullptr;
  }
}
inline void SendLogRequest::set_allocated_logdata(std::string* logdata) {
  if (has_data()) {
    clear_data();
  }
  if (logdata != nullptr) {
    set_has_logdata();
    _impl_.data_.logdata_.InitAllocated(logdata, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.SendLogRequest.logData)
}

inline bool SendLogRequest::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void SendLogRequest::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline SendLogRequest::DataCase SendLogRequest::data_case() const {
  return SendLogRequest::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SendLogResponse

// string logCheckpoint = 1;
inline void SendLogResponse::clear_logcheckpoint() {
  _impl_.logcheckpoint_.ClearToEmpty();
}
inline const std::string& SendLogResponse::logcheckpoint() const {
  // @@protoc_insertion_point(field_get:backup.SendLogResponse.logCheckpoint)
  return _internal_logcheckpoint();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendLogResponse::set_logcheckpoint(ArgT0&& arg0, ArgT... args) {
 
 _impl_.logcheckpoint_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.SendLogResponse.logCheckpoint)
}
inline std::string* SendLogResponse::mutable_logcheckpoint() {
  std::string* _s = _internal_mutable_logcheckpoint();
  // @@protoc_insertion_point(field_mutable:backup.SendLogResponse.logCheckpoint)
  return _s;
}
inline const std::string& SendLogResponse::_internal_logcheckpoint() const {
  return _impl_.logcheckpoint_.Get();
}
inline void SendLogResponse::_internal_set_logcheckpoint(const std::string& value) {
  
  _impl_.logcheckpoint_.Set(value, GetArenaForAllocation());
}
inline std::string* SendLogResponse::_internal_mutable_logcheckpoint() {
  
  return _impl_.logcheckpoint_.Mutable(GetArenaForAllocation());
}
inline std::string* SendLogResponse::release_logcheckpoint() {
  // @@protoc_insertion_point(field_release:backup.SendLogResponse.logCheckpoint)
  return _impl_.logcheckpoint_.Release();
}
inline void SendLogResponse::set_allocated_logcheckpoint(std::string* logcheckpoint) {
  if (logcheckpoint != nullptr) {
    
  } else {
    
  }
  _impl_.logcheckpoint_.SetAllocated(logcheckpoint, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logcheckpoint_.IsDefault()) {
    _impl_.logcheckpoint_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.SendLogResponse.logCheckpoint)
}

// -------------------------------------------------------------------

// RecoverBackupKeyRequest

// string userID = 1;
inline void RecoverBackupKeyRequest::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& RecoverBackupKeyRequest::userid() const {
  // @@protoc_insertion_point(field_get:backup.RecoverBackupKeyRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecoverBackupKeyRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.RecoverBackupKeyRequest.userID)
}
inline std::string* RecoverBackupKeyRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:backup.RecoverBackupKeyRequest.userID)
  return _s;
}
inline const std::string& RecoverBackupKeyRequest::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void RecoverBackupKeyRequest::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* RecoverBackupKeyRequest::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* RecoverBackupKeyRequest::release_userid() {
  // @@protoc_insertion_point(field_release:backup.RecoverBackupKeyRequest.userID)
  return _impl_.userid_.Release();
}
inline void RecoverBackupKeyRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.RecoverBackupKeyRequest.userID)
}

// -------------------------------------------------------------------

// RecoverBackupKeyResponse

// string backupID = 4;
inline void RecoverBackupKeyResponse::clear_backupid() {
  _impl_.backupid_.ClearToEmpty();
}
inline const std::string& RecoverBackupKeyResponse::backupid() const {
  // @@protoc_insertion_point(field_get:backup.RecoverBackupKeyResponse.backupID)
  return _internal_backupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RecoverBackupKeyResponse::set_backupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.backupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.RecoverBackupKeyResponse.backupID)
}
inline std::string* RecoverBackupKeyResponse::mutable_backupid() {
  std::string* _s = _internal_mutable_backupid();
  // @@protoc_insertion_point(field_mutable:backup.RecoverBackupKeyResponse.backupID)
  return _s;
}
inline const std::string& RecoverBackupKeyResponse::_internal_backupid() const {
  return _impl_.backupid_.Get();
}
inline void RecoverBackupKeyResponse::_internal_set_backupid(const std::string& value) {
  
  _impl_.backupid_.Set(value, GetArenaForAllocation());
}
inline std::string* RecoverBackupKeyResponse::_internal_mutable_backupid() {
  
  return _impl_.backupid_.Mutable(GetArenaForAllocation());
}
inline std::string* RecoverBackupKeyResponse::release_backupid() {
  // @@protoc_insertion_point(field_release:backup.RecoverBackupKeyResponse.backupID)
  return _impl_.backupid_.Release();
}
inline void RecoverBackupKeyResponse::set_allocated_backupid(std::string* backupid) {
  if (backupid != nullptr) {
    
  } else {
    
  }
  _impl_.backupid_.SetAllocated(backupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backupid_.IsDefault()) {
    _impl_.backupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.RecoverBackupKeyResponse.backupID)
}

// -------------------------------------------------------------------

// PullBackupRequest

// string userID = 1;
inline void PullBackupRequest::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& PullBackupRequest::userid() const {
  // @@protoc_insertion_point(field_get:backup.PullBackupRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PullBackupRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.PullBackupRequest.userID)
}
inline std::string* PullBackupRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:backup.PullBackupRequest.userID)
  return _s;
}
inline const std::string& PullBackupRequest::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void PullBackupRequest::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* PullBackupRequest::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* PullBackupRequest::release_userid() {
  // @@protoc_insertion_point(field_release:backup.PullBackupRequest.userID)
  return _impl_.userid_.Release();
}
inline void PullBackupRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.PullBackupRequest.userID)
}

// string backupID = 2;
inline void PullBackupRequest::clear_backupid() {
  _impl_.backupid_.ClearToEmpty();
}
inline const std::string& PullBackupRequest::backupid() const {
  // @@protoc_insertion_point(field_get:backup.PullBackupRequest.backupID)
  return _internal_backupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PullBackupRequest::set_backupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.backupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.PullBackupRequest.backupID)
}
inline std::string* PullBackupRequest::mutable_backupid() {
  std::string* _s = _internal_mutable_backupid();
  // @@protoc_insertion_point(field_mutable:backup.PullBackupRequest.backupID)
  return _s;
}
inline const std::string& PullBackupRequest::_internal_backupid() const {
  return _impl_.backupid_.Get();
}
inline void PullBackupRequest::_internal_set_backupid(const std::string& value) {
  
  _impl_.backupid_.Set(value, GetArenaForAllocation());
}
inline std::string* PullBackupRequest::_internal_mutable_backupid() {
  
  return _impl_.backupid_.Mutable(GetArenaForAllocation());
}
inline std::string* PullBackupRequest::release_backupid() {
  // @@protoc_insertion_point(field_release:backup.PullBackupRequest.backupID)
  return _impl_.backupid_.Release();
}
inline void PullBackupRequest::set_allocated_backupid(std::string* backupid) {
  if (backupid != nullptr) {
    
  } else {
    
  }
  _impl_.backupid_.SetAllocated(backupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backupid_.IsDefault()) {
    _impl_.backupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.PullBackupRequest.backupID)
}

// -------------------------------------------------------------------

// PullBackupResponse

// string backupID = 1;
inline bool PullBackupResponse::_internal_has_backupid() const {
  return id_case() == kBackupID;
}
inline bool PullBackupResponse::has_backupid() const {
  return _internal_has_backupid();
}
inline void PullBackupResponse::set_has_backupid() {
  _impl_._oneof_case_[0] = kBackupID;
}
inline void PullBackupResponse::clear_backupid() {
  if (_internal_has_backupid()) {
    _impl_.id_.backupid_.Destroy();
    clear_has_id();
  }
}
inline const std::string& PullBackupResponse::backupid() const {
  // @@protoc_insertion_point(field_get:backup.PullBackupResponse.backupID)
  return _internal_backupid();
}
template <typename ArgT0, typename... ArgT>
inline void PullBackupResponse::set_backupid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_backupid()) {
    clear_id();
    set_has_backupid();
    _impl_.id_.backupid_.InitDefault();
  }
  _impl_.id_.backupid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.PullBackupResponse.backupID)
}
inline std::string* PullBackupResponse::mutable_backupid() {
  std::string* _s = _internal_mutable_backupid();
  // @@protoc_insertion_point(field_mutable:backup.PullBackupResponse.backupID)
  return _s;
}
inline const std::string& PullBackupResponse::_internal_backupid() const {
  if (_internal_has_backupid()) {
    return _impl_.id_.backupid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PullBackupResponse::_internal_set_backupid(const std::string& value) {
  if (!_internal_has_backupid()) {
    clear_id();
    set_has_backupid();
    _impl_.id_.backupid_.InitDefault();
  }
  _impl_.id_.backupid_.Set(value, GetArenaForAllocation());
}
inline std::string* PullBackupResponse::_internal_mutable_backupid() {
  if (!_internal_has_backupid()) {
    clear_id();
    set_has_backupid();
    _impl_.id_.backupid_.InitDefault();
  }
  return _impl_.id_.backupid_.Mutable(      GetArenaForAllocation());
}
inline std::string* PullBackupResponse::release_backupid() {
  // @@protoc_insertion_point(field_release:backup.PullBackupResponse.backupID)
  if (_internal_has_backupid()) {
    clear_has_id();
    return _impl_.id_.backupid_.Release();
  } else {
    return nullptr;
  }
}
inline void PullBackupResponse::set_allocated_backupid(std::string* backupid) {
  if (has_id()) {
    clear_id();
  }
  if (backupid != nullptr) {
    set_has_backupid();
    _impl_.id_.backupid_.InitAllocated(backupid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.PullBackupResponse.backupID)
}

// string logID = 2;
inline bool PullBackupResponse::_internal_has_logid() const {
  return id_case() == kLogID;
}
inline bool PullBackupResponse::has_logid() const {
  return _internal_has_logid();
}
inline void PullBackupResponse::set_has_logid() {
  _impl_._oneof_case_[0] = kLogID;
}
inline void PullBackupResponse::clear_logid() {
  if (_internal_has_logid()) {
    _impl_.id_.logid_.Destroy();
    clear_has_id();
  }
}
inline const std::string& PullBackupResponse::logid() const {
  // @@protoc_insertion_point(field_get:backup.PullBackupResponse.logID)
  return _internal_logid();
}
template <typename ArgT0, typename... ArgT>
inline void PullBackupResponse::set_logid(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_logid()) {
    clear_id();
    set_has_logid();
    _impl_.id_.logid_.InitDefault();
  }
  _impl_.id_.logid_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.PullBackupResponse.logID)
}
inline std::string* PullBackupResponse::mutable_logid() {
  std::string* _s = _internal_mutable_logid();
  // @@protoc_insertion_point(field_mutable:backup.PullBackupResponse.logID)
  return _s;
}
inline const std::string& PullBackupResponse::_internal_logid() const {
  if (_internal_has_logid()) {
    return _impl_.id_.logid_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PullBackupResponse::_internal_set_logid(const std::string& value) {
  if (!_internal_has_logid()) {
    clear_id();
    set_has_logid();
    _impl_.id_.logid_.InitDefault();
  }
  _impl_.id_.logid_.Set(value, GetArenaForAllocation());
}
inline std::string* PullBackupResponse::_internal_mutable_logid() {
  if (!_internal_has_logid()) {
    clear_id();
    set_has_logid();
    _impl_.id_.logid_.InitDefault();
  }
  return _impl_.id_.logid_.Mutable(      GetArenaForAllocation());
}
inline std::string* PullBackupResponse::release_logid() {
  // @@protoc_insertion_point(field_release:backup.PullBackupResponse.logID)
  if (_internal_has_logid()) {
    clear_has_id();
    return _impl_.id_.logid_.Release();
  } else {
    return nullptr;
  }
}
inline void PullBackupResponse::set_allocated_logid(std::string* logid) {
  if (has_id()) {
    clear_id();
  }
  if (logid != nullptr) {
    set_has_logid();
    _impl_.id_.logid_.InitAllocated(logid, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.PullBackupResponse.logID)
}

// bytes compactionChunk = 3;
inline bool PullBackupResponse::_internal_has_compactionchunk() const {
  return data_case() == kCompactionChunk;
}
inline bool PullBackupResponse::has_compactionchunk() const {
  return _internal_has_compactionchunk();
}
inline void PullBackupResponse::set_has_compactionchunk() {
  _impl_._oneof_case_[1] = kCompactionChunk;
}
inline void PullBackupResponse::clear_compactionchunk() {
  if (_internal_has_compactionchunk()) {
    _impl_.data_.compactionchunk_.Destroy();
    clear_has_data();
  }
}
inline const std::string& PullBackupResponse::compactionchunk() const {
  // @@protoc_insertion_point(field_get:backup.PullBackupResponse.compactionChunk)
  return _internal_compactionchunk();
}
template <typename ArgT0, typename... ArgT>
inline void PullBackupResponse::set_compactionchunk(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_compactionchunk()) {
    clear_data();
    set_has_compactionchunk();
    _impl_.data_.compactionchunk_.InitDefault();
  }
  _impl_.data_.compactionchunk_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.PullBackupResponse.compactionChunk)
}
inline std::string* PullBackupResponse::mutable_compactionchunk() {
  std::string* _s = _internal_mutable_compactionchunk();
  // @@protoc_insertion_point(field_mutable:backup.PullBackupResponse.compactionChunk)
  return _s;
}
inline const std::string& PullBackupResponse::_internal_compactionchunk() const {
  if (_internal_has_compactionchunk()) {
    return _impl_.data_.compactionchunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PullBackupResponse::_internal_set_compactionchunk(const std::string& value) {
  if (!_internal_has_compactionchunk()) {
    clear_data();
    set_has_compactionchunk();
    _impl_.data_.compactionchunk_.InitDefault();
  }
  _impl_.data_.compactionchunk_.Set(value, GetArenaForAllocation());
}
inline std::string* PullBackupResponse::_internal_mutable_compactionchunk() {
  if (!_internal_has_compactionchunk()) {
    clear_data();
    set_has_compactionchunk();
    _impl_.data_.compactionchunk_.InitDefault();
  }
  return _impl_.data_.compactionchunk_.Mutable(      GetArenaForAllocation());
}
inline std::string* PullBackupResponse::release_compactionchunk() {
  // @@protoc_insertion_point(field_release:backup.PullBackupResponse.compactionChunk)
  if (_internal_has_compactionchunk()) {
    clear_has_data();
    return _impl_.data_.compactionchunk_.Release();
  } else {
    return nullptr;
  }
}
inline void PullBackupResponse::set_allocated_compactionchunk(std::string* compactionchunk) {
  if (has_data()) {
    clear_data();
  }
  if (compactionchunk != nullptr) {
    set_has_compactionchunk();
    _impl_.data_.compactionchunk_.InitAllocated(compactionchunk, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.PullBackupResponse.compactionChunk)
}

// bytes logChunk = 4;
inline bool PullBackupResponse::_internal_has_logchunk() const {
  return data_case() == kLogChunk;
}
inline bool PullBackupResponse::has_logchunk() const {
  return _internal_has_logchunk();
}
inline void PullBackupResponse::set_has_logchunk() {
  _impl_._oneof_case_[1] = kLogChunk;
}
inline void PullBackupResponse::clear_logchunk() {
  if (_internal_has_logchunk()) {
    _impl_.data_.logchunk_.Destroy();
    clear_has_data();
  }
}
inline const std::string& PullBackupResponse::logchunk() const {
  // @@protoc_insertion_point(field_get:backup.PullBackupResponse.logChunk)
  return _internal_logchunk();
}
template <typename ArgT0, typename... ArgT>
inline void PullBackupResponse::set_logchunk(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_logchunk()) {
    clear_data();
    set_has_logchunk();
    _impl_.data_.logchunk_.InitDefault();
  }
  _impl_.data_.logchunk_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.PullBackupResponse.logChunk)
}
inline std::string* PullBackupResponse::mutable_logchunk() {
  std::string* _s = _internal_mutable_logchunk();
  // @@protoc_insertion_point(field_mutable:backup.PullBackupResponse.logChunk)
  return _s;
}
inline const std::string& PullBackupResponse::_internal_logchunk() const {
  if (_internal_has_logchunk()) {
    return _impl_.data_.logchunk_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PullBackupResponse::_internal_set_logchunk(const std::string& value) {
  if (!_internal_has_logchunk()) {
    clear_data();
    set_has_logchunk();
    _impl_.data_.logchunk_.InitDefault();
  }
  _impl_.data_.logchunk_.Set(value, GetArenaForAllocation());
}
inline std::string* PullBackupResponse::_internal_mutable_logchunk() {
  if (!_internal_has_logchunk()) {
    clear_data();
    set_has_logchunk();
    _impl_.data_.logchunk_.InitDefault();
  }
  return _impl_.data_.logchunk_.Mutable(      GetArenaForAllocation());
}
inline std::string* PullBackupResponse::release_logchunk() {
  // @@protoc_insertion_point(field_release:backup.PullBackupResponse.logChunk)
  if (_internal_has_logchunk()) {
    clear_has_data();
    return _impl_.data_.logchunk_.Release();
  } else {
    return nullptr;
  }
}
inline void PullBackupResponse::set_allocated_logchunk(std::string* logchunk) {
  if (has_data()) {
    clear_data();
  }
  if (logchunk != nullptr) {
    set_has_logchunk();
    _impl_.data_.logchunk_.InitAllocated(logchunk, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:backup.PullBackupResponse.logChunk)
}

// optional string attachmentHolders = 5;
inline bool PullBackupResponse::_internal_has_attachmentholders() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool PullBackupResponse::has_attachmentholders() const {
  return _internal_has_attachmentholders();
}
inline void PullBackupResponse::clear_attachmentholders() {
  _impl_.attachmentholders_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& PullBackupResponse::attachmentholders() const {
  // @@protoc_insertion_point(field_get:backup.PullBackupResponse.attachmentHolders)
  return _internal_attachmentholders();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PullBackupResponse::set_attachmentholders(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.attachmentholders_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.PullBackupResponse.attachmentHolders)
}
inline std::string* PullBackupResponse::mutable_attachmentholders() {
  std::string* _s = _internal_mutable_attachmentholders();
  // @@protoc_insertion_point(field_mutable:backup.PullBackupResponse.attachmentHolders)
  return _s;
}
inline const std::string& PullBackupResponse::_internal_attachmentholders() const {
  return _impl_.attachmentholders_.Get();
}
inline void PullBackupResponse::_internal_set_attachmentholders(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.attachmentholders_.Set(value, GetArenaForAllocation());
}
inline std::string* PullBackupResponse::_internal_mutable_attachmentholders() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.attachmentholders_.Mutable(GetArenaForAllocation());
}
inline std::string* PullBackupResponse::release_attachmentholders() {
  // @@protoc_insertion_point(field_release:backup.PullBackupResponse.attachmentHolders)
  if (!_internal_has_attachmentholders()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.attachmentholders_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentholders_.IsDefault()) {
    _impl_.attachmentholders_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void PullBackupResponse::set_allocated_attachmentholders(std::string* attachmentholders) {
  if (attachmentholders != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.attachmentholders_.SetAllocated(attachmentholders, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.attachmentholders_.IsDefault()) {
    _impl_.attachmentholders_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.PullBackupResponse.attachmentHolders)
}

inline bool PullBackupResponse::has_id() const {
  return id_case() != ID_NOT_SET;
}
inline void PullBackupResponse::clear_has_id() {
  _impl_._oneof_case_[0] = ID_NOT_SET;
}
inline bool PullBackupResponse::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void PullBackupResponse::clear_has_data() {
  _impl_._oneof_case_[1] = DATA_NOT_SET;
}
inline PullBackupResponse::IdCase PullBackupResponse::id_case() const {
  return PullBackupResponse::IdCase(_impl_._oneof_case_[0]);
}
inline PullBackupResponse::DataCase PullBackupResponse::data_case() const {
  return PullBackupResponse::DataCase(_impl_._oneof_case_[1]);
}
// -------------------------------------------------------------------

// AddAttachmentsRequest

// string userID = 1;
inline void AddAttachmentsRequest::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& AddAttachmentsRequest::userid() const {
  // @@protoc_insertion_point(field_get:backup.AddAttachmentsRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddAttachmentsRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.AddAttachmentsRequest.userID)
}
inline std::string* AddAttachmentsRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:backup.AddAttachmentsRequest.userID)
  return _s;
}
inline const std::string& AddAttachmentsRequest::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void AddAttachmentsRequest::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* AddAttachmentsRequest::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* AddAttachmentsRequest::release_userid() {
  // @@protoc_insertion_point(field_release:backup.AddAttachmentsRequest.userID)
  return _impl_.userid_.Release();
}
inline void AddAttachmentsRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.AddAttachmentsRequest.userID)
}

// string backupID = 2;
inline void AddAttachmentsRequest::clear_backupid() {
  _impl_.backupid_.ClearToEmpty();
}
inline const std::string& AddAttachmentsRequest::backupid() const {
  // @@protoc_insertion_point(field_get:backup.AddAttachmentsRequest.backupID)
  return _internal_backupid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddAttachmentsRequest::set_backupid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.backupid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.AddAttachmentsRequest.backupID)
}
inline std::string* AddAttachmentsRequest::mutable_backupid() {
  std::string* _s = _internal_mutable_backupid();
  // @@protoc_insertion_point(field_mutable:backup.AddAttachmentsRequest.backupID)
  return _s;
}
inline const std::string& AddAttachmentsRequest::_internal_backupid() const {
  return _impl_.backupid_.Get();
}
inline void AddAttachmentsRequest::_internal_set_backupid(const std::string& value) {
  
  _impl_.backupid_.Set(value, GetArenaForAllocation());
}
inline std::string* AddAttachmentsRequest::_internal_mutable_backupid() {
  
  return _impl_.backupid_.Mutable(GetArenaForAllocation());
}
inline std::string* AddAttachmentsRequest::release_backupid() {
  // @@protoc_insertion_point(field_release:backup.AddAttachmentsRequest.backupID)
  return _impl_.backupid_.Release();
}
inline void AddAttachmentsRequest::set_allocated_backupid(std::string* backupid) {
  if (backupid != nullptr) {
    
  } else {
    
  }
  _impl_.backupid_.SetAllocated(backupid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.backupid_.IsDefault()) {
    _impl_.backupid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.AddAttachmentsRequest.backupID)
}

// string logID = 3;
inline void AddAttachmentsRequest::clear_logid() {
  _impl_.logid_.ClearToEmpty();
}
inline const std::string& AddAttachmentsRequest::logid() const {
  // @@protoc_insertion_point(field_get:backup.AddAttachmentsRequest.logID)
  return _internal_logid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddAttachmentsRequest::set_logid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.logid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.AddAttachmentsRequest.logID)
}
inline std::string* AddAttachmentsRequest::mutable_logid() {
  std::string* _s = _internal_mutable_logid();
  // @@protoc_insertion_point(field_mutable:backup.AddAttachmentsRequest.logID)
  return _s;
}
inline const std::string& AddAttachmentsRequest::_internal_logid() const {
  return _impl_.logid_.Get();
}
inline void AddAttachmentsRequest::_internal_set_logid(const std::string& value) {
  
  _impl_.logid_.Set(value, GetArenaForAllocation());
}
inline std::string* AddAttachmentsRequest::_internal_mutable_logid() {
  
  return _impl_.logid_.Mutable(GetArenaForAllocation());
}
inline std::string* AddAttachmentsRequest::release_logid() {
  // @@protoc_insertion_point(field_release:backup.AddAttachmentsRequest.logID)
  return _impl_.logid_.Release();
}
inline void AddAttachmentsRequest::set_allocated_logid(std::string* logid) {
  if (logid != nullptr) {
    
  } else {
    
  }
  _impl_.logid_.SetAllocated(logid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.logid_.IsDefault()) {
    _impl_.logid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.AddAttachmentsRequest.logID)
}

// string holders = 4;
inline void AddAttachmentsRequest::clear_holders() {
  _impl_.holders_.ClearToEmpty();
}
inline const std::string& AddAttachmentsRequest::holders() const {
  // @@protoc_insertion_point(field_get:backup.AddAttachmentsRequest.holders)
  return _internal_holders();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AddAttachmentsRequest::set_holders(ArgT0&& arg0, ArgT... args) {
 
 _impl_.holders_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:backup.AddAttachmentsRequest.holders)
}
inline std::string* AddAttachmentsRequest::mutable_holders() {
  std::string* _s = _internal_mutable_holders();
  // @@protoc_insertion_point(field_mutable:backup.AddAttachmentsRequest.holders)
  return _s;
}
inline const std::string& AddAttachmentsRequest::_internal_holders() const {
  return _impl_.holders_.Get();
}
inline void AddAttachmentsRequest::_internal_set_holders(const std::string& value) {
  
  _impl_.holders_.Set(value, GetArenaForAllocation());
}
inline std::string* AddAttachmentsRequest::_internal_mutable_holders() {
  
  return _impl_.holders_.Mutable(GetArenaForAllocation());
}
inline std::string* AddAttachmentsRequest::release_holders() {
  // @@protoc_insertion_point(field_release:backup.AddAttachmentsRequest.holders)
  return _impl_.holders_.Release();
}
inline void AddAttachmentsRequest::set_allocated_holders(std::string* holders) {
  if (holders != nullptr) {
    
  } else {
    
  }
  _impl_.holders_.SetAllocated(holders, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.holders_.IsDefault()) {
    _impl_.holders_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:backup.AddAttachmentsRequest.holders)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace backup

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_backup_2eproto
