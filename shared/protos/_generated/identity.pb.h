// @generated by the protocol buffer compiler.  DO NOT EDIT!
// source: identity.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_identity_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_identity_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_identity_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_identity_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_identity_2eproto;
namespace identity {
class GetUserIDRequest;
struct GetUserIDRequestDefaultTypeInternal;
extern GetUserIDRequestDefaultTypeInternal _GetUserIDRequest_default_instance_;
class GetUserIDResponse;
struct GetUserIDResponseDefaultTypeInternal;
extern GetUserIDResponseDefaultTypeInternal _GetUserIDResponse_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class PakeCredentialRequestAndUserID;
struct PakeCredentialRequestAndUserIDDefaultTypeInternal;
extern PakeCredentialRequestAndUserIDDefaultTypeInternal _PakeCredentialRequestAndUserID_default_instance_;
class PakeLoginRequest;
struct PakeLoginRequestDefaultTypeInternal;
extern PakeLoginRequestDefaultTypeInternal _PakeLoginRequest_default_instance_;
class PakeLoginResponse;
struct PakeLoginResponseDefaultTypeInternal;
extern PakeLoginResponseDefaultTypeInternal _PakeLoginResponse_default_instance_;
class PakeRegistrationRequestAndUserID;
struct PakeRegistrationRequestAndUserIDDefaultTypeInternal;
extern PakeRegistrationRequestAndUserIDDefaultTypeInternal _PakeRegistrationRequestAndUserID_default_instance_;
class PakeRegistrationUploadAndCredentialRequest;
struct PakeRegistrationUploadAndCredentialRequestDefaultTypeInternal;
extern PakeRegistrationUploadAndCredentialRequestDefaultTypeInternal _PakeRegistrationUploadAndCredentialRequest_default_instance_;
class RegistrationRequest;
struct RegistrationRequestDefaultTypeInternal;
extern RegistrationRequestDefaultTypeInternal _RegistrationRequest_default_instance_;
class RegistrationResponse;
struct RegistrationResponseDefaultTypeInternal;
extern RegistrationResponseDefaultTypeInternal _RegistrationResponse_default_instance_;
class VerifyUserTokenRequest;
struct VerifyUserTokenRequestDefaultTypeInternal;
extern VerifyUserTokenRequestDefaultTypeInternal _VerifyUserTokenRequest_default_instance_;
class VerifyUserTokenResponse;
struct VerifyUserTokenResponseDefaultTypeInternal;
extern VerifyUserTokenResponseDefaultTypeInternal _VerifyUserTokenResponse_default_instance_;
class WalletLoginRequest;
struct WalletLoginRequestDefaultTypeInternal;
extern WalletLoginRequestDefaultTypeInternal _WalletLoginRequest_default_instance_;
class WalletLoginResponse;
struct WalletLoginResponseDefaultTypeInternal;
extern WalletLoginResponseDefaultTypeInternal _WalletLoginResponse_default_instance_;
}  // namespace identity
PROTOBUF_NAMESPACE_OPEN
template<> ::identity::GetUserIDRequest* Arena::CreateMaybeMessage<::identity::GetUserIDRequest>(Arena*);
template<> ::identity::GetUserIDResponse* Arena::CreateMaybeMessage<::identity::GetUserIDResponse>(Arena*);
template<> ::identity::LoginRequest* Arena::CreateMaybeMessage<::identity::LoginRequest>(Arena*);
template<> ::identity::LoginResponse* Arena::CreateMaybeMessage<::identity::LoginResponse>(Arena*);
template<> ::identity::PakeCredentialRequestAndUserID* Arena::CreateMaybeMessage<::identity::PakeCredentialRequestAndUserID>(Arena*);
template<> ::identity::PakeLoginRequest* Arena::CreateMaybeMessage<::identity::PakeLoginRequest>(Arena*);
template<> ::identity::PakeLoginResponse* Arena::CreateMaybeMessage<::identity::PakeLoginResponse>(Arena*);
template<> ::identity::PakeRegistrationRequestAndUserID* Arena::CreateMaybeMessage<::identity::PakeRegistrationRequestAndUserID>(Arena*);
template<> ::identity::PakeRegistrationUploadAndCredentialRequest* Arena::CreateMaybeMessage<::identity::PakeRegistrationUploadAndCredentialRequest>(Arena*);
template<> ::identity::RegistrationRequest* Arena::CreateMaybeMessage<::identity::RegistrationRequest>(Arena*);
template<> ::identity::RegistrationResponse* Arena::CreateMaybeMessage<::identity::RegistrationResponse>(Arena*);
template<> ::identity::VerifyUserTokenRequest* Arena::CreateMaybeMessage<::identity::VerifyUserTokenRequest>(Arena*);
template<> ::identity::VerifyUserTokenResponse* Arena::CreateMaybeMessage<::identity::VerifyUserTokenResponse>(Arena*);
template<> ::identity::WalletLoginRequest* Arena::CreateMaybeMessage<::identity::WalletLoginRequest>(Arena*);
template<> ::identity::WalletLoginResponse* Arena::CreateMaybeMessage<::identity::WalletLoginResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace identity {

enum GetUserIDRequest_AuthType : int {
  GetUserIDRequest_AuthType_PASSWORD = 0,
  GetUserIDRequest_AuthType_WALLET = 1,
  GetUserIDRequest_AuthType_GetUserIDRequest_AuthType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  GetUserIDRequest_AuthType_GetUserIDRequest_AuthType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool GetUserIDRequest_AuthType_IsValid(int value);
constexpr GetUserIDRequest_AuthType GetUserIDRequest_AuthType_AuthType_MIN = GetUserIDRequest_AuthType_PASSWORD;
constexpr GetUserIDRequest_AuthType GetUserIDRequest_AuthType_AuthType_MAX = GetUserIDRequest_AuthType_WALLET;
constexpr int GetUserIDRequest_AuthType_AuthType_ARRAYSIZE = GetUserIDRequest_AuthType_AuthType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* GetUserIDRequest_AuthType_descriptor();
template<typename T>
inline const std::string& GetUserIDRequest_AuthType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, GetUserIDRequest_AuthType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function GetUserIDRequest_AuthType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    GetUserIDRequest_AuthType_descriptor(), enum_t_value);
}
inline bool GetUserIDRequest_AuthType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, GetUserIDRequest_AuthType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<GetUserIDRequest_AuthType>(
    GetUserIDRequest_AuthType_descriptor(), name, value);
}
// ===================================================================

class PakeRegistrationRequestAndUserID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.PakeRegistrationRequestAndUserID) */ {
 public:
  inline PakeRegistrationRequestAndUserID() : PakeRegistrationRequestAndUserID(nullptr) {}
  ~PakeRegistrationRequestAndUserID() override;
  explicit PROTOBUF_CONSTEXPR PakeRegistrationRequestAndUserID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PakeRegistrationRequestAndUserID(const PakeRegistrationRequestAndUserID& from);
  PakeRegistrationRequestAndUserID(PakeRegistrationRequestAndUserID&& from) noexcept
    : PakeRegistrationRequestAndUserID() {
    *this = ::std::move(from);
  }

  inline PakeRegistrationRequestAndUserID& operator=(const PakeRegistrationRequestAndUserID& from) {
    CopyFrom(from);
    return *this;
  }
  inline PakeRegistrationRequestAndUserID& operator=(PakeRegistrationRequestAndUserID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PakeRegistrationRequestAndUserID& default_instance() {
    return *internal_default_instance();
  }
  static inline const PakeRegistrationRequestAndUserID* internal_default_instance() {
    return reinterpret_cast<const PakeRegistrationRequestAndUserID*>(
               &_PakeRegistrationRequestAndUserID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PakeRegistrationRequestAndUserID& a, PakeRegistrationRequestAndUserID& b) {
    a.Swap(&b);
  }
  inline void Swap(PakeRegistrationRequestAndUserID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PakeRegistrationRequestAndUserID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PakeRegistrationRequestAndUserID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PakeRegistrationRequestAndUserID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PakeRegistrationRequestAndUserID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PakeRegistrationRequestAndUserID& from) {
    PakeRegistrationRequestAndUserID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PakeRegistrationRequestAndUserID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.PakeRegistrationRequestAndUserID";
  }
  protected:
  explicit PakeRegistrationRequestAndUserID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kDeviceIDFieldNumber = 2,
    kPakeRegistrationRequestFieldNumber = 3,
    kUsernameFieldNumber = 4,
    kUserPublicKeyFieldNumber = 5,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string deviceID = 2;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // bytes pakeRegistrationRequest = 3;
  void clear_pakeregistrationrequest();
  const std::string& pakeregistrationrequest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pakeregistrationrequest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pakeregistrationrequest();
  PROTOBUF_NODISCARD std::string* release_pakeregistrationrequest();
  void set_allocated_pakeregistrationrequest(std::string* pakeregistrationrequest);
  private:
  const std::string& _internal_pakeregistrationrequest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pakeregistrationrequest(const std::string& value);
  std::string* _internal_mutable_pakeregistrationrequest();
  public:

  // string username = 4;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // string userPublicKey = 5;
  void clear_userpublickey();
  const std::string& userpublickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userpublickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userpublickey();
  PROTOBUF_NODISCARD std::string* release_userpublickey();
  void set_allocated_userpublickey(std::string* userpublickey);
  private:
  const std::string& _internal_userpublickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userpublickey(const std::string& value);
  std::string* _internal_mutable_userpublickey();
  public:

  // @@protoc_insertion_point(class_scope:identity.PakeRegistrationRequestAndUserID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pakeregistrationrequest_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userpublickey_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class PakeCredentialRequestAndUserID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.PakeCredentialRequestAndUserID) */ {
 public:
  inline PakeCredentialRequestAndUserID() : PakeCredentialRequestAndUserID(nullptr) {}
  ~PakeCredentialRequestAndUserID() override;
  explicit PROTOBUF_CONSTEXPR PakeCredentialRequestAndUserID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PakeCredentialRequestAndUserID(const PakeCredentialRequestAndUserID& from);
  PakeCredentialRequestAndUserID(PakeCredentialRequestAndUserID&& from) noexcept
    : PakeCredentialRequestAndUserID() {
    *this = ::std::move(from);
  }

  inline PakeCredentialRequestAndUserID& operator=(const PakeCredentialRequestAndUserID& from) {
    CopyFrom(from);
    return *this;
  }
  inline PakeCredentialRequestAndUserID& operator=(PakeCredentialRequestAndUserID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PakeCredentialRequestAndUserID& default_instance() {
    return *internal_default_instance();
  }
  static inline const PakeCredentialRequestAndUserID* internal_default_instance() {
    return reinterpret_cast<const PakeCredentialRequestAndUserID*>(
               &_PakeCredentialRequestAndUserID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PakeCredentialRequestAndUserID& a, PakeCredentialRequestAndUserID& b) {
    a.Swap(&b);
  }
  inline void Swap(PakeCredentialRequestAndUserID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PakeCredentialRequestAndUserID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PakeCredentialRequestAndUserID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PakeCredentialRequestAndUserID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PakeCredentialRequestAndUserID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PakeCredentialRequestAndUserID& from) {
    PakeCredentialRequestAndUserID::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PakeCredentialRequestAndUserID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.PakeCredentialRequestAndUserID";
  }
  protected:
  explicit PakeCredentialRequestAndUserID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kDeviceIDFieldNumber = 2,
    kPakeCredentialRequestFieldNumber = 3,
    kUserPublicKeyFieldNumber = 4,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string deviceID = 2;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // bytes pakeCredentialRequest = 3;
  void clear_pakecredentialrequest();
  const std::string& pakecredentialrequest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pakecredentialrequest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pakecredentialrequest();
  PROTOBUF_NODISCARD std::string* release_pakecredentialrequest();
  void set_allocated_pakecredentialrequest(std::string* pakecredentialrequest);
  private:
  const std::string& _internal_pakecredentialrequest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pakecredentialrequest(const std::string& value);
  std::string* _internal_mutable_pakecredentialrequest();
  public:

  // string userPublicKey = 4;
  void clear_userpublickey();
  const std::string& userpublickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userpublickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userpublickey();
  PROTOBUF_NODISCARD std::string* release_userpublickey();
  void set_allocated_userpublickey(std::string* userpublickey);
  private:
  const std::string& _internal_userpublickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userpublickey(const std::string& value);
  std::string* _internal_mutable_userpublickey();
  public:

  // @@protoc_insertion_point(class_scope:identity.PakeCredentialRequestAndUserID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pakecredentialrequest_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userpublickey_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class PakeLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.PakeLoginRequest) */ {
 public:
  inline PakeLoginRequest() : PakeLoginRequest(nullptr) {}
  ~PakeLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR PakeLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PakeLoginRequest(const PakeLoginRequest& from);
  PakeLoginRequest(PakeLoginRequest&& from) noexcept
    : PakeLoginRequest() {
    *this = ::std::move(from);
  }

  inline PakeLoginRequest& operator=(const PakeLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PakeLoginRequest& operator=(PakeLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PakeLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kPakeCredentialRequestAndUserID = 1,
    kPakeCredentialFinalization = 2,
    DATA_NOT_SET = 0,
  };

  static inline const PakeLoginRequest* internal_default_instance() {
    return reinterpret_cast<const PakeLoginRequest*>(
               &_PakeLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PakeLoginRequest& a, PakeLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PakeLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PakeLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PakeLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PakeLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PakeLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PakeLoginRequest& from) {
    PakeLoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PakeLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.PakeLoginRequest";
  }
  protected:
  explicit PakeLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPakeCredentialRequestAndUserIDFieldNumber = 1,
    kPakeCredentialFinalizationFieldNumber = 2,
  };
  // .identity.PakeCredentialRequestAndUserID pakeCredentialRequestAndUserID = 1;
  bool has_pakecredentialrequestanduserid() const;
  private:
  bool _internal_has_pakecredentialrequestanduserid() const;
  public:
  void clear_pakecredentialrequestanduserid();
  const ::identity::PakeCredentialRequestAndUserID& pakecredentialrequestanduserid() const;
  PROTOBUF_NODISCARD ::identity::PakeCredentialRequestAndUserID* release_pakecredentialrequestanduserid();
  ::identity::PakeCredentialRequestAndUserID* mutable_pakecredentialrequestanduserid();
  void set_allocated_pakecredentialrequestanduserid(::identity::PakeCredentialRequestAndUserID* pakecredentialrequestanduserid);
  private:
  const ::identity::PakeCredentialRequestAndUserID& _internal_pakecredentialrequestanduserid() const;
  ::identity::PakeCredentialRequestAndUserID* _internal_mutable_pakecredentialrequestanduserid();
  public:
  void unsafe_arena_set_allocated_pakecredentialrequestanduserid(
      ::identity::PakeCredentialRequestAndUserID* pakecredentialrequestanduserid);
  ::identity::PakeCredentialRequestAndUserID* unsafe_arena_release_pakecredentialrequestanduserid();

  // bytes pakeCredentialFinalization = 2;
  bool has_pakecredentialfinalization() const;
  private:
  bool _internal_has_pakecredentialfinalization() const;
  public:
  void clear_pakecredentialfinalization();
  const std::string& pakecredentialfinalization() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pakecredentialfinalization(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pakecredentialfinalization();
  PROTOBUF_NODISCARD std::string* release_pakecredentialfinalization();
  void set_allocated_pakecredentialfinalization(std::string* pakecredentialfinalization);
  private:
  const std::string& _internal_pakecredentialfinalization() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pakecredentialfinalization(const std::string& value);
  std::string* _internal_mutable_pakecredentialfinalization();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:identity.PakeLoginRequest)
 private:
  class _Internal;
  void set_has_pakecredentialrequestanduserid();
  void set_has_pakecredentialfinalization();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::identity::PakeCredentialRequestAndUserID* pakecredentialrequestanduserid_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pakecredentialfinalization_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class PakeLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.PakeLoginResponse) */ {
 public:
  inline PakeLoginResponse() : PakeLoginResponse(nullptr) {}
  ~PakeLoginResponse() override;
  explicit PROTOBUF_CONSTEXPR PakeLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PakeLoginResponse(const PakeLoginResponse& from);
  PakeLoginResponse(PakeLoginResponse&& from) noexcept
    : PakeLoginResponse() {
    *this = ::std::move(from);
  }

  inline PakeLoginResponse& operator=(const PakeLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PakeLoginResponse& operator=(PakeLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PakeLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kPakeCredentialResponse = 1,
    kAccessToken = 2,
    DATA_NOT_SET = 0,
  };

  static inline const PakeLoginResponse* internal_default_instance() {
    return reinterpret_cast<const PakeLoginResponse*>(
               &_PakeLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PakeLoginResponse& a, PakeLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PakeLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PakeLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PakeLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PakeLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PakeLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PakeLoginResponse& from) {
    PakeLoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PakeLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.PakeLoginResponse";
  }
  protected:
  explicit PakeLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPakeCredentialResponseFieldNumber = 1,
    kAccessTokenFieldNumber = 2,
  };
  // bytes pakeCredentialResponse = 1;
  bool has_pakecredentialresponse() const;
  private:
  bool _internal_has_pakecredentialresponse() const;
  public:
  void clear_pakecredentialresponse();
  const std::string& pakecredentialresponse() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pakecredentialresponse(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pakecredentialresponse();
  PROTOBUF_NODISCARD std::string* release_pakecredentialresponse();
  void set_allocated_pakecredentialresponse(std::string* pakecredentialresponse);
  private:
  const std::string& _internal_pakecredentialresponse() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pakecredentialresponse(const std::string& value);
  std::string* _internal_mutable_pakecredentialresponse();
  public:

  // string accessToken = 2;
  bool has_accesstoken() const;
  private:
  bool _internal_has_accesstoken() const;
  public:
  void clear_accesstoken();
  const std::string& accesstoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesstoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesstoken();
  PROTOBUF_NODISCARD std::string* release_accesstoken();
  void set_allocated_accesstoken(std::string* accesstoken);
  private:
  const std::string& _internal_accesstoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstoken(const std::string& value);
  std::string* _internal_mutable_accesstoken();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:identity.PakeLoginResponse)
 private:
  class _Internal;
  void set_has_pakecredentialresponse();
  void set_has_accesstoken();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pakecredentialresponse_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesstoken_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class PakeRegistrationUploadAndCredentialRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.PakeRegistrationUploadAndCredentialRequest) */ {
 public:
  inline PakeRegistrationUploadAndCredentialRequest() : PakeRegistrationUploadAndCredentialRequest(nullptr) {}
  ~PakeRegistrationUploadAndCredentialRequest() override;
  explicit PROTOBUF_CONSTEXPR PakeRegistrationUploadAndCredentialRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PakeRegistrationUploadAndCredentialRequest(const PakeRegistrationUploadAndCredentialRequest& from);
  PakeRegistrationUploadAndCredentialRequest(PakeRegistrationUploadAndCredentialRequest&& from) noexcept
    : PakeRegistrationUploadAndCredentialRequest() {
    *this = ::std::move(from);
  }

  inline PakeRegistrationUploadAndCredentialRequest& operator=(const PakeRegistrationUploadAndCredentialRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PakeRegistrationUploadAndCredentialRequest& operator=(PakeRegistrationUploadAndCredentialRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PakeRegistrationUploadAndCredentialRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PakeRegistrationUploadAndCredentialRequest* internal_default_instance() {
    return reinterpret_cast<const PakeRegistrationUploadAndCredentialRequest*>(
               &_PakeRegistrationUploadAndCredentialRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PakeRegistrationUploadAndCredentialRequest& a, PakeRegistrationUploadAndCredentialRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PakeRegistrationUploadAndCredentialRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PakeRegistrationUploadAndCredentialRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PakeRegistrationUploadAndCredentialRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PakeRegistrationUploadAndCredentialRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PakeRegistrationUploadAndCredentialRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PakeRegistrationUploadAndCredentialRequest& from) {
    PakeRegistrationUploadAndCredentialRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PakeRegistrationUploadAndCredentialRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.PakeRegistrationUploadAndCredentialRequest";
  }
  protected:
  explicit PakeRegistrationUploadAndCredentialRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPakeRegistrationUploadFieldNumber = 1,
    kPakeCredentialRequestFieldNumber = 2,
  };
  // bytes pakeRegistrationUpload = 1;
  void clear_pakeregistrationupload();
  const std::string& pakeregistrationupload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pakeregistrationupload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pakeregistrationupload();
  PROTOBUF_NODISCARD std::string* release_pakeregistrationupload();
  void set_allocated_pakeregistrationupload(std::string* pakeregistrationupload);
  private:
  const std::string& _internal_pakeregistrationupload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pakeregistrationupload(const std::string& value);
  std::string* _internal_mutable_pakeregistrationupload();
  public:

  // bytes pakeCredentialRequest = 2;
  void clear_pakecredentialrequest();
  const std::string& pakecredentialrequest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pakecredentialrequest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pakecredentialrequest();
  PROTOBUF_NODISCARD std::string* release_pakecredentialrequest();
  void set_allocated_pakecredentialrequest(std::string* pakecredentialrequest);
  private:
  const std::string& _internal_pakecredentialrequest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pakecredentialrequest(const std::string& value);
  std::string* _internal_mutable_pakecredentialrequest();
  public:

  // @@protoc_insertion_point(class_scope:identity.PakeRegistrationUploadAndCredentialRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pakeregistrationupload_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pakecredentialrequest_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class WalletLoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.WalletLoginRequest) */ {
 public:
  inline WalletLoginRequest() : WalletLoginRequest(nullptr) {}
  ~WalletLoginRequest() override;
  explicit PROTOBUF_CONSTEXPR WalletLoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WalletLoginRequest(const WalletLoginRequest& from);
  WalletLoginRequest(WalletLoginRequest&& from) noexcept
    : WalletLoginRequest() {
    *this = ::std::move(from);
  }

  inline WalletLoginRequest& operator=(const WalletLoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalletLoginRequest& operator=(WalletLoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalletLoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const WalletLoginRequest* internal_default_instance() {
    return reinterpret_cast<const WalletLoginRequest*>(
               &_WalletLoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(WalletLoginRequest& a, WalletLoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(WalletLoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalletLoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalletLoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WalletLoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WalletLoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WalletLoginRequest& from) {
    WalletLoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalletLoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.WalletLoginRequest";
  }
  protected:
  explicit WalletLoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kDeviceIDFieldNumber = 2,
    kSiweMessageFieldNumber = 3,
    kSiweSignatureFieldNumber = 4,
    kUserPublicKeyFieldNumber = 5,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string deviceID = 2;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string siweMessage = 3;
  void clear_siwemessage();
  const std::string& siwemessage() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_siwemessage(ArgT0&& arg0, ArgT... args);
  std::string* mutable_siwemessage();
  PROTOBUF_NODISCARD std::string* release_siwemessage();
  void set_allocated_siwemessage(std::string* siwemessage);
  private:
  const std::string& _internal_siwemessage() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_siwemessage(const std::string& value);
  std::string* _internal_mutable_siwemessage();
  public:

  // bytes siweSignature = 4;
  void clear_siwesignature();
  const std::string& siwesignature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_siwesignature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_siwesignature();
  PROTOBUF_NODISCARD std::string* release_siwesignature();
  void set_allocated_siwesignature(std::string* siwesignature);
  private:
  const std::string& _internal_siwesignature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_siwesignature(const std::string& value);
  std::string* _internal_mutable_siwesignature();
  public:

  // string userPublicKey = 5;
  void clear_userpublickey();
  const std::string& userpublickey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userpublickey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userpublickey();
  PROTOBUF_NODISCARD std::string* release_userpublickey();
  void set_allocated_userpublickey(std::string* userpublickey);
  private:
  const std::string& _internal_userpublickey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userpublickey(const std::string& value);
  std::string* _internal_mutable_userpublickey();
  public:

  // @@protoc_insertion_point(class_scope:identity.WalletLoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr siwemessage_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr siwesignature_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userpublickey_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class WalletLoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.WalletLoginResponse) */ {
 public:
  inline WalletLoginResponse() : WalletLoginResponse(nullptr) {}
  ~WalletLoginResponse() override;
  explicit PROTOBUF_CONSTEXPR WalletLoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  WalletLoginResponse(const WalletLoginResponse& from);
  WalletLoginResponse(WalletLoginResponse&& from) noexcept
    : WalletLoginResponse() {
    *this = ::std::move(from);
  }

  inline WalletLoginResponse& operator=(const WalletLoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline WalletLoginResponse& operator=(WalletLoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const WalletLoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const WalletLoginResponse* internal_default_instance() {
    return reinterpret_cast<const WalletLoginResponse*>(
               &_WalletLoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(WalletLoginResponse& a, WalletLoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(WalletLoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(WalletLoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  WalletLoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<WalletLoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const WalletLoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const WalletLoginResponse& from) {
    WalletLoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(WalletLoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.WalletLoginResponse";
  }
  protected:
  explicit WalletLoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 1,
  };
  // string accessToken = 1;
  void clear_accesstoken();
  const std::string& accesstoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesstoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesstoken();
  PROTOBUF_NODISCARD std::string* release_accesstoken();
  void set_allocated_accesstoken(std::string* accesstoken);
  private:
  const std::string& _internal_accesstoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstoken(const std::string& value);
  std::string* _internal_mutable_accesstoken();
  public:

  // @@protoc_insertion_point(class_scope:identity.WalletLoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesstoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class RegistrationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.RegistrationRequest) */ {
 public:
  inline RegistrationRequest() : RegistrationRequest(nullptr) {}
  ~RegistrationRequest() override;
  explicit PROTOBUF_CONSTEXPR RegistrationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistrationRequest(const RegistrationRequest& from);
  RegistrationRequest(RegistrationRequest&& from) noexcept
    : RegistrationRequest() {
    *this = ::std::move(from);
  }

  inline RegistrationRequest& operator=(const RegistrationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationRequest& operator=(RegistrationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistrationRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kPakeRegistrationRequestAndUserID = 1,
    kPakeRegistrationUploadAndCredentialRequest = 2,
    kPakeCredentialFinalization = 3,
    DATA_NOT_SET = 0,
  };

  static inline const RegistrationRequest* internal_default_instance() {
    return reinterpret_cast<const RegistrationRequest*>(
               &_RegistrationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(RegistrationRequest& a, RegistrationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistrationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistrationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistrationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistrationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistrationRequest& from) {
    RegistrationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistrationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.RegistrationRequest";
  }
  protected:
  explicit RegistrationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPakeRegistrationRequestAndUserIDFieldNumber = 1,
    kPakeRegistrationUploadAndCredentialRequestFieldNumber = 2,
    kPakeCredentialFinalizationFieldNumber = 3,
  };
  // .identity.PakeRegistrationRequestAndUserID pakeRegistrationRequestAndUserID = 1;
  bool has_pakeregistrationrequestanduserid() const;
  private:
  bool _internal_has_pakeregistrationrequestanduserid() const;
  public:
  void clear_pakeregistrationrequestanduserid();
  const ::identity::PakeRegistrationRequestAndUserID& pakeregistrationrequestanduserid() const;
  PROTOBUF_NODISCARD ::identity::PakeRegistrationRequestAndUserID* release_pakeregistrationrequestanduserid();
  ::identity::PakeRegistrationRequestAndUserID* mutable_pakeregistrationrequestanduserid();
  void set_allocated_pakeregistrationrequestanduserid(::identity::PakeRegistrationRequestAndUserID* pakeregistrationrequestanduserid);
  private:
  const ::identity::PakeRegistrationRequestAndUserID& _internal_pakeregistrationrequestanduserid() const;
  ::identity::PakeRegistrationRequestAndUserID* _internal_mutable_pakeregistrationrequestanduserid();
  public:
  void unsafe_arena_set_allocated_pakeregistrationrequestanduserid(
      ::identity::PakeRegistrationRequestAndUserID* pakeregistrationrequestanduserid);
  ::identity::PakeRegistrationRequestAndUserID* unsafe_arena_release_pakeregistrationrequestanduserid();

  // .identity.PakeRegistrationUploadAndCredentialRequest pakeRegistrationUploadAndCredentialRequest = 2;
  bool has_pakeregistrationuploadandcredentialrequest() const;
  private:
  bool _internal_has_pakeregistrationuploadandcredentialrequest() const;
  public:
  void clear_pakeregistrationuploadandcredentialrequest();
  const ::identity::PakeRegistrationUploadAndCredentialRequest& pakeregistrationuploadandcredentialrequest() const;
  PROTOBUF_NODISCARD ::identity::PakeRegistrationUploadAndCredentialRequest* release_pakeregistrationuploadandcredentialrequest();
  ::identity::PakeRegistrationUploadAndCredentialRequest* mutable_pakeregistrationuploadandcredentialrequest();
  void set_allocated_pakeregistrationuploadandcredentialrequest(::identity::PakeRegistrationUploadAndCredentialRequest* pakeregistrationuploadandcredentialrequest);
  private:
  const ::identity::PakeRegistrationUploadAndCredentialRequest& _internal_pakeregistrationuploadandcredentialrequest() const;
  ::identity::PakeRegistrationUploadAndCredentialRequest* _internal_mutable_pakeregistrationuploadandcredentialrequest();
  public:
  void unsafe_arena_set_allocated_pakeregistrationuploadandcredentialrequest(
      ::identity::PakeRegistrationUploadAndCredentialRequest* pakeregistrationuploadandcredentialrequest);
  ::identity::PakeRegistrationUploadAndCredentialRequest* unsafe_arena_release_pakeregistrationuploadandcredentialrequest();

  // bytes pakeCredentialFinalization = 3;
  bool has_pakecredentialfinalization() const;
  private:
  bool _internal_has_pakecredentialfinalization() const;
  public:
  void clear_pakecredentialfinalization();
  const std::string& pakecredentialfinalization() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pakecredentialfinalization(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pakecredentialfinalization();
  PROTOBUF_NODISCARD std::string* release_pakecredentialfinalization();
  void set_allocated_pakecredentialfinalization(std::string* pakecredentialfinalization);
  private:
  const std::string& _internal_pakecredentialfinalization() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pakecredentialfinalization(const std::string& value);
  std::string* _internal_mutable_pakecredentialfinalization();
  public:

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:identity.RegistrationRequest)
 private:
  class _Internal;
  void set_has_pakeregistrationrequestanduserid();
  void set_has_pakeregistrationuploadandcredentialrequest();
  void set_has_pakecredentialfinalization();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::identity::PakeRegistrationRequestAndUserID* pakeregistrationrequestanduserid_;
      ::identity::PakeRegistrationUploadAndCredentialRequest* pakeregistrationuploadandcredentialrequest_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pakecredentialfinalization_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class RegistrationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.RegistrationResponse) */ {
 public:
  inline RegistrationResponse() : RegistrationResponse(nullptr) {}
  ~RegistrationResponse() override;
  explicit PROTOBUF_CONSTEXPR RegistrationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegistrationResponse(const RegistrationResponse& from);
  RegistrationResponse(RegistrationResponse&& from) noexcept
    : RegistrationResponse() {
    *this = ::std::move(from);
  }

  inline RegistrationResponse& operator=(const RegistrationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegistrationResponse& operator=(RegistrationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegistrationResponse& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kPakeRegistrationResponse = 1,
    kPakeLoginResponse = 2,
    DATA_NOT_SET = 0,
  };

  static inline const RegistrationResponse* internal_default_instance() {
    return reinterpret_cast<const RegistrationResponse*>(
               &_RegistrationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(RegistrationResponse& a, RegistrationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegistrationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegistrationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegistrationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegistrationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegistrationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegistrationResponse& from) {
    RegistrationResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegistrationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.RegistrationResponse";
  }
  protected:
  explicit RegistrationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPakeRegistrationResponseFieldNumber = 1,
    kPakeLoginResponseFieldNumber = 2,
  };
  // bytes pakeRegistrationResponse = 1;
  bool has_pakeregistrationresponse() const;
  private:
  bool _internal_has_pakeregistrationresponse() const;
  public:
  void clear_pakeregistrationresponse();
  const std::string& pakeregistrationresponse() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pakeregistrationresponse(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pakeregistrationresponse();
  PROTOBUF_NODISCARD std::string* release_pakeregistrationresponse();
  void set_allocated_pakeregistrationresponse(std::string* pakeregistrationresponse);
  private:
  const std::string& _internal_pakeregistrationresponse() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pakeregistrationresponse(const std::string& value);
  std::string* _internal_mutable_pakeregistrationresponse();
  public:

  // .identity.PakeLoginResponse pakeLoginResponse = 2;
  bool has_pakeloginresponse() const;
  private:
  bool _internal_has_pakeloginresponse() const;
  public:
  void clear_pakeloginresponse();
  const ::identity::PakeLoginResponse& pakeloginresponse() const;
  PROTOBUF_NODISCARD ::identity::PakeLoginResponse* release_pakeloginresponse();
  ::identity::PakeLoginResponse* mutable_pakeloginresponse();
  void set_allocated_pakeloginresponse(::identity::PakeLoginResponse* pakeloginresponse);
  private:
  const ::identity::PakeLoginResponse& _internal_pakeloginresponse() const;
  ::identity::PakeLoginResponse* _internal_mutable_pakeloginresponse();
  public:
  void unsafe_arena_set_allocated_pakeloginresponse(
      ::identity::PakeLoginResponse* pakeloginresponse);
  ::identity::PakeLoginResponse* unsafe_arena_release_pakeloginresponse();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:identity.RegistrationResponse)
 private:
  class _Internal;
  void set_has_pakeregistrationresponse();
  void set_has_pakeloginresponse();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pakeregistrationresponse_;
      ::identity::PakeLoginResponse* pakeloginresponse_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kPakeLoginRequest = 1,
    kWalletLoginRequest = 2,
    DATA_NOT_SET = 0,
  };

  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPakeLoginRequestFieldNumber = 1,
    kWalletLoginRequestFieldNumber = 2,
  };
  // .identity.PakeLoginRequest pakeLoginRequest = 1;
  bool has_pakeloginrequest() const;
  private:
  bool _internal_has_pakeloginrequest() const;
  public:
  void clear_pakeloginrequest();
  const ::identity::PakeLoginRequest& pakeloginrequest() const;
  PROTOBUF_NODISCARD ::identity::PakeLoginRequest* release_pakeloginrequest();
  ::identity::PakeLoginRequest* mutable_pakeloginrequest();
  void set_allocated_pakeloginrequest(::identity::PakeLoginRequest* pakeloginrequest);
  private:
  const ::identity::PakeLoginRequest& _internal_pakeloginrequest() const;
  ::identity::PakeLoginRequest* _internal_mutable_pakeloginrequest();
  public:
  void unsafe_arena_set_allocated_pakeloginrequest(
      ::identity::PakeLoginRequest* pakeloginrequest);
  ::identity::PakeLoginRequest* unsafe_arena_release_pakeloginrequest();

  // .identity.WalletLoginRequest walletLoginRequest = 2;
  bool has_walletloginrequest() const;
  private:
  bool _internal_has_walletloginrequest() const;
  public:
  void clear_walletloginrequest();
  const ::identity::WalletLoginRequest& walletloginrequest() const;
  PROTOBUF_NODISCARD ::identity::WalletLoginRequest* release_walletloginrequest();
  ::identity::WalletLoginRequest* mutable_walletloginrequest();
  void set_allocated_walletloginrequest(::identity::WalletLoginRequest* walletloginrequest);
  private:
  const ::identity::WalletLoginRequest& _internal_walletloginrequest() const;
  ::identity::WalletLoginRequest* _internal_mutable_walletloginrequest();
  public:
  void unsafe_arena_set_allocated_walletloginrequest(
      ::identity::WalletLoginRequest* walletloginrequest);
  ::identity::WalletLoginRequest* unsafe_arena_release_walletloginrequest();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:identity.LoginRequest)
 private:
  class _Internal;
  void set_has_pakeloginrequest();
  void set_has_walletloginrequest();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::identity::PakeLoginRequest* pakeloginrequest_;
      ::identity::WalletLoginRequest* walletloginrequest_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kPakeLoginResponse = 1,
    kWalletLoginResponse = 2,
    DATA_NOT_SET = 0,
  };

  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPakeLoginResponseFieldNumber = 1,
    kWalletLoginResponseFieldNumber = 2,
  };
  // .identity.PakeLoginResponse pakeLoginResponse = 1;
  bool has_pakeloginresponse() const;
  private:
  bool _internal_has_pakeloginresponse() const;
  public:
  void clear_pakeloginresponse();
  const ::identity::PakeLoginResponse& pakeloginresponse() const;
  PROTOBUF_NODISCARD ::identity::PakeLoginResponse* release_pakeloginresponse();
  ::identity::PakeLoginResponse* mutable_pakeloginresponse();
  void set_allocated_pakeloginresponse(::identity::PakeLoginResponse* pakeloginresponse);
  private:
  const ::identity::PakeLoginResponse& _internal_pakeloginresponse() const;
  ::identity::PakeLoginResponse* _internal_mutable_pakeloginresponse();
  public:
  void unsafe_arena_set_allocated_pakeloginresponse(
      ::identity::PakeLoginResponse* pakeloginresponse);
  ::identity::PakeLoginResponse* unsafe_arena_release_pakeloginresponse();

  // .identity.WalletLoginResponse walletLoginResponse = 2;
  bool has_walletloginresponse() const;
  private:
  bool _internal_has_walletloginresponse() const;
  public:
  void clear_walletloginresponse();
  const ::identity::WalletLoginResponse& walletloginresponse() const;
  PROTOBUF_NODISCARD ::identity::WalletLoginResponse* release_walletloginresponse();
  ::identity::WalletLoginResponse* mutable_walletloginresponse();
  void set_allocated_walletloginresponse(::identity::WalletLoginResponse* walletloginresponse);
  private:
  const ::identity::WalletLoginResponse& _internal_walletloginresponse() const;
  ::identity::WalletLoginResponse* _internal_mutable_walletloginresponse();
  public:
  void unsafe_arena_set_allocated_walletloginresponse(
      ::identity::WalletLoginResponse* walletloginresponse);
  ::identity::WalletLoginResponse* unsafe_arena_release_walletloginresponse();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:identity.LoginResponse)
 private:
  class _Internal;
  void set_has_pakeloginresponse();
  void set_has_walletloginresponse();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    union DataUnion {
      constexpr DataUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::identity::PakeLoginResponse* pakeloginresponse_;
      ::identity::WalletLoginResponse* walletloginresponse_;
    } data_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class VerifyUserTokenRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.VerifyUserTokenRequest) */ {
 public:
  inline VerifyUserTokenRequest() : VerifyUserTokenRequest(nullptr) {}
  ~VerifyUserTokenRequest() override;
  explicit PROTOBUF_CONSTEXPR VerifyUserTokenRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyUserTokenRequest(const VerifyUserTokenRequest& from);
  VerifyUserTokenRequest(VerifyUserTokenRequest&& from) noexcept
    : VerifyUserTokenRequest() {
    *this = ::std::move(from);
  }

  inline VerifyUserTokenRequest& operator=(const VerifyUserTokenRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyUserTokenRequest& operator=(VerifyUserTokenRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyUserTokenRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyUserTokenRequest* internal_default_instance() {
    return reinterpret_cast<const VerifyUserTokenRequest*>(
               &_VerifyUserTokenRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(VerifyUserTokenRequest& a, VerifyUserTokenRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyUserTokenRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyUserTokenRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyUserTokenRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyUserTokenRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyUserTokenRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerifyUserTokenRequest& from) {
    VerifyUserTokenRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyUserTokenRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.VerifyUserTokenRequest";
  }
  protected:
  explicit VerifyUserTokenRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
    kDeviceIDFieldNumber = 2,
    kAccessTokenFieldNumber = 3,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // string deviceID = 2;
  void clear_deviceid();
  const std::string& deviceid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_deviceid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_deviceid();
  PROTOBUF_NODISCARD std::string* release_deviceid();
  void set_allocated_deviceid(std::string* deviceid);
  private:
  const std::string& _internal_deviceid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_deviceid(const std::string& value);
  std::string* _internal_mutable_deviceid();
  public:

  // string accessToken = 3;
  void clear_accesstoken();
  const std::string& accesstoken() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_accesstoken(ArgT0&& arg0, ArgT... args);
  std::string* mutable_accesstoken();
  PROTOBUF_NODISCARD std::string* release_accesstoken();
  void set_allocated_accesstoken(std::string* accesstoken);
  private:
  const std::string& _internal_accesstoken() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_accesstoken(const std::string& value);
  std::string* _internal_mutable_accesstoken();
  public:

  // @@protoc_insertion_point(class_scope:identity.VerifyUserTokenRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr deviceid_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr accesstoken_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class VerifyUserTokenResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.VerifyUserTokenResponse) */ {
 public:
  inline VerifyUserTokenResponse() : VerifyUserTokenResponse(nullptr) {}
  ~VerifyUserTokenResponse() override;
  explicit PROTOBUF_CONSTEXPR VerifyUserTokenResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VerifyUserTokenResponse(const VerifyUserTokenResponse& from);
  VerifyUserTokenResponse(VerifyUserTokenResponse&& from) noexcept
    : VerifyUserTokenResponse() {
    *this = ::std::move(from);
  }

  inline VerifyUserTokenResponse& operator=(const VerifyUserTokenResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline VerifyUserTokenResponse& operator=(VerifyUserTokenResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VerifyUserTokenResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const VerifyUserTokenResponse* internal_default_instance() {
    return reinterpret_cast<const VerifyUserTokenResponse*>(
               &_VerifyUserTokenResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(VerifyUserTokenResponse& a, VerifyUserTokenResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(VerifyUserTokenResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VerifyUserTokenResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VerifyUserTokenResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VerifyUserTokenResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VerifyUserTokenResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const VerifyUserTokenResponse& from) {
    VerifyUserTokenResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VerifyUserTokenResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.VerifyUserTokenResponse";
  }
  protected:
  explicit VerifyUserTokenResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenValidFieldNumber = 1,
  };
  // bool tokenValid = 1;
  void clear_tokenvalid();
  bool tokenvalid() const;
  void set_tokenvalid(bool value);
  private:
  bool _internal_tokenvalid() const;
  void _internal_set_tokenvalid(bool value);
  public:

  // @@protoc_insertion_point(class_scope:identity.VerifyUserTokenResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool tokenvalid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class GetUserIDRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.GetUserIDRequest) */ {
 public:
  inline GetUserIDRequest() : GetUserIDRequest(nullptr) {}
  ~GetUserIDRequest() override;
  explicit PROTOBUF_CONSTEXPR GetUserIDRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserIDRequest(const GetUserIDRequest& from);
  GetUserIDRequest(GetUserIDRequest&& from) noexcept
    : GetUserIDRequest() {
    *this = ::std::move(from);
  }

  inline GetUserIDRequest& operator=(const GetUserIDRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserIDRequest& operator=(GetUserIDRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserIDRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserIDRequest* internal_default_instance() {
    return reinterpret_cast<const GetUserIDRequest*>(
               &_GetUserIDRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(GetUserIDRequest& a, GetUserIDRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserIDRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserIDRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserIDRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserIDRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserIDRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserIDRequest& from) {
    GetUserIDRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserIDRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.GetUserIDRequest";
  }
  protected:
  explicit GetUserIDRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef GetUserIDRequest_AuthType AuthType;
  static constexpr AuthType PASSWORD =
    GetUserIDRequest_AuthType_PASSWORD;
  static constexpr AuthType WALLET =
    GetUserIDRequest_AuthType_WALLET;
  static inline bool AuthType_IsValid(int value) {
    return GetUserIDRequest_AuthType_IsValid(value);
  }
  static constexpr AuthType AuthType_MIN =
    GetUserIDRequest_AuthType_AuthType_MIN;
  static constexpr AuthType AuthType_MAX =
    GetUserIDRequest_AuthType_AuthType_MAX;
  static constexpr int AuthType_ARRAYSIZE =
    GetUserIDRequest_AuthType_AuthType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AuthType_descriptor() {
    return GetUserIDRequest_AuthType_descriptor();
  }
  template<typename T>
  static inline const std::string& AuthType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AuthType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AuthType_Name.");
    return GetUserIDRequest_AuthType_Name(enum_t_value);
  }
  static inline bool AuthType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AuthType* value) {
    return GetUserIDRequest_AuthType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kUserInfoFieldNumber = 2,
    kAuthTypeFieldNumber = 1,
  };
  // string userInfo = 2;
  void clear_userinfo();
  const std::string& userinfo() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userinfo(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userinfo();
  PROTOBUF_NODISCARD std::string* release_userinfo();
  void set_allocated_userinfo(std::string* userinfo);
  private:
  const std::string& _internal_userinfo() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userinfo(const std::string& value);
  std::string* _internal_mutable_userinfo();
  public:

  // .identity.GetUserIDRequest.AuthType authType = 1;
  void clear_authtype();
  ::identity::GetUserIDRequest_AuthType authtype() const;
  void set_authtype(::identity::GetUserIDRequest_AuthType value);
  private:
  ::identity::GetUserIDRequest_AuthType _internal_authtype() const;
  void _internal_set_authtype(::identity::GetUserIDRequest_AuthType value);
  public:

  // @@protoc_insertion_point(class_scope:identity.GetUserIDRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userinfo_;
    int authtype_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// -------------------------------------------------------------------

class GetUserIDResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:identity.GetUserIDResponse) */ {
 public:
  inline GetUserIDResponse() : GetUserIDResponse(nullptr) {}
  ~GetUserIDResponse() override;
  explicit PROTOBUF_CONSTEXPR GetUserIDResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetUserIDResponse(const GetUserIDResponse& from);
  GetUserIDResponse(GetUserIDResponse&& from) noexcept
    : GetUserIDResponse() {
    *this = ::std::move(from);
  }

  inline GetUserIDResponse& operator=(const GetUserIDResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetUserIDResponse& operator=(GetUserIDResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetUserIDResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetUserIDResponse* internal_default_instance() {
    return reinterpret_cast<const GetUserIDResponse*>(
               &_GetUserIDResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetUserIDResponse& a, GetUserIDResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetUserIDResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetUserIDResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetUserIDResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetUserIDResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetUserIDResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GetUserIDResponse& from) {
    GetUserIDResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetUserIDResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "identity.GetUserIDResponse";
  }
  protected:
  explicit GetUserIDResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIDFieldNumber = 1,
  };
  // string userID = 1;
  void clear_userid();
  const std::string& userid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_userid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_userid();
  PROTOBUF_NODISCARD std::string* release_userid();
  void set_allocated_userid(std::string* userid);
  private:
  const std::string& _internal_userid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_userid(const std::string& value);
  std::string* _internal_mutable_userid();
  public:

  // @@protoc_insertion_point(class_scope:identity.GetUserIDResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr userid_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_identity_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PakeRegistrationRequestAndUserID

// string userID = 1;
inline void PakeRegistrationRequestAndUserID::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& PakeRegistrationRequestAndUserID::userid() const {
  // @@protoc_insertion_point(field_get:identity.PakeRegistrationRequestAndUserID.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeRegistrationRequestAndUserID::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeRegistrationRequestAndUserID.userID)
}
inline std::string* PakeRegistrationRequestAndUserID::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:identity.PakeRegistrationRequestAndUserID.userID)
  return _s;
}
inline const std::string& PakeRegistrationRequestAndUserID::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void PakeRegistrationRequestAndUserID::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::release_userid() {
  // @@protoc_insertion_point(field_release:identity.PakeRegistrationRequestAndUserID.userID)
  return _impl_.userid_.Release();
}
inline void PakeRegistrationRequestAndUserID::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeRegistrationRequestAndUserID.userID)
}

// string deviceID = 2;
inline void PakeRegistrationRequestAndUserID::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
}
inline const std::string& PakeRegistrationRequestAndUserID::deviceid() const {
  // @@protoc_insertion_point(field_get:identity.PakeRegistrationRequestAndUserID.deviceID)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeRegistrationRequestAndUserID::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeRegistrationRequestAndUserID.deviceID)
}
inline std::string* PakeRegistrationRequestAndUserID::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:identity.PakeRegistrationRequestAndUserID.deviceID)
  return _s;
}
inline const std::string& PakeRegistrationRequestAndUserID::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void PakeRegistrationRequestAndUserID::_internal_set_deviceid(const std::string& value) {
  
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::_internal_mutable_deviceid() {
  
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::release_deviceid() {
  // @@protoc_insertion_point(field_release:identity.PakeRegistrationRequestAndUserID.deviceID)
  return _impl_.deviceid_.Release();
}
inline void PakeRegistrationRequestAndUserID::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeRegistrationRequestAndUserID.deviceID)
}

// bytes pakeRegistrationRequest = 3;
inline void PakeRegistrationRequestAndUserID::clear_pakeregistrationrequest() {
  _impl_.pakeregistrationrequest_.ClearToEmpty();
}
inline const std::string& PakeRegistrationRequestAndUserID::pakeregistrationrequest() const {
  // @@protoc_insertion_point(field_get:identity.PakeRegistrationRequestAndUserID.pakeRegistrationRequest)
  return _internal_pakeregistrationrequest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeRegistrationRequestAndUserID::set_pakeregistrationrequest(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pakeregistrationrequest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeRegistrationRequestAndUserID.pakeRegistrationRequest)
}
inline std::string* PakeRegistrationRequestAndUserID::mutable_pakeregistrationrequest() {
  std::string* _s = _internal_mutable_pakeregistrationrequest();
  // @@protoc_insertion_point(field_mutable:identity.PakeRegistrationRequestAndUserID.pakeRegistrationRequest)
  return _s;
}
inline const std::string& PakeRegistrationRequestAndUserID::_internal_pakeregistrationrequest() const {
  return _impl_.pakeregistrationrequest_.Get();
}
inline void PakeRegistrationRequestAndUserID::_internal_set_pakeregistrationrequest(const std::string& value) {
  
  _impl_.pakeregistrationrequest_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::_internal_mutable_pakeregistrationrequest() {
  
  return _impl_.pakeregistrationrequest_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::release_pakeregistrationrequest() {
  // @@protoc_insertion_point(field_release:identity.PakeRegistrationRequestAndUserID.pakeRegistrationRequest)
  return _impl_.pakeregistrationrequest_.Release();
}
inline void PakeRegistrationRequestAndUserID::set_allocated_pakeregistrationrequest(std::string* pakeregistrationrequest) {
  if (pakeregistrationrequest != nullptr) {
    
  } else {
    
  }
  _impl_.pakeregistrationrequest_.SetAllocated(pakeregistrationrequest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pakeregistrationrequest_.IsDefault()) {
    _impl_.pakeregistrationrequest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeRegistrationRequestAndUserID.pakeRegistrationRequest)
}

// string username = 4;
inline void PakeRegistrationRequestAndUserID::clear_username() {
  _impl_.username_.ClearToEmpty();
}
inline const std::string& PakeRegistrationRequestAndUserID::username() const {
  // @@protoc_insertion_point(field_get:identity.PakeRegistrationRequestAndUserID.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeRegistrationRequestAndUserID::set_username(ArgT0&& arg0, ArgT... args) {
 
 _impl_.username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeRegistrationRequestAndUserID.username)
}
inline std::string* PakeRegistrationRequestAndUserID::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:identity.PakeRegistrationRequestAndUserID.username)
  return _s;
}
inline const std::string& PakeRegistrationRequestAndUserID::_internal_username() const {
  return _impl_.username_.Get();
}
inline void PakeRegistrationRequestAndUserID::_internal_set_username(const std::string& value) {
  
  _impl_.username_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::_internal_mutable_username() {
  
  return _impl_.username_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::release_username() {
  // @@protoc_insertion_point(field_release:identity.PakeRegistrationRequestAndUserID.username)
  return _impl_.username_.Release();
}
inline void PakeRegistrationRequestAndUserID::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  _impl_.username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.username_.IsDefault()) {
    _impl_.username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeRegistrationRequestAndUserID.username)
}

// string userPublicKey = 5;
inline void PakeRegistrationRequestAndUserID::clear_userpublickey() {
  _impl_.userpublickey_.ClearToEmpty();
}
inline const std::string& PakeRegistrationRequestAndUserID::userpublickey() const {
  // @@protoc_insertion_point(field_get:identity.PakeRegistrationRequestAndUserID.userPublicKey)
  return _internal_userpublickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeRegistrationRequestAndUserID::set_userpublickey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userpublickey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeRegistrationRequestAndUserID.userPublicKey)
}
inline std::string* PakeRegistrationRequestAndUserID::mutable_userpublickey() {
  std::string* _s = _internal_mutable_userpublickey();
  // @@protoc_insertion_point(field_mutable:identity.PakeRegistrationRequestAndUserID.userPublicKey)
  return _s;
}
inline const std::string& PakeRegistrationRequestAndUserID::_internal_userpublickey() const {
  return _impl_.userpublickey_.Get();
}
inline void PakeRegistrationRequestAndUserID::_internal_set_userpublickey(const std::string& value) {
  
  _impl_.userpublickey_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::_internal_mutable_userpublickey() {
  
  return _impl_.userpublickey_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeRegistrationRequestAndUserID::release_userpublickey() {
  // @@protoc_insertion_point(field_release:identity.PakeRegistrationRequestAndUserID.userPublicKey)
  return _impl_.userpublickey_.Release();
}
inline void PakeRegistrationRequestAndUserID::set_allocated_userpublickey(std::string* userpublickey) {
  if (userpublickey != nullptr) {
    
  } else {
    
  }
  _impl_.userpublickey_.SetAllocated(userpublickey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userpublickey_.IsDefault()) {
    _impl_.userpublickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeRegistrationRequestAndUserID.userPublicKey)
}

// -------------------------------------------------------------------

// PakeCredentialRequestAndUserID

// string userID = 1;
inline void PakeCredentialRequestAndUserID::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& PakeCredentialRequestAndUserID::userid() const {
  // @@protoc_insertion_point(field_get:identity.PakeCredentialRequestAndUserID.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeCredentialRequestAndUserID::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeCredentialRequestAndUserID.userID)
}
inline std::string* PakeCredentialRequestAndUserID::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:identity.PakeCredentialRequestAndUserID.userID)
  return _s;
}
inline const std::string& PakeCredentialRequestAndUserID::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void PakeCredentialRequestAndUserID::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeCredentialRequestAndUserID::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeCredentialRequestAndUserID::release_userid() {
  // @@protoc_insertion_point(field_release:identity.PakeCredentialRequestAndUserID.userID)
  return _impl_.userid_.Release();
}
inline void PakeCredentialRequestAndUserID::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeCredentialRequestAndUserID.userID)
}

// string deviceID = 2;
inline void PakeCredentialRequestAndUserID::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
}
inline const std::string& PakeCredentialRequestAndUserID::deviceid() const {
  // @@protoc_insertion_point(field_get:identity.PakeCredentialRequestAndUserID.deviceID)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeCredentialRequestAndUserID::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeCredentialRequestAndUserID.deviceID)
}
inline std::string* PakeCredentialRequestAndUserID::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:identity.PakeCredentialRequestAndUserID.deviceID)
  return _s;
}
inline const std::string& PakeCredentialRequestAndUserID::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void PakeCredentialRequestAndUserID::_internal_set_deviceid(const std::string& value) {
  
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeCredentialRequestAndUserID::_internal_mutable_deviceid() {
  
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeCredentialRequestAndUserID::release_deviceid() {
  // @@protoc_insertion_point(field_release:identity.PakeCredentialRequestAndUserID.deviceID)
  return _impl_.deviceid_.Release();
}
inline void PakeCredentialRequestAndUserID::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeCredentialRequestAndUserID.deviceID)
}

// bytes pakeCredentialRequest = 3;
inline void PakeCredentialRequestAndUserID::clear_pakecredentialrequest() {
  _impl_.pakecredentialrequest_.ClearToEmpty();
}
inline const std::string& PakeCredentialRequestAndUserID::pakecredentialrequest() const {
  // @@protoc_insertion_point(field_get:identity.PakeCredentialRequestAndUserID.pakeCredentialRequest)
  return _internal_pakecredentialrequest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeCredentialRequestAndUserID::set_pakecredentialrequest(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pakecredentialrequest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeCredentialRequestAndUserID.pakeCredentialRequest)
}
inline std::string* PakeCredentialRequestAndUserID::mutable_pakecredentialrequest() {
  std::string* _s = _internal_mutable_pakecredentialrequest();
  // @@protoc_insertion_point(field_mutable:identity.PakeCredentialRequestAndUserID.pakeCredentialRequest)
  return _s;
}
inline const std::string& PakeCredentialRequestAndUserID::_internal_pakecredentialrequest() const {
  return _impl_.pakecredentialrequest_.Get();
}
inline void PakeCredentialRequestAndUserID::_internal_set_pakecredentialrequest(const std::string& value) {
  
  _impl_.pakecredentialrequest_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeCredentialRequestAndUserID::_internal_mutable_pakecredentialrequest() {
  
  return _impl_.pakecredentialrequest_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeCredentialRequestAndUserID::release_pakecredentialrequest() {
  // @@protoc_insertion_point(field_release:identity.PakeCredentialRequestAndUserID.pakeCredentialRequest)
  return _impl_.pakecredentialrequest_.Release();
}
inline void PakeCredentialRequestAndUserID::set_allocated_pakecredentialrequest(std::string* pakecredentialrequest) {
  if (pakecredentialrequest != nullptr) {
    
  } else {
    
  }
  _impl_.pakecredentialrequest_.SetAllocated(pakecredentialrequest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pakecredentialrequest_.IsDefault()) {
    _impl_.pakecredentialrequest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeCredentialRequestAndUserID.pakeCredentialRequest)
}

// string userPublicKey = 4;
inline void PakeCredentialRequestAndUserID::clear_userpublickey() {
  _impl_.userpublickey_.ClearToEmpty();
}
inline const std::string& PakeCredentialRequestAndUserID::userpublickey() const {
  // @@protoc_insertion_point(field_get:identity.PakeCredentialRequestAndUserID.userPublicKey)
  return _internal_userpublickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeCredentialRequestAndUserID::set_userpublickey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userpublickey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeCredentialRequestAndUserID.userPublicKey)
}
inline std::string* PakeCredentialRequestAndUserID::mutable_userpublickey() {
  std::string* _s = _internal_mutable_userpublickey();
  // @@protoc_insertion_point(field_mutable:identity.PakeCredentialRequestAndUserID.userPublicKey)
  return _s;
}
inline const std::string& PakeCredentialRequestAndUserID::_internal_userpublickey() const {
  return _impl_.userpublickey_.Get();
}
inline void PakeCredentialRequestAndUserID::_internal_set_userpublickey(const std::string& value) {
  
  _impl_.userpublickey_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeCredentialRequestAndUserID::_internal_mutable_userpublickey() {
  
  return _impl_.userpublickey_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeCredentialRequestAndUserID::release_userpublickey() {
  // @@protoc_insertion_point(field_release:identity.PakeCredentialRequestAndUserID.userPublicKey)
  return _impl_.userpublickey_.Release();
}
inline void PakeCredentialRequestAndUserID::set_allocated_userpublickey(std::string* userpublickey) {
  if (userpublickey != nullptr) {
    
  } else {
    
  }
  _impl_.userpublickey_.SetAllocated(userpublickey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userpublickey_.IsDefault()) {
    _impl_.userpublickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeCredentialRequestAndUserID.userPublicKey)
}

// -------------------------------------------------------------------

// PakeLoginRequest

// .identity.PakeCredentialRequestAndUserID pakeCredentialRequestAndUserID = 1;
inline bool PakeLoginRequest::_internal_has_pakecredentialrequestanduserid() const {
  return data_case() == kPakeCredentialRequestAndUserID;
}
inline bool PakeLoginRequest::has_pakecredentialrequestanduserid() const {
  return _internal_has_pakecredentialrequestanduserid();
}
inline void PakeLoginRequest::set_has_pakecredentialrequestanduserid() {
  _impl_._oneof_case_[0] = kPakeCredentialRequestAndUserID;
}
inline void PakeLoginRequest::clear_pakecredentialrequestanduserid() {
  if (_internal_has_pakecredentialrequestanduserid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.pakecredentialrequestanduserid_;
    }
    clear_has_data();
  }
}
inline ::identity::PakeCredentialRequestAndUserID* PakeLoginRequest::release_pakecredentialrequestanduserid() {
  // @@protoc_insertion_point(field_release:identity.PakeLoginRequest.pakeCredentialRequestAndUserID)
  if (_internal_has_pakecredentialrequestanduserid()) {
    clear_has_data();
    ::identity::PakeCredentialRequestAndUserID* temp = _impl_.data_.pakecredentialrequestanduserid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.pakecredentialrequestanduserid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::identity::PakeCredentialRequestAndUserID& PakeLoginRequest::_internal_pakecredentialrequestanduserid() const {
  return _internal_has_pakecredentialrequestanduserid()
      ? *_impl_.data_.pakecredentialrequestanduserid_
      : reinterpret_cast< ::identity::PakeCredentialRequestAndUserID&>(::identity::_PakeCredentialRequestAndUserID_default_instance_);
}
inline const ::identity::PakeCredentialRequestAndUserID& PakeLoginRequest::pakecredentialrequestanduserid() const {
  // @@protoc_insertion_point(field_get:identity.PakeLoginRequest.pakeCredentialRequestAndUserID)
  return _internal_pakecredentialrequestanduserid();
}
inline ::identity::PakeCredentialRequestAndUserID* PakeLoginRequest::unsafe_arena_release_pakecredentialrequestanduserid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:identity.PakeLoginRequest.pakeCredentialRequestAndUserID)
  if (_internal_has_pakecredentialrequestanduserid()) {
    clear_has_data();
    ::identity::PakeCredentialRequestAndUserID* temp = _impl_.data_.pakecredentialrequestanduserid_;
    _impl_.data_.pakecredentialrequestanduserid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void PakeLoginRequest::unsafe_arena_set_allocated_pakecredentialrequestanduserid(::identity::PakeCredentialRequestAndUserID* pakecredentialrequestanduserid) {
  clear_data();
  if (pakecredentialrequestanduserid) {
    set_has_pakecredentialrequestanduserid();
    _impl_.data_.pakecredentialrequestanduserid_ = pakecredentialrequestanduserid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:identity.PakeLoginRequest.pakeCredentialRequestAndUserID)
}
inline ::identity::PakeCredentialRequestAndUserID* PakeLoginRequest::_internal_mutable_pakecredentialrequestanduserid() {
  if (!_internal_has_pakecredentialrequestanduserid()) {
    clear_data();
    set_has_pakecredentialrequestanduserid();
    _impl_.data_.pakecredentialrequestanduserid_ = CreateMaybeMessage< ::identity::PakeCredentialRequestAndUserID >(GetArenaForAllocation());
  }
  return _impl_.data_.pakecredentialrequestanduserid_;
}
inline ::identity::PakeCredentialRequestAndUserID* PakeLoginRequest::mutable_pakecredentialrequestanduserid() {
  ::identity::PakeCredentialRequestAndUserID* _msg = _internal_mutable_pakecredentialrequestanduserid();
  // @@protoc_insertion_point(field_mutable:identity.PakeLoginRequest.pakeCredentialRequestAndUserID)
  return _msg;
}

// bytes pakeCredentialFinalization = 2;
inline bool PakeLoginRequest::_internal_has_pakecredentialfinalization() const {
  return data_case() == kPakeCredentialFinalization;
}
inline bool PakeLoginRequest::has_pakecredentialfinalization() const {
  return _internal_has_pakecredentialfinalization();
}
inline void PakeLoginRequest::set_has_pakecredentialfinalization() {
  _impl_._oneof_case_[0] = kPakeCredentialFinalization;
}
inline void PakeLoginRequest::clear_pakecredentialfinalization() {
  if (_internal_has_pakecredentialfinalization()) {
    _impl_.data_.pakecredentialfinalization_.Destroy();
    clear_has_data();
  }
}
inline const std::string& PakeLoginRequest::pakecredentialfinalization() const {
  // @@protoc_insertion_point(field_get:identity.PakeLoginRequest.pakeCredentialFinalization)
  return _internal_pakecredentialfinalization();
}
template <typename ArgT0, typename... ArgT>
inline void PakeLoginRequest::set_pakecredentialfinalization(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_pakecredentialfinalization()) {
    clear_data();
    set_has_pakecredentialfinalization();
    _impl_.data_.pakecredentialfinalization_.InitDefault();
  }
  _impl_.data_.pakecredentialfinalization_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeLoginRequest.pakeCredentialFinalization)
}
inline std::string* PakeLoginRequest::mutable_pakecredentialfinalization() {
  std::string* _s = _internal_mutable_pakecredentialfinalization();
  // @@protoc_insertion_point(field_mutable:identity.PakeLoginRequest.pakeCredentialFinalization)
  return _s;
}
inline const std::string& PakeLoginRequest::_internal_pakecredentialfinalization() const {
  if (_internal_has_pakecredentialfinalization()) {
    return _impl_.data_.pakecredentialfinalization_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PakeLoginRequest::_internal_set_pakecredentialfinalization(const std::string& value) {
  if (!_internal_has_pakecredentialfinalization()) {
    clear_data();
    set_has_pakecredentialfinalization();
    _impl_.data_.pakecredentialfinalization_.InitDefault();
  }
  _impl_.data_.pakecredentialfinalization_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeLoginRequest::_internal_mutable_pakecredentialfinalization() {
  if (!_internal_has_pakecredentialfinalization()) {
    clear_data();
    set_has_pakecredentialfinalization();
    _impl_.data_.pakecredentialfinalization_.InitDefault();
  }
  return _impl_.data_.pakecredentialfinalization_.Mutable(      GetArenaForAllocation());
}
inline std::string* PakeLoginRequest::release_pakecredentialfinalization() {
  // @@protoc_insertion_point(field_release:identity.PakeLoginRequest.pakeCredentialFinalization)
  if (_internal_has_pakecredentialfinalization()) {
    clear_has_data();
    return _impl_.data_.pakecredentialfinalization_.Release();
  } else {
    return nullptr;
  }
}
inline void PakeLoginRequest::set_allocated_pakecredentialfinalization(std::string* pakecredentialfinalization) {
  if (has_data()) {
    clear_data();
  }
  if (pakecredentialfinalization != nullptr) {
    set_has_pakecredentialfinalization();
    _impl_.data_.pakecredentialfinalization_.InitAllocated(pakecredentialfinalization, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:identity.PakeLoginRequest.pakeCredentialFinalization)
}

inline bool PakeLoginRequest::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void PakeLoginRequest::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline PakeLoginRequest::DataCase PakeLoginRequest::data_case() const {
  return PakeLoginRequest::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PakeLoginResponse

// bytes pakeCredentialResponse = 1;
inline bool PakeLoginResponse::_internal_has_pakecredentialresponse() const {
  return data_case() == kPakeCredentialResponse;
}
inline bool PakeLoginResponse::has_pakecredentialresponse() const {
  return _internal_has_pakecredentialresponse();
}
inline void PakeLoginResponse::set_has_pakecredentialresponse() {
  _impl_._oneof_case_[0] = kPakeCredentialResponse;
}
inline void PakeLoginResponse::clear_pakecredentialresponse() {
  if (_internal_has_pakecredentialresponse()) {
    _impl_.data_.pakecredentialresponse_.Destroy();
    clear_has_data();
  }
}
inline const std::string& PakeLoginResponse::pakecredentialresponse() const {
  // @@protoc_insertion_point(field_get:identity.PakeLoginResponse.pakeCredentialResponse)
  return _internal_pakecredentialresponse();
}
template <typename ArgT0, typename... ArgT>
inline void PakeLoginResponse::set_pakecredentialresponse(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_pakecredentialresponse()) {
    clear_data();
    set_has_pakecredentialresponse();
    _impl_.data_.pakecredentialresponse_.InitDefault();
  }
  _impl_.data_.pakecredentialresponse_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeLoginResponse.pakeCredentialResponse)
}
inline std::string* PakeLoginResponse::mutable_pakecredentialresponse() {
  std::string* _s = _internal_mutable_pakecredentialresponse();
  // @@protoc_insertion_point(field_mutable:identity.PakeLoginResponse.pakeCredentialResponse)
  return _s;
}
inline const std::string& PakeLoginResponse::_internal_pakecredentialresponse() const {
  if (_internal_has_pakecredentialresponse()) {
    return _impl_.data_.pakecredentialresponse_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PakeLoginResponse::_internal_set_pakecredentialresponse(const std::string& value) {
  if (!_internal_has_pakecredentialresponse()) {
    clear_data();
    set_has_pakecredentialresponse();
    _impl_.data_.pakecredentialresponse_.InitDefault();
  }
  _impl_.data_.pakecredentialresponse_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeLoginResponse::_internal_mutable_pakecredentialresponse() {
  if (!_internal_has_pakecredentialresponse()) {
    clear_data();
    set_has_pakecredentialresponse();
    _impl_.data_.pakecredentialresponse_.InitDefault();
  }
  return _impl_.data_.pakecredentialresponse_.Mutable(      GetArenaForAllocation());
}
inline std::string* PakeLoginResponse::release_pakecredentialresponse() {
  // @@protoc_insertion_point(field_release:identity.PakeLoginResponse.pakeCredentialResponse)
  if (_internal_has_pakecredentialresponse()) {
    clear_has_data();
    return _impl_.data_.pakecredentialresponse_.Release();
  } else {
    return nullptr;
  }
}
inline void PakeLoginResponse::set_allocated_pakecredentialresponse(std::string* pakecredentialresponse) {
  if (has_data()) {
    clear_data();
  }
  if (pakecredentialresponse != nullptr) {
    set_has_pakecredentialresponse();
    _impl_.data_.pakecredentialresponse_.InitAllocated(pakecredentialresponse, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:identity.PakeLoginResponse.pakeCredentialResponse)
}

// string accessToken = 2;
inline bool PakeLoginResponse::_internal_has_accesstoken() const {
  return data_case() == kAccessToken;
}
inline bool PakeLoginResponse::has_accesstoken() const {
  return _internal_has_accesstoken();
}
inline void PakeLoginResponse::set_has_accesstoken() {
  _impl_._oneof_case_[0] = kAccessToken;
}
inline void PakeLoginResponse::clear_accesstoken() {
  if (_internal_has_accesstoken()) {
    _impl_.data_.accesstoken_.Destroy();
    clear_has_data();
  }
}
inline const std::string& PakeLoginResponse::accesstoken() const {
  // @@protoc_insertion_point(field_get:identity.PakeLoginResponse.accessToken)
  return _internal_accesstoken();
}
template <typename ArgT0, typename... ArgT>
inline void PakeLoginResponse::set_accesstoken(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_accesstoken()) {
    clear_data();
    set_has_accesstoken();
    _impl_.data_.accesstoken_.InitDefault();
  }
  _impl_.data_.accesstoken_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeLoginResponse.accessToken)
}
inline std::string* PakeLoginResponse::mutable_accesstoken() {
  std::string* _s = _internal_mutable_accesstoken();
  // @@protoc_insertion_point(field_mutable:identity.PakeLoginResponse.accessToken)
  return _s;
}
inline const std::string& PakeLoginResponse::_internal_accesstoken() const {
  if (_internal_has_accesstoken()) {
    return _impl_.data_.accesstoken_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void PakeLoginResponse::_internal_set_accesstoken(const std::string& value) {
  if (!_internal_has_accesstoken()) {
    clear_data();
    set_has_accesstoken();
    _impl_.data_.accesstoken_.InitDefault();
  }
  _impl_.data_.accesstoken_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeLoginResponse::_internal_mutable_accesstoken() {
  if (!_internal_has_accesstoken()) {
    clear_data();
    set_has_accesstoken();
    _impl_.data_.accesstoken_.InitDefault();
  }
  return _impl_.data_.accesstoken_.Mutable(      GetArenaForAllocation());
}
inline std::string* PakeLoginResponse::release_accesstoken() {
  // @@protoc_insertion_point(field_release:identity.PakeLoginResponse.accessToken)
  if (_internal_has_accesstoken()) {
    clear_has_data();
    return _impl_.data_.accesstoken_.Release();
  } else {
    return nullptr;
  }
}
inline void PakeLoginResponse::set_allocated_accesstoken(std::string* accesstoken) {
  if (has_data()) {
    clear_data();
  }
  if (accesstoken != nullptr) {
    set_has_accesstoken();
    _impl_.data_.accesstoken_.InitAllocated(accesstoken, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:identity.PakeLoginResponse.accessToken)
}

inline bool PakeLoginResponse::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void PakeLoginResponse::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline PakeLoginResponse::DataCase PakeLoginResponse::data_case() const {
  return PakeLoginResponse::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// PakeRegistrationUploadAndCredentialRequest

// bytes pakeRegistrationUpload = 1;
inline void PakeRegistrationUploadAndCredentialRequest::clear_pakeregistrationupload() {
  _impl_.pakeregistrationupload_.ClearToEmpty();
}
inline const std::string& PakeRegistrationUploadAndCredentialRequest::pakeregistrationupload() const {
  // @@protoc_insertion_point(field_get:identity.PakeRegistrationUploadAndCredentialRequest.pakeRegistrationUpload)
  return _internal_pakeregistrationupload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeRegistrationUploadAndCredentialRequest::set_pakeregistrationupload(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pakeregistrationupload_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeRegistrationUploadAndCredentialRequest.pakeRegistrationUpload)
}
inline std::string* PakeRegistrationUploadAndCredentialRequest::mutable_pakeregistrationupload() {
  std::string* _s = _internal_mutable_pakeregistrationupload();
  // @@protoc_insertion_point(field_mutable:identity.PakeRegistrationUploadAndCredentialRequest.pakeRegistrationUpload)
  return _s;
}
inline const std::string& PakeRegistrationUploadAndCredentialRequest::_internal_pakeregistrationupload() const {
  return _impl_.pakeregistrationupload_.Get();
}
inline void PakeRegistrationUploadAndCredentialRequest::_internal_set_pakeregistrationupload(const std::string& value) {
  
  _impl_.pakeregistrationupload_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeRegistrationUploadAndCredentialRequest::_internal_mutable_pakeregistrationupload() {
  
  return _impl_.pakeregistrationupload_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeRegistrationUploadAndCredentialRequest::release_pakeregistrationupload() {
  // @@protoc_insertion_point(field_release:identity.PakeRegistrationUploadAndCredentialRequest.pakeRegistrationUpload)
  return _impl_.pakeregistrationupload_.Release();
}
inline void PakeRegistrationUploadAndCredentialRequest::set_allocated_pakeregistrationupload(std::string* pakeregistrationupload) {
  if (pakeregistrationupload != nullptr) {
    
  } else {
    
  }
  _impl_.pakeregistrationupload_.SetAllocated(pakeregistrationupload, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pakeregistrationupload_.IsDefault()) {
    _impl_.pakeregistrationupload_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeRegistrationUploadAndCredentialRequest.pakeRegistrationUpload)
}

// bytes pakeCredentialRequest = 2;
inline void PakeRegistrationUploadAndCredentialRequest::clear_pakecredentialrequest() {
  _impl_.pakecredentialrequest_.ClearToEmpty();
}
inline const std::string& PakeRegistrationUploadAndCredentialRequest::pakecredentialrequest() const {
  // @@protoc_insertion_point(field_get:identity.PakeRegistrationUploadAndCredentialRequest.pakeCredentialRequest)
  return _internal_pakecredentialrequest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PakeRegistrationUploadAndCredentialRequest::set_pakecredentialrequest(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pakecredentialrequest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.PakeRegistrationUploadAndCredentialRequest.pakeCredentialRequest)
}
inline std::string* PakeRegistrationUploadAndCredentialRequest::mutable_pakecredentialrequest() {
  std::string* _s = _internal_mutable_pakecredentialrequest();
  // @@protoc_insertion_point(field_mutable:identity.PakeRegistrationUploadAndCredentialRequest.pakeCredentialRequest)
  return _s;
}
inline const std::string& PakeRegistrationUploadAndCredentialRequest::_internal_pakecredentialrequest() const {
  return _impl_.pakecredentialrequest_.Get();
}
inline void PakeRegistrationUploadAndCredentialRequest::_internal_set_pakecredentialrequest(const std::string& value) {
  
  _impl_.pakecredentialrequest_.Set(value, GetArenaForAllocation());
}
inline std::string* PakeRegistrationUploadAndCredentialRequest::_internal_mutable_pakecredentialrequest() {
  
  return _impl_.pakecredentialrequest_.Mutable(GetArenaForAllocation());
}
inline std::string* PakeRegistrationUploadAndCredentialRequest::release_pakecredentialrequest() {
  // @@protoc_insertion_point(field_release:identity.PakeRegistrationUploadAndCredentialRequest.pakeCredentialRequest)
  return _impl_.pakecredentialrequest_.Release();
}
inline void PakeRegistrationUploadAndCredentialRequest::set_allocated_pakecredentialrequest(std::string* pakecredentialrequest) {
  if (pakecredentialrequest != nullptr) {
    
  } else {
    
  }
  _impl_.pakecredentialrequest_.SetAllocated(pakecredentialrequest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pakecredentialrequest_.IsDefault()) {
    _impl_.pakecredentialrequest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.PakeRegistrationUploadAndCredentialRequest.pakeCredentialRequest)
}

// -------------------------------------------------------------------

// WalletLoginRequest

// string userID = 1;
inline void WalletLoginRequest::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& WalletLoginRequest::userid() const {
  // @@protoc_insertion_point(field_get:identity.WalletLoginRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalletLoginRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.WalletLoginRequest.userID)
}
inline std::string* WalletLoginRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:identity.WalletLoginRequest.userID)
  return _s;
}
inline const std::string& WalletLoginRequest::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void WalletLoginRequest::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::release_userid() {
  // @@protoc_insertion_point(field_release:identity.WalletLoginRequest.userID)
  return _impl_.userid_.Release();
}
inline void WalletLoginRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.WalletLoginRequest.userID)
}

// string deviceID = 2;
inline void WalletLoginRequest::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
}
inline const std::string& WalletLoginRequest::deviceid() const {
  // @@protoc_insertion_point(field_get:identity.WalletLoginRequest.deviceID)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalletLoginRequest::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.WalletLoginRequest.deviceID)
}
inline std::string* WalletLoginRequest::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:identity.WalletLoginRequest.deviceID)
  return _s;
}
inline const std::string& WalletLoginRequest::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void WalletLoginRequest::_internal_set_deviceid(const std::string& value) {
  
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::_internal_mutable_deviceid() {
  
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::release_deviceid() {
  // @@protoc_insertion_point(field_release:identity.WalletLoginRequest.deviceID)
  return _impl_.deviceid_.Release();
}
inline void WalletLoginRequest::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.WalletLoginRequest.deviceID)
}

// string siweMessage = 3;
inline void WalletLoginRequest::clear_siwemessage() {
  _impl_.siwemessage_.ClearToEmpty();
}
inline const std::string& WalletLoginRequest::siwemessage() const {
  // @@protoc_insertion_point(field_get:identity.WalletLoginRequest.siweMessage)
  return _internal_siwemessage();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalletLoginRequest::set_siwemessage(ArgT0&& arg0, ArgT... args) {
 
 _impl_.siwemessage_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.WalletLoginRequest.siweMessage)
}
inline std::string* WalletLoginRequest::mutable_siwemessage() {
  std::string* _s = _internal_mutable_siwemessage();
  // @@protoc_insertion_point(field_mutable:identity.WalletLoginRequest.siweMessage)
  return _s;
}
inline const std::string& WalletLoginRequest::_internal_siwemessage() const {
  return _impl_.siwemessage_.Get();
}
inline void WalletLoginRequest::_internal_set_siwemessage(const std::string& value) {
  
  _impl_.siwemessage_.Set(value, GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::_internal_mutable_siwemessage() {
  
  return _impl_.siwemessage_.Mutable(GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::release_siwemessage() {
  // @@protoc_insertion_point(field_release:identity.WalletLoginRequest.siweMessage)
  return _impl_.siwemessage_.Release();
}
inline void WalletLoginRequest::set_allocated_siwemessage(std::string* siwemessage) {
  if (siwemessage != nullptr) {
    
  } else {
    
  }
  _impl_.siwemessage_.SetAllocated(siwemessage, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.siwemessage_.IsDefault()) {
    _impl_.siwemessage_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.WalletLoginRequest.siweMessage)
}

// bytes siweSignature = 4;
inline void WalletLoginRequest::clear_siwesignature() {
  _impl_.siwesignature_.ClearToEmpty();
}
inline const std::string& WalletLoginRequest::siwesignature() const {
  // @@protoc_insertion_point(field_get:identity.WalletLoginRequest.siweSignature)
  return _internal_siwesignature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalletLoginRequest::set_siwesignature(ArgT0&& arg0, ArgT... args) {
 
 _impl_.siwesignature_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.WalletLoginRequest.siweSignature)
}
inline std::string* WalletLoginRequest::mutable_siwesignature() {
  std::string* _s = _internal_mutable_siwesignature();
  // @@protoc_insertion_point(field_mutable:identity.WalletLoginRequest.siweSignature)
  return _s;
}
inline const std::string& WalletLoginRequest::_internal_siwesignature() const {
  return _impl_.siwesignature_.Get();
}
inline void WalletLoginRequest::_internal_set_siwesignature(const std::string& value) {
  
  _impl_.siwesignature_.Set(value, GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::_internal_mutable_siwesignature() {
  
  return _impl_.siwesignature_.Mutable(GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::release_siwesignature() {
  // @@protoc_insertion_point(field_release:identity.WalletLoginRequest.siweSignature)
  return _impl_.siwesignature_.Release();
}
inline void WalletLoginRequest::set_allocated_siwesignature(std::string* siwesignature) {
  if (siwesignature != nullptr) {
    
  } else {
    
  }
  _impl_.siwesignature_.SetAllocated(siwesignature, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.siwesignature_.IsDefault()) {
    _impl_.siwesignature_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.WalletLoginRequest.siweSignature)
}

// string userPublicKey = 5;
inline void WalletLoginRequest::clear_userpublickey() {
  _impl_.userpublickey_.ClearToEmpty();
}
inline const std::string& WalletLoginRequest::userpublickey() const {
  // @@protoc_insertion_point(field_get:identity.WalletLoginRequest.userPublicKey)
  return _internal_userpublickey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalletLoginRequest::set_userpublickey(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userpublickey_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.WalletLoginRequest.userPublicKey)
}
inline std::string* WalletLoginRequest::mutable_userpublickey() {
  std::string* _s = _internal_mutable_userpublickey();
  // @@protoc_insertion_point(field_mutable:identity.WalletLoginRequest.userPublicKey)
  return _s;
}
inline const std::string& WalletLoginRequest::_internal_userpublickey() const {
  return _impl_.userpublickey_.Get();
}
inline void WalletLoginRequest::_internal_set_userpublickey(const std::string& value) {
  
  _impl_.userpublickey_.Set(value, GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::_internal_mutable_userpublickey() {
  
  return _impl_.userpublickey_.Mutable(GetArenaForAllocation());
}
inline std::string* WalletLoginRequest::release_userpublickey() {
  // @@protoc_insertion_point(field_release:identity.WalletLoginRequest.userPublicKey)
  return _impl_.userpublickey_.Release();
}
inline void WalletLoginRequest::set_allocated_userpublickey(std::string* userpublickey) {
  if (userpublickey != nullptr) {
    
  } else {
    
  }
  _impl_.userpublickey_.SetAllocated(userpublickey, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userpublickey_.IsDefault()) {
    _impl_.userpublickey_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.WalletLoginRequest.userPublicKey)
}

// -------------------------------------------------------------------

// WalletLoginResponse

// string accessToken = 1;
inline void WalletLoginResponse::clear_accesstoken() {
  _impl_.accesstoken_.ClearToEmpty();
}
inline const std::string& WalletLoginResponse::accesstoken() const {
  // @@protoc_insertion_point(field_get:identity.WalletLoginResponse.accessToken)
  return _internal_accesstoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void WalletLoginResponse::set_accesstoken(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accesstoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.WalletLoginResponse.accessToken)
}
inline std::string* WalletLoginResponse::mutable_accesstoken() {
  std::string* _s = _internal_mutable_accesstoken();
  // @@protoc_insertion_point(field_mutable:identity.WalletLoginResponse.accessToken)
  return _s;
}
inline const std::string& WalletLoginResponse::_internal_accesstoken() const {
  return _impl_.accesstoken_.Get();
}
inline void WalletLoginResponse::_internal_set_accesstoken(const std::string& value) {
  
  _impl_.accesstoken_.Set(value, GetArenaForAllocation());
}
inline std::string* WalletLoginResponse::_internal_mutable_accesstoken() {
  
  return _impl_.accesstoken_.Mutable(GetArenaForAllocation());
}
inline std::string* WalletLoginResponse::release_accesstoken() {
  // @@protoc_insertion_point(field_release:identity.WalletLoginResponse.accessToken)
  return _impl_.accesstoken_.Release();
}
inline void WalletLoginResponse::set_allocated_accesstoken(std::string* accesstoken) {
  if (accesstoken != nullptr) {
    
  } else {
    
  }
  _impl_.accesstoken_.SetAllocated(accesstoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accesstoken_.IsDefault()) {
    _impl_.accesstoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.WalletLoginResponse.accessToken)
}

// -------------------------------------------------------------------

// RegistrationRequest

// .identity.PakeRegistrationRequestAndUserID pakeRegistrationRequestAndUserID = 1;
inline bool RegistrationRequest::_internal_has_pakeregistrationrequestanduserid() const {
  return data_case() == kPakeRegistrationRequestAndUserID;
}
inline bool RegistrationRequest::has_pakeregistrationrequestanduserid() const {
  return _internal_has_pakeregistrationrequestanduserid();
}
inline void RegistrationRequest::set_has_pakeregistrationrequestanduserid() {
  _impl_._oneof_case_[0] = kPakeRegistrationRequestAndUserID;
}
inline void RegistrationRequest::clear_pakeregistrationrequestanduserid() {
  if (_internal_has_pakeregistrationrequestanduserid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.pakeregistrationrequestanduserid_;
    }
    clear_has_data();
  }
}
inline ::identity::PakeRegistrationRequestAndUserID* RegistrationRequest::release_pakeregistrationrequestanduserid() {
  // @@protoc_insertion_point(field_release:identity.RegistrationRequest.pakeRegistrationRequestAndUserID)
  if (_internal_has_pakeregistrationrequestanduserid()) {
    clear_has_data();
    ::identity::PakeRegistrationRequestAndUserID* temp = _impl_.data_.pakeregistrationrequestanduserid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.pakeregistrationrequestanduserid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::identity::PakeRegistrationRequestAndUserID& RegistrationRequest::_internal_pakeregistrationrequestanduserid() const {
  return _internal_has_pakeregistrationrequestanduserid()
      ? *_impl_.data_.pakeregistrationrequestanduserid_
      : reinterpret_cast< ::identity::PakeRegistrationRequestAndUserID&>(::identity::_PakeRegistrationRequestAndUserID_default_instance_);
}
inline const ::identity::PakeRegistrationRequestAndUserID& RegistrationRequest::pakeregistrationrequestanduserid() const {
  // @@protoc_insertion_point(field_get:identity.RegistrationRequest.pakeRegistrationRequestAndUserID)
  return _internal_pakeregistrationrequestanduserid();
}
inline ::identity::PakeRegistrationRequestAndUserID* RegistrationRequest::unsafe_arena_release_pakeregistrationrequestanduserid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:identity.RegistrationRequest.pakeRegistrationRequestAndUserID)
  if (_internal_has_pakeregistrationrequestanduserid()) {
    clear_has_data();
    ::identity::PakeRegistrationRequestAndUserID* temp = _impl_.data_.pakeregistrationrequestanduserid_;
    _impl_.data_.pakeregistrationrequestanduserid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegistrationRequest::unsafe_arena_set_allocated_pakeregistrationrequestanduserid(::identity::PakeRegistrationRequestAndUserID* pakeregistrationrequestanduserid) {
  clear_data();
  if (pakeregistrationrequestanduserid) {
    set_has_pakeregistrationrequestanduserid();
    _impl_.data_.pakeregistrationrequestanduserid_ = pakeregistrationrequestanduserid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:identity.RegistrationRequest.pakeRegistrationRequestAndUserID)
}
inline ::identity::PakeRegistrationRequestAndUserID* RegistrationRequest::_internal_mutable_pakeregistrationrequestanduserid() {
  if (!_internal_has_pakeregistrationrequestanduserid()) {
    clear_data();
    set_has_pakeregistrationrequestanduserid();
    _impl_.data_.pakeregistrationrequestanduserid_ = CreateMaybeMessage< ::identity::PakeRegistrationRequestAndUserID >(GetArenaForAllocation());
  }
  return _impl_.data_.pakeregistrationrequestanduserid_;
}
inline ::identity::PakeRegistrationRequestAndUserID* RegistrationRequest::mutable_pakeregistrationrequestanduserid() {
  ::identity::PakeRegistrationRequestAndUserID* _msg = _internal_mutable_pakeregistrationrequestanduserid();
  // @@protoc_insertion_point(field_mutable:identity.RegistrationRequest.pakeRegistrationRequestAndUserID)
  return _msg;
}

// .identity.PakeRegistrationUploadAndCredentialRequest pakeRegistrationUploadAndCredentialRequest = 2;
inline bool RegistrationRequest::_internal_has_pakeregistrationuploadandcredentialrequest() const {
  return data_case() == kPakeRegistrationUploadAndCredentialRequest;
}
inline bool RegistrationRequest::has_pakeregistrationuploadandcredentialrequest() const {
  return _internal_has_pakeregistrationuploadandcredentialrequest();
}
inline void RegistrationRequest::set_has_pakeregistrationuploadandcredentialrequest() {
  _impl_._oneof_case_[0] = kPakeRegistrationUploadAndCredentialRequest;
}
inline void RegistrationRequest::clear_pakeregistrationuploadandcredentialrequest() {
  if (_internal_has_pakeregistrationuploadandcredentialrequest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.pakeregistrationuploadandcredentialrequest_;
    }
    clear_has_data();
  }
}
inline ::identity::PakeRegistrationUploadAndCredentialRequest* RegistrationRequest::release_pakeregistrationuploadandcredentialrequest() {
  // @@protoc_insertion_point(field_release:identity.RegistrationRequest.pakeRegistrationUploadAndCredentialRequest)
  if (_internal_has_pakeregistrationuploadandcredentialrequest()) {
    clear_has_data();
    ::identity::PakeRegistrationUploadAndCredentialRequest* temp = _impl_.data_.pakeregistrationuploadandcredentialrequest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.pakeregistrationuploadandcredentialrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::identity::PakeRegistrationUploadAndCredentialRequest& RegistrationRequest::_internal_pakeregistrationuploadandcredentialrequest() const {
  return _internal_has_pakeregistrationuploadandcredentialrequest()
      ? *_impl_.data_.pakeregistrationuploadandcredentialrequest_
      : reinterpret_cast< ::identity::PakeRegistrationUploadAndCredentialRequest&>(::identity::_PakeRegistrationUploadAndCredentialRequest_default_instance_);
}
inline const ::identity::PakeRegistrationUploadAndCredentialRequest& RegistrationRequest::pakeregistrationuploadandcredentialrequest() const {
  // @@protoc_insertion_point(field_get:identity.RegistrationRequest.pakeRegistrationUploadAndCredentialRequest)
  return _internal_pakeregistrationuploadandcredentialrequest();
}
inline ::identity::PakeRegistrationUploadAndCredentialRequest* RegistrationRequest::unsafe_arena_release_pakeregistrationuploadandcredentialrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:identity.RegistrationRequest.pakeRegistrationUploadAndCredentialRequest)
  if (_internal_has_pakeregistrationuploadandcredentialrequest()) {
    clear_has_data();
    ::identity::PakeRegistrationUploadAndCredentialRequest* temp = _impl_.data_.pakeregistrationuploadandcredentialrequest_;
    _impl_.data_.pakeregistrationuploadandcredentialrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegistrationRequest::unsafe_arena_set_allocated_pakeregistrationuploadandcredentialrequest(::identity::PakeRegistrationUploadAndCredentialRequest* pakeregistrationuploadandcredentialrequest) {
  clear_data();
  if (pakeregistrationuploadandcredentialrequest) {
    set_has_pakeregistrationuploadandcredentialrequest();
    _impl_.data_.pakeregistrationuploadandcredentialrequest_ = pakeregistrationuploadandcredentialrequest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:identity.RegistrationRequest.pakeRegistrationUploadAndCredentialRequest)
}
inline ::identity::PakeRegistrationUploadAndCredentialRequest* RegistrationRequest::_internal_mutable_pakeregistrationuploadandcredentialrequest() {
  if (!_internal_has_pakeregistrationuploadandcredentialrequest()) {
    clear_data();
    set_has_pakeregistrationuploadandcredentialrequest();
    _impl_.data_.pakeregistrationuploadandcredentialrequest_ = CreateMaybeMessage< ::identity::PakeRegistrationUploadAndCredentialRequest >(GetArenaForAllocation());
  }
  return _impl_.data_.pakeregistrationuploadandcredentialrequest_;
}
inline ::identity::PakeRegistrationUploadAndCredentialRequest* RegistrationRequest::mutable_pakeregistrationuploadandcredentialrequest() {
  ::identity::PakeRegistrationUploadAndCredentialRequest* _msg = _internal_mutable_pakeregistrationuploadandcredentialrequest();
  // @@protoc_insertion_point(field_mutable:identity.RegistrationRequest.pakeRegistrationUploadAndCredentialRequest)
  return _msg;
}

// bytes pakeCredentialFinalization = 3;
inline bool RegistrationRequest::_internal_has_pakecredentialfinalization() const {
  return data_case() == kPakeCredentialFinalization;
}
inline bool RegistrationRequest::has_pakecredentialfinalization() const {
  return _internal_has_pakecredentialfinalization();
}
inline void RegistrationRequest::set_has_pakecredentialfinalization() {
  _impl_._oneof_case_[0] = kPakeCredentialFinalization;
}
inline void RegistrationRequest::clear_pakecredentialfinalization() {
  if (_internal_has_pakecredentialfinalization()) {
    _impl_.data_.pakecredentialfinalization_.Destroy();
    clear_has_data();
  }
}
inline const std::string& RegistrationRequest::pakecredentialfinalization() const {
  // @@protoc_insertion_point(field_get:identity.RegistrationRequest.pakeCredentialFinalization)
  return _internal_pakecredentialfinalization();
}
template <typename ArgT0, typename... ArgT>
inline void RegistrationRequest::set_pakecredentialfinalization(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_pakecredentialfinalization()) {
    clear_data();
    set_has_pakecredentialfinalization();
    _impl_.data_.pakecredentialfinalization_.InitDefault();
  }
  _impl_.data_.pakecredentialfinalization_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.RegistrationRequest.pakeCredentialFinalization)
}
inline std::string* RegistrationRequest::mutable_pakecredentialfinalization() {
  std::string* _s = _internal_mutable_pakecredentialfinalization();
  // @@protoc_insertion_point(field_mutable:identity.RegistrationRequest.pakeCredentialFinalization)
  return _s;
}
inline const std::string& RegistrationRequest::_internal_pakecredentialfinalization() const {
  if (_internal_has_pakecredentialfinalization()) {
    return _impl_.data_.pakecredentialfinalization_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RegistrationRequest::_internal_set_pakecredentialfinalization(const std::string& value) {
  if (!_internal_has_pakecredentialfinalization()) {
    clear_data();
    set_has_pakecredentialfinalization();
    _impl_.data_.pakecredentialfinalization_.InitDefault();
  }
  _impl_.data_.pakecredentialfinalization_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistrationRequest::_internal_mutable_pakecredentialfinalization() {
  if (!_internal_has_pakecredentialfinalization()) {
    clear_data();
    set_has_pakecredentialfinalization();
    _impl_.data_.pakecredentialfinalization_.InitDefault();
  }
  return _impl_.data_.pakecredentialfinalization_.Mutable(      GetArenaForAllocation());
}
inline std::string* RegistrationRequest::release_pakecredentialfinalization() {
  // @@protoc_insertion_point(field_release:identity.RegistrationRequest.pakeCredentialFinalization)
  if (_internal_has_pakecredentialfinalization()) {
    clear_has_data();
    return _impl_.data_.pakecredentialfinalization_.Release();
  } else {
    return nullptr;
  }
}
inline void RegistrationRequest::set_allocated_pakecredentialfinalization(std::string* pakecredentialfinalization) {
  if (has_data()) {
    clear_data();
  }
  if (pakecredentialfinalization != nullptr) {
    set_has_pakecredentialfinalization();
    _impl_.data_.pakecredentialfinalization_.InitAllocated(pakecredentialfinalization, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:identity.RegistrationRequest.pakeCredentialFinalization)
}

inline bool RegistrationRequest::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void RegistrationRequest::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline RegistrationRequest::DataCase RegistrationRequest::data_case() const {
  return RegistrationRequest::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// RegistrationResponse

// bytes pakeRegistrationResponse = 1;
inline bool RegistrationResponse::_internal_has_pakeregistrationresponse() const {
  return data_case() == kPakeRegistrationResponse;
}
inline bool RegistrationResponse::has_pakeregistrationresponse() const {
  return _internal_has_pakeregistrationresponse();
}
inline void RegistrationResponse::set_has_pakeregistrationresponse() {
  _impl_._oneof_case_[0] = kPakeRegistrationResponse;
}
inline void RegistrationResponse::clear_pakeregistrationresponse() {
  if (_internal_has_pakeregistrationresponse()) {
    _impl_.data_.pakeregistrationresponse_.Destroy();
    clear_has_data();
  }
}
inline const std::string& RegistrationResponse::pakeregistrationresponse() const {
  // @@protoc_insertion_point(field_get:identity.RegistrationResponse.pakeRegistrationResponse)
  return _internal_pakeregistrationresponse();
}
template <typename ArgT0, typename... ArgT>
inline void RegistrationResponse::set_pakeregistrationresponse(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_pakeregistrationresponse()) {
    clear_data();
    set_has_pakeregistrationresponse();
    _impl_.data_.pakeregistrationresponse_.InitDefault();
  }
  _impl_.data_.pakeregistrationresponse_.SetBytes( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.RegistrationResponse.pakeRegistrationResponse)
}
inline std::string* RegistrationResponse::mutable_pakeregistrationresponse() {
  std::string* _s = _internal_mutable_pakeregistrationresponse();
  // @@protoc_insertion_point(field_mutable:identity.RegistrationResponse.pakeRegistrationResponse)
  return _s;
}
inline const std::string& RegistrationResponse::_internal_pakeregistrationresponse() const {
  if (_internal_has_pakeregistrationresponse()) {
    return _impl_.data_.pakeregistrationresponse_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void RegistrationResponse::_internal_set_pakeregistrationresponse(const std::string& value) {
  if (!_internal_has_pakeregistrationresponse()) {
    clear_data();
    set_has_pakeregistrationresponse();
    _impl_.data_.pakeregistrationresponse_.InitDefault();
  }
  _impl_.data_.pakeregistrationresponse_.Set(value, GetArenaForAllocation());
}
inline std::string* RegistrationResponse::_internal_mutable_pakeregistrationresponse() {
  if (!_internal_has_pakeregistrationresponse()) {
    clear_data();
    set_has_pakeregistrationresponse();
    _impl_.data_.pakeregistrationresponse_.InitDefault();
  }
  return _impl_.data_.pakeregistrationresponse_.Mutable(      GetArenaForAllocation());
}
inline std::string* RegistrationResponse::release_pakeregistrationresponse() {
  // @@protoc_insertion_point(field_release:identity.RegistrationResponse.pakeRegistrationResponse)
  if (_internal_has_pakeregistrationresponse()) {
    clear_has_data();
    return _impl_.data_.pakeregistrationresponse_.Release();
  } else {
    return nullptr;
  }
}
inline void RegistrationResponse::set_allocated_pakeregistrationresponse(std::string* pakeregistrationresponse) {
  if (has_data()) {
    clear_data();
  }
  if (pakeregistrationresponse != nullptr) {
    set_has_pakeregistrationresponse();
    _impl_.data_.pakeregistrationresponse_.InitAllocated(pakeregistrationresponse, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:identity.RegistrationResponse.pakeRegistrationResponse)
}

// .identity.PakeLoginResponse pakeLoginResponse = 2;
inline bool RegistrationResponse::_internal_has_pakeloginresponse() const {
  return data_case() == kPakeLoginResponse;
}
inline bool RegistrationResponse::has_pakeloginresponse() const {
  return _internal_has_pakeloginresponse();
}
inline void RegistrationResponse::set_has_pakeloginresponse() {
  _impl_._oneof_case_[0] = kPakeLoginResponse;
}
inline void RegistrationResponse::clear_pakeloginresponse() {
  if (_internal_has_pakeloginresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.pakeloginresponse_;
    }
    clear_has_data();
  }
}
inline ::identity::PakeLoginResponse* RegistrationResponse::release_pakeloginresponse() {
  // @@protoc_insertion_point(field_release:identity.RegistrationResponse.pakeLoginResponse)
  if (_internal_has_pakeloginresponse()) {
    clear_has_data();
    ::identity::PakeLoginResponse* temp = _impl_.data_.pakeloginresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.pakeloginresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::identity::PakeLoginResponse& RegistrationResponse::_internal_pakeloginresponse() const {
  return _internal_has_pakeloginresponse()
      ? *_impl_.data_.pakeloginresponse_
      : reinterpret_cast< ::identity::PakeLoginResponse&>(::identity::_PakeLoginResponse_default_instance_);
}
inline const ::identity::PakeLoginResponse& RegistrationResponse::pakeloginresponse() const {
  // @@protoc_insertion_point(field_get:identity.RegistrationResponse.pakeLoginResponse)
  return _internal_pakeloginresponse();
}
inline ::identity::PakeLoginResponse* RegistrationResponse::unsafe_arena_release_pakeloginresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:identity.RegistrationResponse.pakeLoginResponse)
  if (_internal_has_pakeloginresponse()) {
    clear_has_data();
    ::identity::PakeLoginResponse* temp = _impl_.data_.pakeloginresponse_;
    _impl_.data_.pakeloginresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void RegistrationResponse::unsafe_arena_set_allocated_pakeloginresponse(::identity::PakeLoginResponse* pakeloginresponse) {
  clear_data();
  if (pakeloginresponse) {
    set_has_pakeloginresponse();
    _impl_.data_.pakeloginresponse_ = pakeloginresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:identity.RegistrationResponse.pakeLoginResponse)
}
inline ::identity::PakeLoginResponse* RegistrationResponse::_internal_mutable_pakeloginresponse() {
  if (!_internal_has_pakeloginresponse()) {
    clear_data();
    set_has_pakeloginresponse();
    _impl_.data_.pakeloginresponse_ = CreateMaybeMessage< ::identity::PakeLoginResponse >(GetArenaForAllocation());
  }
  return _impl_.data_.pakeloginresponse_;
}
inline ::identity::PakeLoginResponse* RegistrationResponse::mutable_pakeloginresponse() {
  ::identity::PakeLoginResponse* _msg = _internal_mutable_pakeloginresponse();
  // @@protoc_insertion_point(field_mutable:identity.RegistrationResponse.pakeLoginResponse)
  return _msg;
}

inline bool RegistrationResponse::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void RegistrationResponse::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline RegistrationResponse::DataCase RegistrationResponse::data_case() const {
  return RegistrationResponse::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginRequest

// .identity.PakeLoginRequest pakeLoginRequest = 1;
inline bool LoginRequest::_internal_has_pakeloginrequest() const {
  return data_case() == kPakeLoginRequest;
}
inline bool LoginRequest::has_pakeloginrequest() const {
  return _internal_has_pakeloginrequest();
}
inline void LoginRequest::set_has_pakeloginrequest() {
  _impl_._oneof_case_[0] = kPakeLoginRequest;
}
inline void LoginRequest::clear_pakeloginrequest() {
  if (_internal_has_pakeloginrequest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.pakeloginrequest_;
    }
    clear_has_data();
  }
}
inline ::identity::PakeLoginRequest* LoginRequest::release_pakeloginrequest() {
  // @@protoc_insertion_point(field_release:identity.LoginRequest.pakeLoginRequest)
  if (_internal_has_pakeloginrequest()) {
    clear_has_data();
    ::identity::PakeLoginRequest* temp = _impl_.data_.pakeloginrequest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.pakeloginrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::identity::PakeLoginRequest& LoginRequest::_internal_pakeloginrequest() const {
  return _internal_has_pakeloginrequest()
      ? *_impl_.data_.pakeloginrequest_
      : reinterpret_cast< ::identity::PakeLoginRequest&>(::identity::_PakeLoginRequest_default_instance_);
}
inline const ::identity::PakeLoginRequest& LoginRequest::pakeloginrequest() const {
  // @@protoc_insertion_point(field_get:identity.LoginRequest.pakeLoginRequest)
  return _internal_pakeloginrequest();
}
inline ::identity::PakeLoginRequest* LoginRequest::unsafe_arena_release_pakeloginrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:identity.LoginRequest.pakeLoginRequest)
  if (_internal_has_pakeloginrequest()) {
    clear_has_data();
    ::identity::PakeLoginRequest* temp = _impl_.data_.pakeloginrequest_;
    _impl_.data_.pakeloginrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginRequest::unsafe_arena_set_allocated_pakeloginrequest(::identity::PakeLoginRequest* pakeloginrequest) {
  clear_data();
  if (pakeloginrequest) {
    set_has_pakeloginrequest();
    _impl_.data_.pakeloginrequest_ = pakeloginrequest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:identity.LoginRequest.pakeLoginRequest)
}
inline ::identity::PakeLoginRequest* LoginRequest::_internal_mutable_pakeloginrequest() {
  if (!_internal_has_pakeloginrequest()) {
    clear_data();
    set_has_pakeloginrequest();
    _impl_.data_.pakeloginrequest_ = CreateMaybeMessage< ::identity::PakeLoginRequest >(GetArenaForAllocation());
  }
  return _impl_.data_.pakeloginrequest_;
}
inline ::identity::PakeLoginRequest* LoginRequest::mutable_pakeloginrequest() {
  ::identity::PakeLoginRequest* _msg = _internal_mutable_pakeloginrequest();
  // @@protoc_insertion_point(field_mutable:identity.LoginRequest.pakeLoginRequest)
  return _msg;
}

// .identity.WalletLoginRequest walletLoginRequest = 2;
inline bool LoginRequest::_internal_has_walletloginrequest() const {
  return data_case() == kWalletLoginRequest;
}
inline bool LoginRequest::has_walletloginrequest() const {
  return _internal_has_walletloginrequest();
}
inline void LoginRequest::set_has_walletloginrequest() {
  _impl_._oneof_case_[0] = kWalletLoginRequest;
}
inline void LoginRequest::clear_walletloginrequest() {
  if (_internal_has_walletloginrequest()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.walletloginrequest_;
    }
    clear_has_data();
  }
}
inline ::identity::WalletLoginRequest* LoginRequest::release_walletloginrequest() {
  // @@protoc_insertion_point(field_release:identity.LoginRequest.walletLoginRequest)
  if (_internal_has_walletloginrequest()) {
    clear_has_data();
    ::identity::WalletLoginRequest* temp = _impl_.data_.walletloginrequest_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.walletloginrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::identity::WalletLoginRequest& LoginRequest::_internal_walletloginrequest() const {
  return _internal_has_walletloginrequest()
      ? *_impl_.data_.walletloginrequest_
      : reinterpret_cast< ::identity::WalletLoginRequest&>(::identity::_WalletLoginRequest_default_instance_);
}
inline const ::identity::WalletLoginRequest& LoginRequest::walletloginrequest() const {
  // @@protoc_insertion_point(field_get:identity.LoginRequest.walletLoginRequest)
  return _internal_walletloginrequest();
}
inline ::identity::WalletLoginRequest* LoginRequest::unsafe_arena_release_walletloginrequest() {
  // @@protoc_insertion_point(field_unsafe_arena_release:identity.LoginRequest.walletLoginRequest)
  if (_internal_has_walletloginrequest()) {
    clear_has_data();
    ::identity::WalletLoginRequest* temp = _impl_.data_.walletloginrequest_;
    _impl_.data_.walletloginrequest_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginRequest::unsafe_arena_set_allocated_walletloginrequest(::identity::WalletLoginRequest* walletloginrequest) {
  clear_data();
  if (walletloginrequest) {
    set_has_walletloginrequest();
    _impl_.data_.walletloginrequest_ = walletloginrequest;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:identity.LoginRequest.walletLoginRequest)
}
inline ::identity::WalletLoginRequest* LoginRequest::_internal_mutable_walletloginrequest() {
  if (!_internal_has_walletloginrequest()) {
    clear_data();
    set_has_walletloginrequest();
    _impl_.data_.walletloginrequest_ = CreateMaybeMessage< ::identity::WalletLoginRequest >(GetArenaForAllocation());
  }
  return _impl_.data_.walletloginrequest_;
}
inline ::identity::WalletLoginRequest* LoginRequest::mutable_walletloginrequest() {
  ::identity::WalletLoginRequest* _msg = _internal_mutable_walletloginrequest();
  // @@protoc_insertion_point(field_mutable:identity.LoginRequest.walletLoginRequest)
  return _msg;
}

inline bool LoginRequest::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void LoginRequest::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline LoginRequest::DataCase LoginRequest::data_case() const {
  return LoginRequest::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// LoginResponse

// .identity.PakeLoginResponse pakeLoginResponse = 1;
inline bool LoginResponse::_internal_has_pakeloginresponse() const {
  return data_case() == kPakeLoginResponse;
}
inline bool LoginResponse::has_pakeloginresponse() const {
  return _internal_has_pakeloginresponse();
}
inline void LoginResponse::set_has_pakeloginresponse() {
  _impl_._oneof_case_[0] = kPakeLoginResponse;
}
inline void LoginResponse::clear_pakeloginresponse() {
  if (_internal_has_pakeloginresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.pakeloginresponse_;
    }
    clear_has_data();
  }
}
inline ::identity::PakeLoginResponse* LoginResponse::release_pakeloginresponse() {
  // @@protoc_insertion_point(field_release:identity.LoginResponse.pakeLoginResponse)
  if (_internal_has_pakeloginresponse()) {
    clear_has_data();
    ::identity::PakeLoginResponse* temp = _impl_.data_.pakeloginresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.pakeloginresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::identity::PakeLoginResponse& LoginResponse::_internal_pakeloginresponse() const {
  return _internal_has_pakeloginresponse()
      ? *_impl_.data_.pakeloginresponse_
      : reinterpret_cast< ::identity::PakeLoginResponse&>(::identity::_PakeLoginResponse_default_instance_);
}
inline const ::identity::PakeLoginResponse& LoginResponse::pakeloginresponse() const {
  // @@protoc_insertion_point(field_get:identity.LoginResponse.pakeLoginResponse)
  return _internal_pakeloginresponse();
}
inline ::identity::PakeLoginResponse* LoginResponse::unsafe_arena_release_pakeloginresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:identity.LoginResponse.pakeLoginResponse)
  if (_internal_has_pakeloginresponse()) {
    clear_has_data();
    ::identity::PakeLoginResponse* temp = _impl_.data_.pakeloginresponse_;
    _impl_.data_.pakeloginresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponse::unsafe_arena_set_allocated_pakeloginresponse(::identity::PakeLoginResponse* pakeloginresponse) {
  clear_data();
  if (pakeloginresponse) {
    set_has_pakeloginresponse();
    _impl_.data_.pakeloginresponse_ = pakeloginresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:identity.LoginResponse.pakeLoginResponse)
}
inline ::identity::PakeLoginResponse* LoginResponse::_internal_mutable_pakeloginresponse() {
  if (!_internal_has_pakeloginresponse()) {
    clear_data();
    set_has_pakeloginresponse();
    _impl_.data_.pakeloginresponse_ = CreateMaybeMessage< ::identity::PakeLoginResponse >(GetArenaForAllocation());
  }
  return _impl_.data_.pakeloginresponse_;
}
inline ::identity::PakeLoginResponse* LoginResponse::mutable_pakeloginresponse() {
  ::identity::PakeLoginResponse* _msg = _internal_mutable_pakeloginresponse();
  // @@protoc_insertion_point(field_mutable:identity.LoginResponse.pakeLoginResponse)
  return _msg;
}

// .identity.WalletLoginResponse walletLoginResponse = 2;
inline bool LoginResponse::_internal_has_walletloginresponse() const {
  return data_case() == kWalletLoginResponse;
}
inline bool LoginResponse::has_walletloginresponse() const {
  return _internal_has_walletloginresponse();
}
inline void LoginResponse::set_has_walletloginresponse() {
  _impl_._oneof_case_[0] = kWalletLoginResponse;
}
inline void LoginResponse::clear_walletloginresponse() {
  if (_internal_has_walletloginresponse()) {
    if (GetArenaForAllocation() == nullptr) {
      delete _impl_.data_.walletloginresponse_;
    }
    clear_has_data();
  }
}
inline ::identity::WalletLoginResponse* LoginResponse::release_walletloginresponse() {
  // @@protoc_insertion_point(field_release:identity.LoginResponse.walletLoginResponse)
  if (_internal_has_walletloginresponse()) {
    clear_has_data();
    ::identity::WalletLoginResponse* temp = _impl_.data_.walletloginresponse_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.data_.walletloginresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::identity::WalletLoginResponse& LoginResponse::_internal_walletloginresponse() const {
  return _internal_has_walletloginresponse()
      ? *_impl_.data_.walletloginresponse_
      : reinterpret_cast< ::identity::WalletLoginResponse&>(::identity::_WalletLoginResponse_default_instance_);
}
inline const ::identity::WalletLoginResponse& LoginResponse::walletloginresponse() const {
  // @@protoc_insertion_point(field_get:identity.LoginResponse.walletLoginResponse)
  return _internal_walletloginresponse();
}
inline ::identity::WalletLoginResponse* LoginResponse::unsafe_arena_release_walletloginresponse() {
  // @@protoc_insertion_point(field_unsafe_arena_release:identity.LoginResponse.walletLoginResponse)
  if (_internal_has_walletloginresponse()) {
    clear_has_data();
    ::identity::WalletLoginResponse* temp = _impl_.data_.walletloginresponse_;
    _impl_.data_.walletloginresponse_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void LoginResponse::unsafe_arena_set_allocated_walletloginresponse(::identity::WalletLoginResponse* walletloginresponse) {
  clear_data();
  if (walletloginresponse) {
    set_has_walletloginresponse();
    _impl_.data_.walletloginresponse_ = walletloginresponse;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:identity.LoginResponse.walletLoginResponse)
}
inline ::identity::WalletLoginResponse* LoginResponse::_internal_mutable_walletloginresponse() {
  if (!_internal_has_walletloginresponse()) {
    clear_data();
    set_has_walletloginresponse();
    _impl_.data_.walletloginresponse_ = CreateMaybeMessage< ::identity::WalletLoginResponse >(GetArenaForAllocation());
  }
  return _impl_.data_.walletloginresponse_;
}
inline ::identity::WalletLoginResponse* LoginResponse::mutable_walletloginresponse() {
  ::identity::WalletLoginResponse* _msg = _internal_mutable_walletloginresponse();
  // @@protoc_insertion_point(field_mutable:identity.LoginResponse.walletLoginResponse)
  return _msg;
}

inline bool LoginResponse::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void LoginResponse::clear_has_data() {
  _impl_._oneof_case_[0] = DATA_NOT_SET;
}
inline LoginResponse::DataCase LoginResponse::data_case() const {
  return LoginResponse::DataCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// VerifyUserTokenRequest

// string userID = 1;
inline void VerifyUserTokenRequest::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& VerifyUserTokenRequest::userid() const {
  // @@protoc_insertion_point(field_get:identity.VerifyUserTokenRequest.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyUserTokenRequest::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.VerifyUserTokenRequest.userID)
}
inline std::string* VerifyUserTokenRequest::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:identity.VerifyUserTokenRequest.userID)
  return _s;
}
inline const std::string& VerifyUserTokenRequest::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void VerifyUserTokenRequest::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyUserTokenRequest::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyUserTokenRequest::release_userid() {
  // @@protoc_insertion_point(field_release:identity.VerifyUserTokenRequest.userID)
  return _impl_.userid_.Release();
}
inline void VerifyUserTokenRequest::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.VerifyUserTokenRequest.userID)
}

// string deviceID = 2;
inline void VerifyUserTokenRequest::clear_deviceid() {
  _impl_.deviceid_.ClearToEmpty();
}
inline const std::string& VerifyUserTokenRequest::deviceid() const {
  // @@protoc_insertion_point(field_get:identity.VerifyUserTokenRequest.deviceID)
  return _internal_deviceid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyUserTokenRequest::set_deviceid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.deviceid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.VerifyUserTokenRequest.deviceID)
}
inline std::string* VerifyUserTokenRequest::mutable_deviceid() {
  std::string* _s = _internal_mutable_deviceid();
  // @@protoc_insertion_point(field_mutable:identity.VerifyUserTokenRequest.deviceID)
  return _s;
}
inline const std::string& VerifyUserTokenRequest::_internal_deviceid() const {
  return _impl_.deviceid_.Get();
}
inline void VerifyUserTokenRequest::_internal_set_deviceid(const std::string& value) {
  
  _impl_.deviceid_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyUserTokenRequest::_internal_mutable_deviceid() {
  
  return _impl_.deviceid_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyUserTokenRequest::release_deviceid() {
  // @@protoc_insertion_point(field_release:identity.VerifyUserTokenRequest.deviceID)
  return _impl_.deviceid_.Release();
}
inline void VerifyUserTokenRequest::set_allocated_deviceid(std::string* deviceid) {
  if (deviceid != nullptr) {
    
  } else {
    
  }
  _impl_.deviceid_.SetAllocated(deviceid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.deviceid_.IsDefault()) {
    _impl_.deviceid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.VerifyUserTokenRequest.deviceID)
}

// string accessToken = 3;
inline void VerifyUserTokenRequest::clear_accesstoken() {
  _impl_.accesstoken_.ClearToEmpty();
}
inline const std::string& VerifyUserTokenRequest::accesstoken() const {
  // @@protoc_insertion_point(field_get:identity.VerifyUserTokenRequest.accessToken)
  return _internal_accesstoken();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VerifyUserTokenRequest::set_accesstoken(ArgT0&& arg0, ArgT... args) {
 
 _impl_.accesstoken_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.VerifyUserTokenRequest.accessToken)
}
inline std::string* VerifyUserTokenRequest::mutable_accesstoken() {
  std::string* _s = _internal_mutable_accesstoken();
  // @@protoc_insertion_point(field_mutable:identity.VerifyUserTokenRequest.accessToken)
  return _s;
}
inline const std::string& VerifyUserTokenRequest::_internal_accesstoken() const {
  return _impl_.accesstoken_.Get();
}
inline void VerifyUserTokenRequest::_internal_set_accesstoken(const std::string& value) {
  
  _impl_.accesstoken_.Set(value, GetArenaForAllocation());
}
inline std::string* VerifyUserTokenRequest::_internal_mutable_accesstoken() {
  
  return _impl_.accesstoken_.Mutable(GetArenaForAllocation());
}
inline std::string* VerifyUserTokenRequest::release_accesstoken() {
  // @@protoc_insertion_point(field_release:identity.VerifyUserTokenRequest.accessToken)
  return _impl_.accesstoken_.Release();
}
inline void VerifyUserTokenRequest::set_allocated_accesstoken(std::string* accesstoken) {
  if (accesstoken != nullptr) {
    
  } else {
    
  }
  _impl_.accesstoken_.SetAllocated(accesstoken, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.accesstoken_.IsDefault()) {
    _impl_.accesstoken_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.VerifyUserTokenRequest.accessToken)
}

// -------------------------------------------------------------------

// VerifyUserTokenResponse

// bool tokenValid = 1;
inline void VerifyUserTokenResponse::clear_tokenvalid() {
  _impl_.tokenvalid_ = false;
}
inline bool VerifyUserTokenResponse::_internal_tokenvalid() const {
  return _impl_.tokenvalid_;
}
inline bool VerifyUserTokenResponse::tokenvalid() const {
  // @@protoc_insertion_point(field_get:identity.VerifyUserTokenResponse.tokenValid)
  return _internal_tokenvalid();
}
inline void VerifyUserTokenResponse::_internal_set_tokenvalid(bool value) {
  
  _impl_.tokenvalid_ = value;
}
inline void VerifyUserTokenResponse::set_tokenvalid(bool value) {
  _internal_set_tokenvalid(value);
  // @@protoc_insertion_point(field_set:identity.VerifyUserTokenResponse.tokenValid)
}

// -------------------------------------------------------------------

// GetUserIDRequest

// .identity.GetUserIDRequest.AuthType authType = 1;
inline void GetUserIDRequest::clear_authtype() {
  _impl_.authtype_ = 0;
}
inline ::identity::GetUserIDRequest_AuthType GetUserIDRequest::_internal_authtype() const {
  return static_cast< ::identity::GetUserIDRequest_AuthType >(_impl_.authtype_);
}
inline ::identity::GetUserIDRequest_AuthType GetUserIDRequest::authtype() const {
  // @@protoc_insertion_point(field_get:identity.GetUserIDRequest.authType)
  return _internal_authtype();
}
inline void GetUserIDRequest::_internal_set_authtype(::identity::GetUserIDRequest_AuthType value) {
  
  _impl_.authtype_ = value;
}
inline void GetUserIDRequest::set_authtype(::identity::GetUserIDRequest_AuthType value) {
  _internal_set_authtype(value);
  // @@protoc_insertion_point(field_set:identity.GetUserIDRequest.authType)
}

// string userInfo = 2;
inline void GetUserIDRequest::clear_userinfo() {
  _impl_.userinfo_.ClearToEmpty();
}
inline const std::string& GetUserIDRequest::userinfo() const {
  // @@protoc_insertion_point(field_get:identity.GetUserIDRequest.userInfo)
  return _internal_userinfo();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserIDRequest::set_userinfo(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userinfo_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.GetUserIDRequest.userInfo)
}
inline std::string* GetUserIDRequest::mutable_userinfo() {
  std::string* _s = _internal_mutable_userinfo();
  // @@protoc_insertion_point(field_mutable:identity.GetUserIDRequest.userInfo)
  return _s;
}
inline const std::string& GetUserIDRequest::_internal_userinfo() const {
  return _impl_.userinfo_.Get();
}
inline void GetUserIDRequest::_internal_set_userinfo(const std::string& value) {
  
  _impl_.userinfo_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserIDRequest::_internal_mutable_userinfo() {
  
  return _impl_.userinfo_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserIDRequest::release_userinfo() {
  // @@protoc_insertion_point(field_release:identity.GetUserIDRequest.userInfo)
  return _impl_.userinfo_.Release();
}
inline void GetUserIDRequest::set_allocated_userinfo(std::string* userinfo) {
  if (userinfo != nullptr) {
    
  } else {
    
  }
  _impl_.userinfo_.SetAllocated(userinfo, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userinfo_.IsDefault()) {
    _impl_.userinfo_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.GetUserIDRequest.userInfo)
}

// -------------------------------------------------------------------

// GetUserIDResponse

// string userID = 1;
inline void GetUserIDResponse::clear_userid() {
  _impl_.userid_.ClearToEmpty();
}
inline const std::string& GetUserIDResponse::userid() const {
  // @@protoc_insertion_point(field_get:identity.GetUserIDResponse.userID)
  return _internal_userid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetUserIDResponse::set_userid(ArgT0&& arg0, ArgT... args) {
 
 _impl_.userid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:identity.GetUserIDResponse.userID)
}
inline std::string* GetUserIDResponse::mutable_userid() {
  std::string* _s = _internal_mutable_userid();
  // @@protoc_insertion_point(field_mutable:identity.GetUserIDResponse.userID)
  return _s;
}
inline const std::string& GetUserIDResponse::_internal_userid() const {
  return _impl_.userid_.Get();
}
inline void GetUserIDResponse::_internal_set_userid(const std::string& value) {
  
  _impl_.userid_.Set(value, GetArenaForAllocation());
}
inline std::string* GetUserIDResponse::_internal_mutable_userid() {
  
  return _impl_.userid_.Mutable(GetArenaForAllocation());
}
inline std::string* GetUserIDResponse::release_userid() {
  // @@protoc_insertion_point(field_release:identity.GetUserIDResponse.userID)
  return _impl_.userid_.Release();
}
inline void GetUserIDResponse::set_allocated_userid(std::string* userid) {
  if (userid != nullptr) {
    
  } else {
    
  }
  _impl_.userid_.SetAllocated(userid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.userid_.IsDefault()) {
    _impl_.userid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:identity.GetUserIDResponse.userID)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace identity

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::identity::GetUserIDRequest_AuthType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::identity::GetUserIDRequest_AuthType>() {
  return ::identity::GetUserIDRequest_AuthType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_identity_2eproto
