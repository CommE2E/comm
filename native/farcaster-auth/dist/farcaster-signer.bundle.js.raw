/*! For license information please see farcaster-signer.bundle.js.raw.LICENSE.txt */
(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{OG:()=>be,My:()=>ue,Ph:()=>le,lX:()=>de,Id:()=>we,fg:()=>Ee,qj:()=>ye,aT:()=>he,lq:()=>pe,z:()=>ge,Q5:()=>Be});var r={};function n(e,t,r,n,i,o,s){try{var a=e[o](s),c=a.value}catch(e){return void r(e)}a.done?t(c):Promise.resolve(c).then(n,i)}function i(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function o(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function s(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");i(e.outputLen),i(e.blockLen)}function a(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function c(e,t){o(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}e.r(r),e.d(r,{OG:()=>vr,My:()=>dr,Ph:()=>yr,lX:()=>wr,Id:()=>Er,fg:()=>Ar,qj:()=>xr,aT:()=>gr,lq:()=>br,z:()=>mr,Q5:()=>Pr});const u="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,f=e=>e instanceof Uint8Array,h=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),l=(e,t)=>e<<32-t|e>>>t;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");const d=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function p(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function g(e){if("string"==typeof e&&(e=p(e)),!f(e))throw new Error("expected Uint8Array, got "+typeof e);return e}function y(...e){const t=new Uint8Array(e.reduce(((e,t)=>e+t.length),0));let r=0;return e.forEach((e=>{if(!f(e))throw new Error("Uint8Array expected");t.set(e,r),r+=e.length})),t}class w{clone(){return this._cloneInto()}}const b={}.toString;function m(e){const t=t=>e().update(g(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function x(e=32){if(u&&"function"==typeof u.getRandomValues)return u.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}class E extends w{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,s(e);const r=g(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<i.length;e++)i[e]^=54;this.iHash.update(i),this.oHash=e.create();for(let e=0;e<i.length;e++)i[e]^=106;this.oHash.update(i),i.fill(0)}update(e){return a(this),this.iHash.update(e),this}digestInto(e){a(this),o(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:i,blockLen:o,outputLen:s}=this;return e.finished=n,e.destroyed=i,e.blockLen=o,e.outputLen=s,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const v=(e,t,r)=>new E(e,t).update(r).digest();v.create=(e,t)=>new E(e,t);class B extends w{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=h(this.buffer)}update(e){a(this);const{view:t,buffer:r,blockLen:n}=this,i=(e=g(e)).length;for(let o=0;o<i;){const s=Math.min(n-this.pos,i-o);if(s!==n)r.set(e.subarray(o,o+s),this.pos),this.pos+=s,o+=s,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=h(e);for(;n<=i-o;o+=n)this.process(t,o)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){a(this),c(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:i}=this;let{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>n-o&&(this.process(r,0),o=0);for(let e=o;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),a=Number(r&o),c=n?4:0,u=n?0:4;e.setUint32(t+c,s,n),e.setUint32(t+u,a,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const s=h(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const f=u/4,l=this.get();if(f>l.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<f;e++)s.setUint32(4*e,l[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return e.length=n,e.pos=s,e.finished=i,e.destroyed=o,n%t&&e.buffer.set(r),e}}const I=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),A=Uint8Array.from({length:16},((e,t)=>t));let S=[A],P=[A.map((e=>(9*e+5)%16))];for(let e=0;e<4;e++)for(let t of[S,P])t.push(t[e].map((e=>I[e])));const O=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((e=>new Uint8Array(e))),$=S.map(((e,t)=>e.map((e=>O[t][e])))),z=P.map(((e,t)=>e.map((e=>O[t][e])))),U=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),L=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),R=(e,t)=>e<<t|e>>>32-t;function N(e,t,r,n){return 0===e?t^r^n:1===e?t&r|~t&n:2===e?(t|~r)^n:3===e?t&n|r&~n:t^(r|~n)}const F=new Uint32Array(16);class T extends B{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:e,h1:t,h2:r,h3:n,h4:i}=this;return[e,t,r,n,i]}set(e,t,r,n,i){this.h0=0|e,this.h1=0|t,this.h2=0|r,this.h3=0|n,this.h4=0|i}process(e,t){for(let r=0;r<16;r++,t+=4)F[r]=e.getUint32(t,!0);let r=0|this.h0,n=r,i=0|this.h1,o=i,s=0|this.h2,a=s,c=0|this.h3,u=c,f=0|this.h4,h=f;for(let e=0;e<5;e++){const t=4-e,l=U[e],d=L[e],p=S[e],g=P[e],y=$[e],w=z[e];for(let t=0;t<16;t++){const n=R(r+N(e,i,s,c)+F[p[t]]+l,y[t])+f|0;r=f,f=c,c=0|R(s,10),s=i,i=n}for(let e=0;e<16;e++){const r=R(n+N(t,o,a,u)+F[g[e]]+d,w[e])+h|0;n=h,h=u,u=0|R(a,10),a=o,o=r}}this.set(this.h1+s+u|0,this.h2+c+h|0,this.h3+f+n|0,this.h4+r+o|0,this.h0+i+a|0)}roundClean(){F.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const K=m((()=>new T)),H=(e,t,r)=>e&t^e&r^t&r,C=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),j=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),k=new Uint32Array(64);class q extends B{constructor(){super(64,32,8,!1),this.A=0|j[0],this.B=0|j[1],this.C=0|j[2],this.D=0|j[3],this.E=0|j[4],this.F=0|j[5],this.G=0|j[6],this.H=0|j[7]}get(){const{A:e,B:t,C:r,D:n,E:i,F:o,G:s,H:a}=this;return[e,t,r,n,i,o,s,a]}set(e,t,r,n,i,o,s,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)k[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=k[e-15],r=k[e-2],n=l(t,7)^l(t,18)^t>>>3,i=l(r,17)^l(r,19)^r>>>10;k[e]=i+k[e-7]+n+k[e-16]|0}let{A:r,B:n,C:i,D:o,E:s,F:a,G:c,H:u}=this;for(let e=0;e<64;e++){const t=u+(l(s,6)^l(s,11)^l(s,25))+((f=s)&a^~f&c)+C[e]+k[e]|0,h=(l(r,2)^l(r,13)^l(r,22))+H(r,n,i)|0;u=c,c=a,a=s,s=o+t|0,o=i,i=n,n=r,r=t+h|0}var f;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,o=o+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(r,n,i,o,s,a,c,u)}roundClean(){k.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const M=m((()=>new q)),V=BigInt(2**32-1),D=BigInt(32);function G(e,t=!1){return t?{h:Number(e&V),l:Number(e>>D&V)}:{h:0|Number(e>>D&V),l:0|Number(e&V)}}function Z(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let i=0;i<e.length;i++){const{h:o,l:s}=G(e[i],t);[r[i],n[i]]=[o,s]}return[r,n]}const _=(e,t,r)=>e<<r|t>>>32-r,W=(e,t,r)=>t<<r|e>>>32-r,Y=(e,t,r)=>t<<r-32|e>>>64-r,X=(e,t,r)=>e<<r-32|t>>>64-r;const J={fromBig:G,split:Z,toBig:(e,t)=>BigInt(e>>>0)<<D|BigInt(t>>>0),shrSH:(e,t,r)=>e>>>r,shrSL:(e,t,r)=>e<<32-r|t>>>r,rotrSH:(e,t,r)=>e>>>r|t<<32-r,rotrSL:(e,t,r)=>e<<32-r|t>>>r,rotrBH:(e,t,r)=>e<<64-r|t>>>r-32,rotrBL:(e,t,r)=>e>>>r-32|t<<64-r,rotr32H:(e,t)=>t,rotr32L:(e,t)=>e,rotlSH:_,rotlSL:W,rotlBH:Y,rotlBL:X,add:function(e,t,r,n){const i=(t>>>0)+(n>>>0);return{h:e+r+(i/2**32|0)|0,l:0|i}},add3L:(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),add3H:(e,t,r,n)=>t+r+n+(e/2**32|0)|0,add4L:(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),add4H:(e,t,r,n,i)=>t+r+n+i+(e/2**32|0)|0,add5H:(e,t,r,n,i,o)=>t+r+n+i+o+(e/2**32|0)|0,add5L:(e,t,r,n,i)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(i>>>0)},[Q,ee]=(()=>J.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),te=new Uint32Array(80),re=new Uint32Array(80);class ne extends B{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:i,Cl:o,Dh:s,Dl:a,Eh:c,El:u,Fh:f,Fl:h,Gh:l,Gl:d,Hh:p,Hl:g}=this;return[e,t,r,n,i,o,s,a,c,u,f,h,l,d,p,g]}set(e,t,r,n,i,o,s,a,c,u,f,h,l,d,p,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|o,this.Dh=0|s,this.Dl=0|a,this.Eh=0|c,this.El=0|u,this.Fh=0|f,this.Fl=0|h,this.Gh=0|l,this.Gl=0|d,this.Hh=0|p,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)te[r]=e.getUint32(t),re[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|te[e-15],r=0|re[e-15],n=J.rotrSH(t,r,1)^J.rotrSH(t,r,8)^J.shrSH(t,r,7),i=J.rotrSL(t,r,1)^J.rotrSL(t,r,8)^J.shrSL(t,r,7),o=0|te[e-2],s=0|re[e-2],a=J.rotrSH(o,s,19)^J.rotrBH(o,s,61)^J.shrSH(o,s,6),c=J.rotrSL(o,s,19)^J.rotrBL(o,s,61)^J.shrSL(o,s,6),u=J.add4L(i,c,re[e-7],re[e-16]),f=J.add4H(u,n,a,te[e-7],te[e-16]);te[e]=0|f,re[e]=0|u}let{Ah:r,Al:n,Bh:i,Bl:o,Ch:s,Cl:a,Dh:c,Dl:u,Eh:f,El:h,Fh:l,Fl:d,Gh:p,Gl:g,Hh:y,Hl:w}=this;for(let e=0;e<80;e++){const t=J.rotrSH(f,h,14)^J.rotrSH(f,h,18)^J.rotrBH(f,h,41),b=J.rotrSL(f,h,14)^J.rotrSL(f,h,18)^J.rotrBL(f,h,41),m=f&l^~f&p,x=h&d^~h&g,E=J.add5L(w,b,x,ee[e],re[e]),v=J.add5H(E,y,t,m,Q[e],te[e]),B=0|E,I=J.rotrSH(r,n,28)^J.rotrBH(r,n,34)^J.rotrBH(r,n,39),A=J.rotrSL(r,n,28)^J.rotrBL(r,n,34)^J.rotrBL(r,n,39),S=r&i^r&s^i&s,P=n&o^n&a^o&a;y=0|p,w=0|g,p=0|l,g=0|d,l=0|f,d=0|h,({h:f,l:h}=J.add(0|c,0|u,0|v,0|B)),c=0|s,u=0|a,s=0|i,a=0|o,i=0|r,o=0|n;const O=J.add3L(B,A,P);r=J.add3H(O,v,I,S),n=0|O}({h:r,l:n}=J.add(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:o}=J.add(0|this.Bh,0|this.Bl,0|i,0|o)),({h:s,l:a}=J.add(0|this.Ch,0|this.Cl,0|s,0|a)),({h:c,l:u}=J.add(0|this.Dh,0|this.Dl,0|c,0|u)),({h:f,l:h}=J.add(0|this.Eh,0|this.El,0|f,0|h)),({h:l,l:d}=J.add(0|this.Fh,0|this.Fl,0|l,0|d)),({h:p,l:g}=J.add(0|this.Gh,0|this.Gl,0|p,0|g)),({h:y,l:w}=J.add(0|this.Hh,0|this.Hl,0|y,0|w)),this.set(r,n,i,o,s,a,c,u,f,h,l,d,p,g,y,w)}roundClean(){te.fill(0),re.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ie=m((()=>new ne)),oe=(BigInt(0),BigInt(1)),se=BigInt(2),ae=e=>e instanceof Uint8Array,ce=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function ue(e){if(!ae(e))throw new Error("Uint8Array expected");let t="";for(let r=0;r<e.length;r++)t+=ce[e[r]];return t}function fe(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}function he(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let t=0;t<r.length;t++){const n=2*t,i=e.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[t]=o}return r}function le(e){return fe(ue(e))}function de(e){if(!ae(e))throw new Error("Uint8Array expected");return fe(ue(Uint8Array.from(e).reverse()))}function pe(e,t){return he(e.toString(16).padStart(2*t,"0"))}function ge(e,t){return pe(e,t).reverse()}function ye(e,t,r){let n;if("string"==typeof t)try{n=he(t)}catch(r){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${r}`)}else{if(!ae(t))throw new Error(`${e} must be hex string or Uint8Array`);n=Uint8Array.from(t)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(`${e} expected ${r} bytes, got ${i}`);return n}function we(...e){const t=new Uint8Array(e.reduce(((e,t)=>e+t.length),0));let r=0;return e.forEach((e=>{if(!ae(e))throw new Error("Uint8Array expected");t.set(e,r),r+=e.length})),t}const be=e=>(se<<BigInt(e-1))-oe,me=e=>new Uint8Array(e),xe=e=>Uint8Array.from(e);function Ee(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=me(e),i=me(e),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},a=(...e)=>r(i,n,...e),c=(e=me())=>{i=a(xe([0]),e),n=a(),0!==e.length&&(i=a(xe([1]),e),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){n=a();const t=n.slice();r.push(t),e+=n.length}return we(...r)};return(e,t)=>{let r;for(s(),c(e);!(r=t(u()));)c();return s(),r}}const ve={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||e instanceof Uint8Array,isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function Be(e,t,r={}){const n=(t,r,n)=>{const i=ve[r];if("function"!=typeof i)throw new Error(`Invalid validator "${r}", expected function`);const o=e[t];if(!(n&&void 0===o||i(o,e)))throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${r}`)};for(const[e,r]of Object.entries(t))n(e,r,!1);for(const[e,t]of Object.entries(r))n(e,t,!0);return e}const Ie=BigInt(0),Ae=BigInt(1),Se=BigInt(2),Pe=BigInt(3),Oe=BigInt(4),$e=BigInt(5),ze=BigInt(8);BigInt(9),BigInt(16);function Ue(e,t){const r=e%t;return r>=Ie?r:t+r}function Le(e,t,r){if(r<=Ie||t<Ie)throw new Error("Expected power/modulo > 0");if(r===Ae)return Ie;let n=Ae;for(;t>Ie;)t&Ae&&(n=n*e%r),e=e*e%r,t>>=Ae;return n}function Re(e,t,r){let n=e;for(;t-- >Ie;)n*=n,n%=r;return n}function Ne(e,t){if(e===Ie||t<=Ie)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=Ue(e,t),n=t,i=Ie,o=Ae,s=Ae,a=Ie;for(;r!==Ie;){const e=n/r,t=n%r,c=i-s*e,u=o-a*e;n=r,r=t,i=s,o=a,s=c,a=u}if(n!==Ae)throw new Error("invert: does not exist");return Ue(i,t)}function Fe(e){if(e%Oe===Pe){const t=(e+Ae)/Oe;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}if(e%ze===$e){const t=(e-$e)/ze;return function(e,r){const n=e.mul(r,Se),i=e.pow(n,t),o=e.mul(r,i),s=e.mul(e.mul(o,Se),i),a=e.mul(o,e.sub(s,e.ONE));if(!e.eql(e.sqr(a),r))throw new Error("Cannot find square root");return a}}return function(e){const t=(e-Ae)/Se;let r,n,i;for(r=e-Ae,n=0;r%Se===Ie;r/=Se,n++);for(i=Se;i<e&&Le(i,t,e)!==e-Ae;i++);if(1===n){const t=(e+Ae)/Oe;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}const o=(r+Ae)/Se;return function(e,s){if(e.pow(s,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let a=n,c=e.pow(e.mul(e.ONE,i),r),u=e.pow(s,o),f=e.pow(s,r);for(;!e.eql(f,e.ONE);){if(e.eql(f,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(f);t<a&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const r=e.pow(c,Ae<<BigInt(a-t-1));c=e.sqr(r),u=e.mul(u,r),f=e.mul(f,c),a=t}return u}}(e)}const Te=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Ke(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function He(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Ce(e){const t=He(e);return t+Math.ceil(t/2)}const je=BigInt(0),ke=BigInt(1);function qe(e){return Be(e.Fp,Te.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),Be(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Ke(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const{Ph:Me,aT:Ve}=t,De={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=De;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const r=e[1],n=e.subarray(2,r+2);if(!r||n.length!==r)throw new t("Invalid signature integer: wrong length");if(128&n[0])throw new t("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Me(n),l:e.subarray(r+2)}},toSig(e){const{Err:t}=De,r="string"==typeof e?Ve(e):e;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new t("Invalid signature tag");if(r[1]!==n-2)throw new t("Invalid signature: incorrect length");const{d:i,l:o}=De._parseInt(r.subarray(2)),{d:s,l:a}=De._parseInt(o);if(a.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(e){const t=e=>8&Number.parseInt(e[0],16)?"00"+e:e,r=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},n=t(r(e.s)),i=t(r(e.r)),o=n.length/2,s=i.length/2,a=r(o),c=r(s);return`30${r(s+o+4)}02${c}${i}02${a}${n}`}},Ge=BigInt(0),Ze=BigInt(1),_e=(BigInt(2),BigInt(3));BigInt(4);function We(e){const t=function(e){const t=qe(e);Be(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=t;if(r){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:r}=t,n=t.toBytes||((e,t,n)=>{const i=t.toAffine();return we(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),i=t.fromBytes||(e=>{const t=e.subarray(1);return{x:r.fromBytes(t.subarray(0,r.BYTES)),y:r.fromBytes(t.subarray(r.BYTES,2*r.BYTES))}});function o(e){const{a:n,b:i}=t,o=r.sqr(e),s=r.mul(o,e);return r.add(r.add(s,r.mul(e,n)),i)}if(!r.eql(r.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function s(e){return"bigint"==typeof e&&Ge<e&&e<t.n}function a(e){if(!s(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(e){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=t;if(r&&"bigint"!=typeof e){if(e instanceof Uint8Array&&(e=ue(e)),"string"!=typeof e||!r.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*n,"0")}let s;try{s="bigint"==typeof e?e:le(ye("private key",e,n))}catch(t){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof e}`)}return i&&(s=Ue(s,o)),a(s),s}const u=new Map;function f(e){if(!(e instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(e,t,n){if(this.px=e,this.py=t,this.pz=n,null==e||!r.isValid(e))throw new Error("x required");if(null==t||!r.isValid(t))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!r.isValid(t)||!r.isValid(n))throw new Error("invalid affine point");if(e instanceof h)throw new Error("projective point not allowed");const i=e=>r.eql(e,r.ZERO);return i(t)&&i(n)?h.ZERO:new h(t,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(h.fromAffine)}static fromHex(e){const t=h.fromAffine(i(ye("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return h.BASE.multiply(c(e))}_setWindowSize(e){this._WINDOW_SIZE=e,u.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:n}=this.toAffine();if(!r.isValid(e)||!r.isValid(n))throw new Error("bad point: x or y not FE");const i=r.sqr(n),s=o(e);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(r.isOdd)return!r.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){f(e);const{px:t,py:n,pz:i}=this,{px:o,py:s,pz:a}=e,c=r.eql(r.mul(t,a),r.mul(o,i)),u=r.eql(r.mul(n,a),r.mul(s,i));return c&&u}negate(){return new h(this.px,r.neg(this.py),this.pz)}double(){const{a:e,b:n}=t,i=r.mul(n,_e),{px:o,py:s,pz:a}=this;let c=r.ZERO,u=r.ZERO,f=r.ZERO,l=r.mul(o,o),d=r.mul(s,s),p=r.mul(a,a),g=r.mul(o,s);return g=r.add(g,g),f=r.mul(o,a),f=r.add(f,f),c=r.mul(e,f),u=r.mul(i,p),u=r.add(c,u),c=r.sub(d,u),u=r.add(d,u),u=r.mul(c,u),c=r.mul(g,c),f=r.mul(i,f),p=r.mul(e,p),g=r.sub(l,p),g=r.mul(e,g),g=r.add(g,f),f=r.add(l,l),l=r.add(f,l),l=r.add(l,p),l=r.mul(l,g),u=r.add(u,l),p=r.mul(s,a),p=r.add(p,p),l=r.mul(p,g),c=r.sub(c,l),f=r.mul(p,d),f=r.add(f,f),f=r.add(f,f),new h(c,u,f)}add(e){f(e);const{px:n,py:i,pz:o}=this,{px:s,py:a,pz:c}=e;let u=r.ZERO,l=r.ZERO,d=r.ZERO;const p=t.a,g=r.mul(t.b,_e);let y=r.mul(n,s),w=r.mul(i,a),b=r.mul(o,c),m=r.add(n,i),x=r.add(s,a);m=r.mul(m,x),x=r.add(y,w),m=r.sub(m,x),x=r.add(n,o);let E=r.add(s,c);return x=r.mul(x,E),E=r.add(y,b),x=r.sub(x,E),E=r.add(i,o),u=r.add(a,c),E=r.mul(E,u),u=r.add(w,b),E=r.sub(E,u),d=r.mul(p,x),u=r.mul(g,b),d=r.add(u,d),u=r.sub(w,d),d=r.add(w,d),l=r.mul(u,d),w=r.add(y,y),w=r.add(w,y),b=r.mul(p,b),x=r.mul(g,x),w=r.add(w,b),b=r.sub(y,b),b=r.mul(p,b),x=r.add(x,b),y=r.mul(w,x),l=r.add(l,y),y=r.mul(E,x),u=r.mul(m,u),u=r.sub(u,y),y=r.mul(m,w),d=r.mul(E,d),d=r.add(d,y),new h(u,l,d)}subtract(e){return this.add(e.negate())}is0(){return this.equals(h.ZERO)}wNAF(e){return d.wNAFCached(this,u,e,(e=>{const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(h.fromAffine)}))}multiplyUnsafe(e){const n=h.ZERO;if(e===Ge)return n;if(a(e),e===Ze)return this;const{endo:i}=t;if(!i)return d.unsafeLadder(this,e);let{k1neg:o,k1:s,k2neg:c,k2:u}=i.splitScalar(e),f=n,l=n,p=this;for(;s>Ge||u>Ge;)s&Ze&&(f=f.add(p)),u&Ze&&(l=l.add(p)),p=p.double(),s>>=Ze,u>>=Ze;return o&&(f=f.negate()),c&&(l=l.negate()),l=new h(r.mul(l.px,i.beta),l.py,l.pz),f.add(l)}multiply(e){a(e);let n,i,o=e;const{endo:s}=t;if(s){const{k1neg:e,k1:t,k2neg:a,k2:c}=s.splitScalar(o);let{p:u,f}=this.wNAF(t),{p:l,f:p}=this.wNAF(c);u=d.constTimeNegate(e,u),l=d.constTimeNegate(a,l),l=new h(r.mul(l.px,s.beta),l.py,l.pz),n=u.add(l),i=f.add(p)}else{const{p:e,f:t}=this.wNAF(o);n=e,i=t}return h.normalizeZ([n,i])[0]}multiplyAndAddUnsafe(e,t,r){const n=h.BASE,i=(e,t)=>t!==Ge&&t!==Ze&&e.equals(n)?e.multiply(t):e.multiplyUnsafe(t),o=i(this,t).add(i(e,r));return o.is0()?void 0:o}toAffine(e){const{px:t,py:n,pz:i}=this,o=this.is0();null==e&&(e=o?r.ONE:r.inv(i));const s=r.mul(t,e),a=r.mul(n,e),c=r.mul(i,e);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:e,isTorsionFree:r}=t;if(e===Ze)return!0;if(r)return r(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:r}=t;return e===Ze?this:r?r(h,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),n(h,this,e)}toHex(e=!0){return ue(this.toRawBytes(e))}}h.BASE=new h(t.Gx,t.Gy,r.ONE),h.ZERO=new h(r.ZERO,r.ONE,r.ZERO);const l=t.nBitLength,d=function(e,t){const r=(e,t)=>{const r=t.negate();return e?r:t},n=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate:r,unsafeLadder(t,r){let n=e.ZERO,i=t;for(;r>je;)r&ke&&(n=n.add(i)),i=i.double(),r>>=ke;return n},precomputeWindow(e,t){const{windows:r,windowSize:i}=n(t),o=[];let s=e,a=s;for(let e=0;e<r;e++){a=s,o.push(a);for(let e=1;e<i;e++)a=a.add(s),o.push(a);s=a.double()}return o},wNAF(t,i,o){const{windows:s,windowSize:a}=n(t);let c=e.ZERO,u=e.BASE;const f=BigInt(2**t-1),h=2**t,l=BigInt(t);for(let e=0;e<s;e++){const t=e*a;let n=Number(o&f);o>>=l,n>a&&(n-=h,o+=ke);const s=t,d=t+Math.abs(n)-1,p=e%2!=0,g=n<0;0===n?u=u.add(r(p,i[s])):c=c.add(r(g,i[d]))}return{p:c,f:u}},wNAFCached(e,t,r,n){const i=e._WINDOW_SIZE||1;let o=t.get(e);return o||(o=this.precomputeWindow(e,i),1!==i&&t.set(e,n(o))),this.wNAF(i,o,r)}}}(h,t.endo?Math.ceil(l/2):l);return{CURVE:t,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:s}}function Ye(e){const t=function(e){const t=qe(e);return Be(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:r,n}=t,i=r.BYTES+1,o=2*r.BYTES+1;function s(e){return Ue(e,n)}function a(e){return Ne(e,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:f,isWithinCurveOrder:h}=We({...t,toBytes(e,t,n){const i=t.toAffine(),o=r.toBytes(i.x),s=we;return n?s(Uint8Array.from([t.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(e){const t=e.length,n=e[0],s=e.subarray(1);if(t!==i||2!==n&&3!==n){if(t===o&&4===n){return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}{const e=le(s);if(!(Ge<(a=e)&&a<r.ORDER))throw new Error("Point is not on curve");const t=f(e);let i=r.sqrt(t);return 1==(1&n)!==((i&Ze)===Ze)&&(i=r.neg(i)),{x:e,y:i}}var a}}),l=e=>ue(pe(e,t.nByteLength));function d(e){return e>n>>Ze}const p=(e,t,r)=>le(e.slice(t,r));class g{constructor(e,t,r){this.r=e,this.s=t,this.recovery=r,this.assertValidity()}static fromCompact(e){const r=t.nByteLength;return e=ye("compactSignature",e,2*r),new g(p(e,0,r),p(e,r,2*r))}static fromDER(e){const{r:t,s:r}=De.toSig(ye("DER",e));return new g(t,r)}assertValidity(){if(!h(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!h(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new g(this.r,this.s,e)}recoverPublicKey(e){const{r:n,s:i,recovery:o}=this,u=m(ye("msgHash",e));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const f=2===o||3===o?n+t.n:n;if(f>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=0==(1&o)?"02":"03",d=c.fromHex(h+l(f)),p=a(f),g=s(-u*p),y=s(i*p),w=c.BASE.multiplyAndAddUnsafe(d,g,y);if(!w)throw new Error("point at infinify");return w.assertValidity(),w}hasHighS(){return d(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return he(this.toDERHex())}toDERHex(){return De.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return he(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const y={isValidPrivateKey(e){try{return u(e),!0}catch(e){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const e=Ce(t.n);return function(e,t,r=!1){const n=e.length,i=He(t),o=Ce(t);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const s=Ue(r?le(e):de(e),t-Ae)+Ae;return r?ge(s,i):pe(s,i)}(t.randomBytes(e),t.n)},precompute:(e=8,t=c.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function w(e){const t=e instanceof Uint8Array,r="string"==typeof e,n=(t||r)&&e.length;return t?n===i||n===o:r?n===2*i||n===2*o:e instanceof c}const b=t.bits2int||function(e){const r=le(e),n=8*e.length-t.nBitLength;return n>0?r>>BigInt(n):r},m=t.bits2int_modN||function(e){return s(b(e))},x=be(t.nBitLength);function E(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(Ge<=e&&e<x))throw new Error(`bigint expected < 2^${t.nBitLength}`);return pe(e,t.nByteLength)}function v(e,n,i=B){if(["recovered","canonical"].some((e=>e in i)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:f}=t;let{lowS:l,prehash:p,extraEntropy:y}=i;null==l&&(l=!0),e=ye("msgHash",e),p&&(e=ye("prehashed msgHash",o(e)));const w=m(e),x=u(n),v=[E(x),E(w)];if(null!=y){const e=!0===y?f(r.BYTES):y;v.push(ye("extraEntropy",e))}const I=we(...v),A=w;return{seed:I,k2sig:function(e){const t=b(e);if(!h(t))return;const r=a(t),n=c.BASE.multiply(t).toAffine(),i=s(n.x);if(i===Ge)return;const o=s(r*s(A+i*x));if(o===Ge)return;let u=(n.x===i?0:2)|Number(n.y&Ze),f=o;return l&&d(o)&&(f=function(e){return d(e)?s(-e):e}(o),u^=1),new g(i,f,u)}}}const B={lowS:t.lowS,prehash:!1},I={lowS:t.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return c.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,r=!0){if(w(e))throw new Error("first arg must be private key");if(!w(t))throw new Error("second arg must be public key");return c.fromHex(t).multiply(u(e)).toRawBytes(r)},sign:function(e,r,n=B){const{seed:i,k2sig:o}=v(e,r,n),s=t;return Ee(s.hash.outputLen,s.nByteLength,s.hmac)(i,o)},verify:function(e,r,n,i=I){const o=e;if(r=ye("msgHash",r),n=ye("publicKey",n),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:u,prehash:f}=i;let h,l;try{if("string"==typeof o||o instanceof Uint8Array)try{h=g.fromDER(o)}catch(e){if(!(e instanceof De.Err))throw e;h=g.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:e,s:t}=o;h=new g(e,t)}}l=c.fromHex(n)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(u&&h.hasHighS())return!1;f&&(r=t.hash(r));const{r:d,s:p}=h,y=m(r),w=a(p),b=s(y*w),x=s(d*w),E=c.BASE.multiplyAndAddUnsafe(l,b,x)?.toAffine();return!!E&&s(E.x)===d},ProjectivePoint:c,Signature:g,utils:y}}function Xe(e){return{hash:e,hmac:(t,...r)=>v(e,t,y(...r)),randomBytes:x}}const Je=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Qe=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),et=BigInt(1),tt=BigInt(2),rt=(e,t)=>(e+t/tt)/t;function nt(e){const t=Je,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),u=e*e*e%t,f=u*u*e%t,h=Re(f,r,t)*f%t,l=Re(h,r,t)*f%t,d=Re(l,tt,t)*u%t,p=Re(d,i,t)*d%t,g=Re(p,o,t)*p%t,y=Re(g,a,t)*g%t,w=Re(y,c,t)*y%t,b=Re(w,a,t)*g%t,m=Re(b,r,t)*f%t,x=Re(m,s,t)*p%t,E=Re(x,n,t)*u%t,v=Re(E,tt,t);if(!it.eql(it.sqr(v),e))throw new Error("Cannot find square root");return v}const it=function(e,t,r=!1,n={}){if(e<=Ie)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:i,nByteLength:o}=Ke(e,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=Fe(e),a=Object.freeze({ORDER:e,BITS:i,BYTES:o,MASK:be(i),ZERO:Ie,ONE:Ae,create:t=>Ue(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return Ie<=t&&t<e},is0:e=>e===Ie,isOdd:e=>(e&Ae)===Ae,neg:t=>Ue(-t,e),eql:(e,t)=>e===t,sqr:t=>Ue(t*t,e),add:(t,r)=>Ue(t+r,e),sub:(t,r)=>Ue(t-r,e),mul:(t,r)=>Ue(t*r,e),pow:(e,t)=>function(e,t,r){if(r<Ie)throw new Error("Expected power > 0");if(r===Ie)return e.ONE;if(r===Ae)return t;let n=e.ONE,i=t;for(;r>Ie;)r&Ae&&(n=e.mul(n,i)),i=e.sqr(i),r>>=Ae;return n}(a,e,t),div:(t,r)=>Ue(t*Ne(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>Ne(t,e),sqrt:n.sqrt||(e=>s(a,e)),invertBatch:e=>function(e,t){const r=new Array(t.length),n=t.reduce(((t,n,i)=>e.is0(n)?t:(r[i]=t,e.mul(t,n))),e.ONE),i=e.inv(n);return t.reduceRight(((t,n,i)=>e.is0(n)?t:(r[i]=e.mul(t,r[i]),e.mul(t,n))),i),r}(a,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?ge(e,o):pe(e,o),fromBytes:e=>{if(e.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`);return r?de(e):le(e)}});return Object.freeze(a)}(Je,void 0,void 0,{sqrt:nt}),ot=function(e,t){const r=t=>Ye({...e,...Xe(t)});return Object.freeze({...r(t),create:r})}({a:BigInt(0),b:BigInt(7),Fp:it,n:Qe,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=Qe,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-et*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),a=rt(o*e,t),c=rt(-n*e,t);let u=Ue(e-a*r-c*i,t),f=Ue(-a*n-c*o,t);const h=u>s,l=f>s;if(h&&(u=t-u),l&&(f=t-f),u>s||f>s)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:h,k1:u,k2neg:l,k2:f}}}},M);BigInt(0);ot.ProjectivePoint;function st(e){if(!Number.isSafeInteger(e))throw new Error(`Wrong integer: ${e}`)}function at(...e){const t=(e,t)=>r=>e(t(r));return{encode:Array.from(e).reverse().reduce(((e,r)=>e?t(e,r.encode):r.encode),void 0),decode:e.reduce(((e,r)=>e?t(e,r.decode):r.decode),void 0)}}function ct(e){return{encode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("alphabet.encode input should be an array of numbers");return t.map((t=>{if(st(t),t<0||t>=e.length)throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`);return e[t]}))},decode:t=>{if(!Array.isArray(t)||t.length&&"string"!=typeof t[0])throw new Error("alphabet.decode input should be array of strings");return t.map((t=>{if("string"!=typeof t)throw new Error(`alphabet.decode: not string element=${t}`);const r=e.indexOf(t);if(-1===r)throw new Error(`Unknown letter: "${t}". Allowed: ${e}`);return r}))}}}function ut(e=""){if("string"!=typeof e)throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&"string"!=typeof t[0])throw new Error("join.encode input should be array of strings");for(let e of t)if("string"!=typeof e)throw new Error(`join.encode: non-string input=${e}`);return t.join(e)},decode:t=>{if("string"!=typeof t)throw new Error("join.decode input should be string");return t.split(e)}}}function ft(e,t="="){if(st(e),"string"!=typeof t)throw new Error("padding chr should be string");return{encode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let e of r)if("string"!=typeof e)throw new Error(`padding.encode: non-string input=${e}`);for(;r.length*e%8;)r.push(t);return r},decode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let e of r)if("string"!=typeof e)throw new Error(`padding.decode: non-string input=${e}`);let n=r.length;if(n*e%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;n>0&&r[n-1]===t;n--)if(!((n-1)*e%8))throw new Error("Invalid padding: string has too much padding");return r.slice(0,n)}}}function ht(e){if("function"!=typeof e)throw new Error("normalize fn should be function");return{encode:e=>e,decode:t=>e(t)}}function lt(e,t,r){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);if(!Array.isArray(e))throw new Error("convertRadix: data should be array");if(!e.length)return[];let n=0;const i=[],o=Array.from(e);for(o.forEach((e=>{if(st(e),e<0||e>=t)throw new Error(`Wrong integer: ${e}`)}));;){let e=0,s=!0;for(let i=n;i<o.length;i++){const a=o[i],c=t*e+a;if(!Number.isSafeInteger(c)||t*e/t!==e||c-a!=t*e)throw new Error("convertRadix: carry overflow");e=c%r;const u=Math.floor(c/r);if(o[i]=u,!Number.isSafeInteger(u)||u*r+e!==c)throw new Error("convertRadix: carry overflow");s&&(u?s=!1:n=i)}if(i.push(e),s)break}for(let t=0;t<e.length-1&&0===e[t];t++)i.push(0);return i.reverse()}const dt=(e,t)=>t?dt(t,e%t):e,pt=(e,t)=>e+(t-dt(e,t));function gt(e,t,r,n){if(!Array.isArray(e))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(pt(t,r)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${pt(t,r)}`);let i=0,o=0;const s=2**r-1,a=[];for(const n of e){if(st(n),n>=2**t)throw new Error(`convertRadix2: invalid data word=${n} from=${t}`);if(i=i<<t|n,o+t>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${t}`);for(o+=t;o>=r;o-=r)a.push((i>>o-r&s)>>>0);i&=2**o-1}if(i=i<<r-o&s,!n&&o>=t)throw new Error("Excess padding");if(!n&&i)throw new Error(`Non-zero padding: ${i}`);return n&&o>0&&a.push(i>>>0),a}function yt(e){return st(e),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return lt(Array.from(t),256,e)},decode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("radix.decode input should be array of strings");return Uint8Array.from(lt(t,e,256))}}}function wt(e,t=!1){if(st(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(pt(8,e)>32||pt(e,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!(r instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return gt(Array.from(r),8,e,!t)},decode:r=>{if(!Array.isArray(r)||r.length&&"number"!=typeof r[0])throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(gt(r,e,8,t))}}}function bt(e,t){if(st(e),"function"!=typeof t)throw new Error("checksum fn should be function");return{encode(r){if(!(r instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const n=t(r).slice(0,e),i=new Uint8Array(r.length+e);return i.set(r),i.set(n,r.length),i},decode(r){if(!(r instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-e),i=t(n).slice(0,e),o=r.slice(-e);for(let t=0;t<e;t++)if(i[t]!==o[t])throw new Error("Invalid checksum");return n}}}const mt=at(wt(4),ct("0123456789ABCDEF"),ut("")),xt=at(wt(5),ct("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),ft(5),ut("")),Et=(wt(5),ct("0123456789ABCDEFGHIJKLMNOPQRSTUV"),ft(5),ut(""),wt(5),ct("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),ut(""),ht((e=>e.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),at(wt(6),ct("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),ft(6),ut(""))),vt=at(wt(6),ct("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),ft(6),ut("")),Bt=(wt(6),ct("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),ut(""),e=>at(yt(58),ct(e),ut(""))),It=Bt("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),At=[0,2,3,5,6,7,9,10,11],St={encode(e){let t="";for(let r=0;r<e.length;r+=8){const n=e.subarray(r,r+8);t+=It.encode(n).padStart(At[n.length],"1")}return t},decode(e){let t=[];for(let r=0;r<e.length;r+=11){const n=e.slice(r,r+11),i=At.indexOf(n.length),o=It.decode(n);for(let e=0;e<o.length-i;e++)if(0!==o[e])throw new Error("base58xmr: wrong padding");t=t.concat(Array.from(o.slice(o.length-i)))}return Uint8Array.from(t)}};ct("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),ut("");const Pt={encode:e=>(new TextDecoder).decode(e),decode:e=>(new TextEncoder).encode(e)},Ot=(wt(4),ct("0123456789abcdef"),ut(""),ht((e=>{if("string"!=typeof e||e.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);return e.toLowerCase()})),ot.ProjectivePoint),$t=(e=>at(bt(4,(t=>e(e(t)))),It))(M);function zt(e){return BigInt(`0x${function(e){if(!f(e))throw new Error("Uint8Array expected");let t="";for(let r=0;r<e.length;r++)t+=d[e[r]];return t}(e)}`)}function Ut(e){return function(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let t=0;t<r.length;t++){const n=2*t,i=e.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[t]=o}return r}(e.toString(16).padStart(64,"0"))}const Lt=p("Bitcoin seed"),Rt={private:76066276,public:76067358},Nt=2147483648,Ft=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error(`Invalid number=${e}. Should be from 0 to 2 ** 32 - 1`);const t=new Uint8Array(4);return h(t).setUint32(0,e,!1),t};class Tt{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return e=this.pubHash,h(e).getUint32(0,!1);var e}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const e=this.privateKey;if(!e)throw new Error("No private key");return $t.encode(this.serialize(this.versions.private,y(new Uint8Array([0]),e)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return $t.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(e,t=Rt){if(o(e),8*e.length<128||8*e.length>512)throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`);const r=v(ie,Lt,e);return new Tt({versions:t,chainCode:r.slice(32),privateKey:r.slice(0,32)})}static fromExtendedKey(e,t=Rt){const r=$t.decode(e),n=h(r),i=n.getUint32(0,!1),o={versions:t,depth:r[4],parentFingerprint:n.getUint32(5,!1),index:n.getUint32(9,!1),chainCode:r.slice(13,45)},s=r.slice(45),a=0===s[0];if(i!==t[a?"private":"public"])throw new Error("Version mismatch");return new Tt(a?{...o,privateKey:s.slice(1)}:{...o,publicKey:s})}static fromJSON(e){return Tt.fromExtendedKey(e.xpriv)}constructor(e){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!e||"object"!=typeof e)throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||Rt,this.depth=e.depth||0,this.chainCode=e.chainCode,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!ot.utils.isValidPrivateKey(e.privateKey))throw new Error("Invalid private key");this.privKey="bigint"==typeof e.privateKey?e.privateKey:zt(e.privateKey),this.privKeyBytes=Ut(this.privKey),this.pubKey=ot.getPublicKey(e.privateKey,!0)}else{if(!e.publicKey)throw new Error("HDKey: no public or private key provided");this.pubKey=Ot.fromHex(e.publicKey).toRawBytes(!0)}var t;this.pubHash=(t=this.pubKey,K(M(t)))}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const t=e.replace(/^[mM]'?\//,"").split("/");let r=this;for(const e of t){const t=/^(\d+)('?)$/.exec(e),n=t&&t[1];if(!t||3!==t.length||"string"!=typeof n)throw new Error(`Invalid child index: ${e}`);let i=+n;if(!Number.isSafeInteger(i)||i>=Nt)throw new Error("Invalid index");"'"===t[2]&&(i+=Nt),r=r.deriveChild(i)}return r}deriveChild(e){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let t=Ft(e);if(e>=Nt){const e=this.privateKey;if(!e)throw new Error("Could not derive hardened child key");t=y(new Uint8Array([0]),e,t)}else t=y(this.pubKey,t);const r=v(ie,this.chainCode,t),n=zt(r.slice(0,32)),i=r.slice(32);if(!ot.utils.isValidPrivateKey(n))throw new Error("Tweak bigger than curve order");const o={versions:this.versions,chainCode:i,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e};try{if(this.privateKey){const e=Ue(this.privKey+n,ot.CURVE.n);if(!ot.utils.isValidPrivateKey(e))throw new Error("The tweak was out of range or the resulted private key is invalid");o.privateKey=e}else{const e=Ot.fromHex(this.pubKey).add(Ot.fromPrivateKey(n));if(e.equals(Ot.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");o.publicKey=e.toRawBytes(!0)}return new Tt(o)}catch(t){return this.deriveChild(e+1)}}sign(e){if(!this.privateKey)throw new Error("No privateKey set!");return o(e,32),ot.sign(e,this.privKey).toCompactRawBytes()}verify(e,t){if(o(e,32),o(t,64),!this.publicKey)throw new Error("No publicKey set!");let r;try{r=ot.Signature.fromCompact(t)}catch(e){return!1}return ot.verify(r,e,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,t){if(!this.chainCode)throw new Error("No chainCode set");return o(t,33),y(Ft(e),new Uint8Array([this.depth]),Ft(this.parentFingerprint),Ft(this.index),this.chainCode,t)}}function Kt(e,t,r,n){s(e);const o=function(e,t){if(void 0!==t&&"[object Object]"!==b.call(t))throw new Error("Options should be object or undefined");return Object.assign(e,t)}({dkLen:32,asyncTick:10},n),{c:a,dkLen:c,asyncTick:u}=o;if(i(a),i(c),i(u),a<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const f=g(t),h=g(r),l=new Uint8Array(c),d=v.create(e,f),p=d._cloneInto().update(h);return{c:a,dkLen:c,asyncTick:u,DK:l,PRF:d,PRFSalt:p}}function Ht(e,t,r,n,i){return e.destroy(),t.destroy(),n&&n.destroy(),i.fill(0),r}function Ct(e){if("string"!=typeof e)throw new TypeError("Invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}function jt(e){const t=Ct(e),r=t.split(" ");if(![12,15,18,21,24].includes(r.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:r}}const kt=e=>Ct(`mnemonic${e}`);function qt(e,t=""){return function(e,t,r,n){const{c:i,dkLen:o,DK:s,PRF:a,PRFSalt:c}=Kt(e,t,r,n);let u;const f=new Uint8Array(4),l=h(f),d=new Uint8Array(a.outputLen);for(let e=1,t=0;t<o;e++,t+=a.outputLen){const r=s.subarray(t,t+a.outputLen);l.setInt32(0,e,!1),(u=c._cloneInto(u)).update(f).digestInto(d),r.set(d.subarray(0,r.length));for(let e=1;e<i;e++){a._cloneInto(u).update(d).digestInto(d);for(let e=0;e<r.length;e++)r[e]^=d[e]}}return Ht(a,c,s,u,d)}(ie,jt(e).nfkd,kt(t),{c:2048,dkLen:64})}class Mt extends Error{constructor(e,t={}){super(),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ViemError"}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:"viem@2.9.5"});const r=t.cause instanceof Mt?t.cause.details:t.cause?.message?t.cause.message:t.details,n=t.cause instanceof Mt&&t.cause.docsPath||t.docsPath;this.message=[e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...n?[`Docs: https://viem.sh${n}${t.docsSlug?`#${t.docsSlug}`:""}`]:[],...r?[`Details: ${r}`]:[],`Version: ${this.version}`].join("\n"),t.cause&&(this.cause=t.cause),this.details=r,this.docsPath=n,this.metaMessages=t.metaMessages,this.shortMessage=e}walk(e){return Vt(this,e)}}function Vt(e,t){return t?.(e)?e:e&&"object"==typeof e&&"cause"in e?Vt(e.cause,t):t?null:e}class Dt extends Mt{constructor({max:e,min:t,signed:r,size:n,value:i}){super(`Number "${i}" is not in safe ${n?`${8*n}-bit ${r?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"IntegerOutOfRangeError"})}}class Gt extends Mt{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SizeOverflowError"})}}class Zt extends Mt{constructor({offset:e,position:t,size:r}){super(`Slice ${"start"===t?"starting":"ending"} at offset "${e}" is out-of-bounds (size: ${r}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SliceOffsetOutOfBoundsError"})}}class _t extends Mt{constructor({size:e,targetSize:t,type:r}){super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SizeExceedsPaddingSizeError"})}}function Wt(e,{dir:t,size:r=32}={}){return"string"==typeof e?Yt(e,{dir:t,size:r}):function(e,{dir:t,size:r=32}={}){if(null===r)return e;if(e.length>r)throw new _t({size:e.length,targetSize:r,type:"bytes"});const n=new Uint8Array(r);for(let i=0;i<r;i++){const o="right"===t;n[o?i:r-i-1]=e[o?i:e.length-i-1]}return n}(e,{dir:t,size:r})}function Yt(e,{dir:t,size:r=32}={}){if(null===r)return e;const n=e.replace("0x","");if(n.length>2*r)throw new _t({size:Math.ceil(n.length/2),targetSize:r,type:"hex"});return`0x${n["right"===t?"padEnd":"padStart"](2*r,"0")}`}function Xt(e,{strict:t=!0}={}){return!!e&&("string"==typeof e&&(t?/^0x[0-9a-fA-F]*$/.test(e):e.startsWith("0x")))}function Jt(e){return Xt(e,{strict:!1})?Math.ceil((e.length-2)/2):e.length}function Qt(e,{size:t}){if(Jt(e)>t)throw new Gt({givenSize:Jt(e),maxSize:t})}function er(e,t={}){const{signed:r}=t;t.size&&Qt(e,{size:t.size});const n=BigInt(e);if(!r)return n;const i=(e.length-2)/2;return n<=(1n<<8n*BigInt(i)-1n)-1n?n:n-BigInt(`0x${"f".padStart(2*i,"f")}`)-1n}function tr(e,t={}){return Number(er(e,t))}const rr=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function nr(e,t={}){return"number"==typeof e||"bigint"==typeof e?sr(e,t):"string"==typeof e?cr(e,t):"boolean"==typeof e?ir(e,t):or(e,t)}function ir(e,t={}){const r=`0x${Number(e)}`;return"number"==typeof t.size?(Qt(r,{size:t.size}),Wt(r,{size:t.size})):r}function or(e,t={}){let r="";for(let t=0;t<e.length;t++)r+=rr[e[t]];const n=`0x${r}`;return"number"==typeof t.size?(Qt(n,{size:t.size}),Wt(n,{dir:"right",size:t.size})):n}function sr(e,t={}){const{signed:r,size:n}=t,i=BigInt(e);let o;n?o=r?(1n<<8n*BigInt(n)-1n)-1n:2n**(8n*BigInt(n))-1n:"number"==typeof e&&(o=BigInt(Number.MAX_SAFE_INTEGER));const s="bigint"==typeof o&&r?-o-1n:0;if(o&&i>o||i<s){const t="bigint"==typeof e?"n":"";throw new Dt({max:o?`${o}${t}`:void 0,min:`${s}${t}`,signed:r,size:n,value:`${e}${t}`})}const a=`0x${(r&&i<0?(1n<<BigInt(8*n))+BigInt(i):i).toString(16)}`;return n?Wt(a,{size:n}):a}const ar=new TextEncoder;function cr(e,t={}){return or(ar.encode(e),t)}BigInt(0);const ur=BigInt(1),fr=BigInt(2),hr=e=>e instanceof Uint8Array,lr=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function dr(e){if(!hr(e))throw new Error("Uint8Array expected");let t="";for(let r=0;r<e.length;r++)t+=lr[e[r]];return t}function pr(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}function gr(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let t=0;t<r.length;t++){const n=2*t,i=e.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[t]=o}return r}function yr(e){return pr(dr(e))}function wr(e){if(!hr(e))throw new Error("Uint8Array expected");return pr(dr(Uint8Array.from(e).reverse()))}function br(e,t){return gr(e.toString(16).padStart(2*t,"0"))}function mr(e,t){return br(e,t).reverse()}function xr(e,t,r){let n;if("string"==typeof t)try{n=gr(t)}catch(r){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${r}`)}else{if(!hr(t))throw new Error(`${e} must be hex string or Uint8Array`);n=Uint8Array.from(t)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(`${e} expected ${r} bytes, got ${i}`);return n}function Er(...e){const t=new Uint8Array(e.reduce(((e,t)=>e+t.length),0));let r=0;return e.forEach((e=>{if(!hr(e))throw new Error("Uint8Array expected");t.set(e,r),r+=e.length})),t}const vr=e=>(fr<<BigInt(e-1))-ur,Br=e=>new Uint8Array(e),Ir=e=>Uint8Array.from(e);function Ar(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=Br(e),i=Br(e),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},a=(...e)=>r(i,n,...e),c=(e=Br())=>{i=a(Ir([0]),e),n=a(),0!==e.length&&(i=a(Ir([1]),e),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){n=a();const t=n.slice();r.push(t),e+=n.length}return Er(...r)};return(e,t)=>{let r;for(s(),c(e);!(r=t(u()));)c();return s(),r}}const Sr={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||e instanceof Uint8Array,isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function Pr(e,t,r={}){const n=(t,r,n)=>{const i=Sr[r];if("function"!=typeof i)throw new Error(`Invalid validator "${r}", expected function`);const o=e[t];if(!(n&&void 0===o||i(o,e)))throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${r}`)};for(const[e,r]of Object.entries(t))n(e,r,!1);for(const[e,t]of Object.entries(r))n(e,t,!0);return e}const Or=BigInt(0),$r=BigInt(1),zr=BigInt(2),Ur=BigInt(3),Lr=BigInt(4),Rr=BigInt(5),Nr=BigInt(8);BigInt(9),BigInt(16);function Fr(e,t){const r=e%t;return r>=Or?r:t+r}function Tr(e,t,r){if(r<=Or||t<Or)throw new Error("Expected power/modulo > 0");if(r===$r)return Or;let n=$r;for(;t>Or;)t&$r&&(n=n*e%r),e=e*e%r,t>>=$r;return n}function Kr(e,t,r){let n=e;for(;t-- >Or;)n*=n,n%=r;return n}function Hr(e,t){if(e===Or||t<=Or)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=Fr(e,t),n=t,i=Or,o=$r,s=$r,a=Or;for(;r!==Or;){const e=n/r,t=n%r,c=i-s*e,u=o-a*e;n=r,r=t,i=s,o=a,s=c,a=u}if(n!==$r)throw new Error("invert: does not exist");return Fr(i,t)}function Cr(e){if(e%Lr===Ur){const t=(e+$r)/Lr;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}if(e%Nr===Rr){const t=(e-Rr)/Nr;return function(e,r){const n=e.mul(r,zr),i=e.pow(n,t),o=e.mul(r,i),s=e.mul(e.mul(o,zr),i),a=e.mul(o,e.sub(s,e.ONE));if(!e.eql(e.sqr(a),r))throw new Error("Cannot find square root");return a}}return function(e){const t=(e-$r)/zr;let r,n,i;for(r=e-$r,n=0;r%zr===Or;r/=zr,n++);for(i=zr;i<e&&Tr(i,t,e)!==e-$r;i++);if(1===n){const t=(e+$r)/Lr;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}const o=(r+$r)/zr;return function(e,s){if(e.pow(s,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let a=n,c=e.pow(e.mul(e.ONE,i),r),u=e.pow(s,o),f=e.pow(s,r);for(;!e.eql(f,e.ONE);){if(e.eql(f,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(f);t<a&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const r=e.pow(c,$r<<BigInt(a-t-1));c=e.sqr(r),u=e.mul(u,r),f=e.mul(f,c),a=t}return u}}(e)}const jr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function kr(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function qr(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function Mr(e){const t=qr(e);return t+Math.ceil(t/2)}const Vr=BigInt(0),Dr=BigInt(1);function Gr(e){return Pr(e.Fp,jr.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),Pr(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...kr(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const{Ph:Zr,aT:_r}=r,Wr={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=Wr;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const r=e[1],n=e.subarray(2,r+2);if(!r||n.length!==r)throw new t("Invalid signature integer: wrong length");if(128&n[0])throw new t("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Zr(n),l:e.subarray(r+2)}},toSig(e){const{Err:t}=Wr,r="string"==typeof e?_r(e):e;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new t("Invalid signature tag");if(r[1]!==n-2)throw new t("Invalid signature: incorrect length");const{d:i,l:o}=Wr._parseInt(r.subarray(2)),{d:s,l:a}=Wr._parseInt(o);if(a.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(e){const t=e=>8&Number.parseInt(e[0],16)?"00"+e:e,r=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},n=t(r(e.s)),i=t(r(e.r)),o=n.length/2,s=i.length/2,a=r(o),c=r(s);return`30${r(s+o+4)}02${c}${i}02${a}${n}`}},Yr=BigInt(0),Xr=BigInt(1),Jr=(BigInt(2),BigInt(3));BigInt(4);function Qr(e){const t=function(e){const t=Gr(e);Pr(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=t;if(r){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:r}=t,n=t.toBytes||((e,t,n)=>{const i=t.toAffine();return Er(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),i=t.fromBytes||(e=>{const t=e.subarray(1);return{x:r.fromBytes(t.subarray(0,r.BYTES)),y:r.fromBytes(t.subarray(r.BYTES,2*r.BYTES))}});function o(e){const{a:n,b:i}=t,o=r.sqr(e),s=r.mul(o,e);return r.add(r.add(s,r.mul(e,n)),i)}if(!r.eql(r.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function s(e){return"bigint"==typeof e&&Yr<e&&e<t.n}function a(e){if(!s(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(e){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=t;if(r&&"bigint"!=typeof e){if(e instanceof Uint8Array&&(e=dr(e)),"string"!=typeof e||!r.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*n,"0")}let s;try{s="bigint"==typeof e?e:yr(xr("private key",e,n))}catch(t){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof e}`)}return i&&(s=Fr(s,o)),a(s),s}const u=new Map;function f(e){if(!(e instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(e,t,n){if(this.px=e,this.py=t,this.pz=n,null==e||!r.isValid(e))throw new Error("x required");if(null==t||!r.isValid(t))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!r.isValid(t)||!r.isValid(n))throw new Error("invalid affine point");if(e instanceof h)throw new Error("projective point not allowed");const i=e=>r.eql(e,r.ZERO);return i(t)&&i(n)?h.ZERO:new h(t,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(h.fromAffine)}static fromHex(e){const t=h.fromAffine(i(xr("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return h.BASE.multiply(c(e))}_setWindowSize(e){this._WINDOW_SIZE=e,u.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:n}=this.toAffine();if(!r.isValid(e)||!r.isValid(n))throw new Error("bad point: x or y not FE");const i=r.sqr(n),s=o(e);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(r.isOdd)return!r.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){f(e);const{px:t,py:n,pz:i}=this,{px:o,py:s,pz:a}=e,c=r.eql(r.mul(t,a),r.mul(o,i)),u=r.eql(r.mul(n,a),r.mul(s,i));return c&&u}negate(){return new h(this.px,r.neg(this.py),this.pz)}double(){const{a:e,b:n}=t,i=r.mul(n,Jr),{px:o,py:s,pz:a}=this;let c=r.ZERO,u=r.ZERO,f=r.ZERO,l=r.mul(o,o),d=r.mul(s,s),p=r.mul(a,a),g=r.mul(o,s);return g=r.add(g,g),f=r.mul(o,a),f=r.add(f,f),c=r.mul(e,f),u=r.mul(i,p),u=r.add(c,u),c=r.sub(d,u),u=r.add(d,u),u=r.mul(c,u),c=r.mul(g,c),f=r.mul(i,f),p=r.mul(e,p),g=r.sub(l,p),g=r.mul(e,g),g=r.add(g,f),f=r.add(l,l),l=r.add(f,l),l=r.add(l,p),l=r.mul(l,g),u=r.add(u,l),p=r.mul(s,a),p=r.add(p,p),l=r.mul(p,g),c=r.sub(c,l),f=r.mul(p,d),f=r.add(f,f),f=r.add(f,f),new h(c,u,f)}add(e){f(e);const{px:n,py:i,pz:o}=this,{px:s,py:a,pz:c}=e;let u=r.ZERO,l=r.ZERO,d=r.ZERO;const p=t.a,g=r.mul(t.b,Jr);let y=r.mul(n,s),w=r.mul(i,a),b=r.mul(o,c),m=r.add(n,i),x=r.add(s,a);m=r.mul(m,x),x=r.add(y,w),m=r.sub(m,x),x=r.add(n,o);let E=r.add(s,c);return x=r.mul(x,E),E=r.add(y,b),x=r.sub(x,E),E=r.add(i,o),u=r.add(a,c),E=r.mul(E,u),u=r.add(w,b),E=r.sub(E,u),d=r.mul(p,x),u=r.mul(g,b),d=r.add(u,d),u=r.sub(w,d),d=r.add(w,d),l=r.mul(u,d),w=r.add(y,y),w=r.add(w,y),b=r.mul(p,b),x=r.mul(g,x),w=r.add(w,b),b=r.sub(y,b),b=r.mul(p,b),x=r.add(x,b),y=r.mul(w,x),l=r.add(l,y),y=r.mul(E,x),u=r.mul(m,u),u=r.sub(u,y),y=r.mul(m,w),d=r.mul(E,d),d=r.add(d,y),new h(u,l,d)}subtract(e){return this.add(e.negate())}is0(){return this.equals(h.ZERO)}wNAF(e){return d.wNAFCached(this,u,e,(e=>{const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(h.fromAffine)}))}multiplyUnsafe(e){const n=h.ZERO;if(e===Yr)return n;if(a(e),e===Xr)return this;const{endo:i}=t;if(!i)return d.unsafeLadder(this,e);let{k1neg:o,k1:s,k2neg:c,k2:u}=i.splitScalar(e),f=n,l=n,p=this;for(;s>Yr||u>Yr;)s&Xr&&(f=f.add(p)),u&Xr&&(l=l.add(p)),p=p.double(),s>>=Xr,u>>=Xr;return o&&(f=f.negate()),c&&(l=l.negate()),l=new h(r.mul(l.px,i.beta),l.py,l.pz),f.add(l)}multiply(e){a(e);let n,i,o=e;const{endo:s}=t;if(s){const{k1neg:e,k1:t,k2neg:a,k2:c}=s.splitScalar(o);let{p:u,f}=this.wNAF(t),{p:l,f:p}=this.wNAF(c);u=d.constTimeNegate(e,u),l=d.constTimeNegate(a,l),l=new h(r.mul(l.px,s.beta),l.py,l.pz),n=u.add(l),i=f.add(p)}else{const{p:e,f:t}=this.wNAF(o);n=e,i=t}return h.normalizeZ([n,i])[0]}multiplyAndAddUnsafe(e,t,r){const n=h.BASE,i=(e,t)=>t!==Yr&&t!==Xr&&e.equals(n)?e.multiply(t):e.multiplyUnsafe(t),o=i(this,t).add(i(e,r));return o.is0()?void 0:o}toAffine(e){const{px:t,py:n,pz:i}=this,o=this.is0();null==e&&(e=o?r.ONE:r.inv(i));const s=r.mul(t,e),a=r.mul(n,e),c=r.mul(i,e);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:e,isTorsionFree:r}=t;if(e===Xr)return!0;if(r)return r(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:r}=t;return e===Xr?this:r?r(h,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),n(h,this,e)}toHex(e=!0){return dr(this.toRawBytes(e))}}h.BASE=new h(t.Gx,t.Gy,r.ONE),h.ZERO=new h(r.ZERO,r.ONE,r.ZERO);const l=t.nBitLength,d=function(e,t){const r=(e,t)=>{const r=t.negate();return e?r:t},n=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate:r,unsafeLadder(t,r){let n=e.ZERO,i=t;for(;r>Vr;)r&Dr&&(n=n.add(i)),i=i.double(),r>>=Dr;return n},precomputeWindow(e,t){const{windows:r,windowSize:i}=n(t),o=[];let s=e,a=s;for(let e=0;e<r;e++){a=s,o.push(a);for(let e=1;e<i;e++)a=a.add(s),o.push(a);s=a.double()}return o},wNAF(t,i,o){const{windows:s,windowSize:a}=n(t);let c=e.ZERO,u=e.BASE;const f=BigInt(2**t-1),h=2**t,l=BigInt(t);for(let e=0;e<s;e++){const t=e*a;let n=Number(o&f);o>>=l,n>a&&(n-=h,o+=Dr);const s=t,d=t+Math.abs(n)-1,p=e%2!=0,g=n<0;0===n?u=u.add(r(p,i[s])):c=c.add(r(g,i[d]))}return{p:c,f:u}},wNAFCached(e,t,r,n){const i=e._WINDOW_SIZE||1;let o=t.get(e);return o||(o=this.precomputeWindow(e,i),1!==i&&t.set(e,n(o))),this.wNAF(i,o,r)}}}(h,t.endo?Math.ceil(l/2):l);return{CURVE:t,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:s}}function en(e){const t=function(e){const t=Gr(e);return Pr(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:r,n}=t,i=r.BYTES+1,o=2*r.BYTES+1;function s(e){return Fr(e,n)}function a(e){return Hr(e,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:f,isWithinCurveOrder:h}=Qr({...t,toBytes(e,t,n){const i=t.toAffine(),o=r.toBytes(i.x),s=Er;return n?s(Uint8Array.from([t.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(e){const t=e.length,n=e[0],s=e.subarray(1);if(t!==i||2!==n&&3!==n){if(t===o&&4===n){return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}{const e=yr(s);if(!(Yr<(a=e)&&a<r.ORDER))throw new Error("Point is not on curve");const t=f(e);let i=r.sqrt(t);return 1==(1&n)!==((i&Xr)===Xr)&&(i=r.neg(i)),{x:e,y:i}}var a}}),l=e=>dr(br(e,t.nByteLength));function d(e){return e>n>>Xr}const p=(e,t,r)=>yr(e.slice(t,r));class g{constructor(e,t,r){this.r=e,this.s=t,this.recovery=r,this.assertValidity()}static fromCompact(e){const r=t.nByteLength;return e=xr("compactSignature",e,2*r),new g(p(e,0,r),p(e,r,2*r))}static fromDER(e){const{r:t,s:r}=Wr.toSig(xr("DER",e));return new g(t,r)}assertValidity(){if(!h(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!h(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new g(this.r,this.s,e)}recoverPublicKey(e){const{r:n,s:i,recovery:o}=this,u=m(xr("msgHash",e));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const f=2===o||3===o?n+t.n:n;if(f>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=0==(1&o)?"02":"03",d=c.fromHex(h+l(f)),p=a(f),g=s(-u*p),y=s(i*p),w=c.BASE.multiplyAndAddUnsafe(d,g,y);if(!w)throw new Error("point at infinify");return w.assertValidity(),w}hasHighS(){return d(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return gr(this.toDERHex())}toDERHex(){return Wr.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return gr(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const y={isValidPrivateKey(e){try{return u(e),!0}catch(e){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const e=Mr(t.n);return function(e,t,r=!1){const n=e.length,i=qr(t),o=Mr(t);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const s=Fr(r?yr(e):wr(e),t-$r)+$r;return r?mr(s,i):br(s,i)}(t.randomBytes(e),t.n)},precompute:(e=8,t=c.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function w(e){const t=e instanceof Uint8Array,r="string"==typeof e,n=(t||r)&&e.length;return t?n===i||n===o:r?n===2*i||n===2*o:e instanceof c}const b=t.bits2int||function(e){const r=yr(e),n=8*e.length-t.nBitLength;return n>0?r>>BigInt(n):r},m=t.bits2int_modN||function(e){return s(b(e))},x=vr(t.nBitLength);function E(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(Yr<=e&&e<x))throw new Error(`bigint expected < 2^${t.nBitLength}`);return br(e,t.nByteLength)}function v(e,n,i=B){if(["recovered","canonical"].some((e=>e in i)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:f}=t;let{lowS:l,prehash:p,extraEntropy:y}=i;null==l&&(l=!0),e=xr("msgHash",e),p&&(e=xr("prehashed msgHash",o(e)));const w=m(e),x=u(n),v=[E(x),E(w)];if(null!=y){const e=!0===y?f(r.BYTES):y;v.push(xr("extraEntropy",e))}const I=Er(...v),A=w;return{seed:I,k2sig:function(e){const t=b(e);if(!h(t))return;const r=a(t),n=c.BASE.multiply(t).toAffine(),i=s(n.x);if(i===Yr)return;const o=s(r*s(A+i*x));if(o===Yr)return;let u=(n.x===i?0:2)|Number(n.y&Xr),f=o;return l&&d(o)&&(f=function(e){return d(e)?s(-e):e}(o),u^=1),new g(i,f,u)}}}const B={lowS:t.lowS,prehash:!1},I={lowS:t.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return c.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,r=!0){if(w(e))throw new Error("first arg must be private key");if(!w(t))throw new Error("second arg must be public key");return c.fromHex(t).multiply(u(e)).toRawBytes(r)},sign:function(e,r,n=B){const{seed:i,k2sig:o}=v(e,r,n),s=t;return Ar(s.hash.outputLen,s.nByteLength,s.hmac)(i,o)},verify:function(e,r,n,i=I){const o=e;if(r=xr("msgHash",r),n=xr("publicKey",n),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:u,prehash:f}=i;let h,l;try{if("string"==typeof o||o instanceof Uint8Array)try{h=g.fromDER(o)}catch(e){if(!(e instanceof Wr.Err))throw e;h=g.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:e,s:t}=o;h=new g(e,t)}}l=c.fromHex(n)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(u&&h.hasHighS())return!1;f&&(r=t.hash(r));const{r:d,s:p}=h,y=m(r),w=a(p),b=s(y*w),x=s(d*w),E=c.BASE.multiplyAndAddUnsafe(l,b,x)?.toAffine();return!!E&&s(E.x)===d},ProjectivePoint:c,Signature:g,utils:y}}function tn(e){return{hash:e,hmac:(t,...r)=>v(e,t,y(...r)),randomBytes:x}}const rn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),nn=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),on=BigInt(1),sn=BigInt(2),an=(e,t)=>(e+t/sn)/t;function cn(e){const t=rn,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),u=e*e*e%t,f=u*u*e%t,h=Kr(f,r,t)*f%t,l=Kr(h,r,t)*f%t,d=Kr(l,sn,t)*u%t,p=Kr(d,i,t)*d%t,g=Kr(p,o,t)*p%t,y=Kr(g,a,t)*g%t,w=Kr(y,c,t)*y%t,b=Kr(w,a,t)*g%t,m=Kr(b,r,t)*f%t,x=Kr(m,s,t)*p%t,E=Kr(x,n,t)*u%t,v=Kr(E,sn,t);if(!un.eql(un.sqr(v),e))throw new Error("Cannot find square root");return v}const un=function(e,t,r=!1,n={}){if(e<=Or)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:i,nByteLength:o}=kr(e,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=Cr(e),a=Object.freeze({ORDER:e,BITS:i,BYTES:o,MASK:vr(i),ZERO:Or,ONE:$r,create:t=>Fr(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return Or<=t&&t<e},is0:e=>e===Or,isOdd:e=>(e&$r)===$r,neg:t=>Fr(-t,e),eql:(e,t)=>e===t,sqr:t=>Fr(t*t,e),add:(t,r)=>Fr(t+r,e),sub:(t,r)=>Fr(t-r,e),mul:(t,r)=>Fr(t*r,e),pow:(e,t)=>function(e,t,r){if(r<Or)throw new Error("Expected power > 0");if(r===Or)return e.ONE;if(r===$r)return t;let n=e.ONE,i=t;for(;r>Or;)r&$r&&(n=e.mul(n,i)),i=e.sqr(i),r>>=$r;return n}(a,e,t),div:(t,r)=>Fr(t*Hr(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>Hr(t,e),sqrt:n.sqrt||(e=>s(a,e)),invertBatch:e=>function(e,t){const r=new Array(t.length),n=t.reduce(((t,n,i)=>e.is0(n)?t:(r[i]=t,e.mul(t,n))),e.ONE),i=e.inv(n);return t.reduceRight(((t,n,i)=>e.is0(n)?t:(r[i]=e.mul(t,r[i]),e.mul(t,n))),i),r}(a,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?mr(e,o):br(e,o),fromBytes:e=>{if(e.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`);return r?wr(e):yr(e)}});return Object.freeze(a)}(rn,void 0,void 0,{sqrt:cn}),fn=function(e,t){const r=t=>en({...e,...tn(t)});return Object.freeze({...r(t),create:r})}({a:BigInt(0),b:BigInt(7),Fp:un,n:nn,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=nn,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-on*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),a=an(o*e,t),c=an(-n*e,t);let u=Fr(e-a*r-c*i,t),f=Fr(-a*n-c*o,t);const h=u>s,l=f>s;if(h&&(u=t-u),l&&(f=t-f),u>s||f>s)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:h,k1:u,k2neg:l,k2:f}}}},M);BigInt(0);fn.ProjectivePoint;class hn extends Mt{constructor({address:e}){super(`Address "${e}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAddressError"})}}class ln extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}set(e,t){return super.set(e,t),this.maxSize&&this.size>this.maxSize&&this.delete(this.keys().next().value),this}}const dn=new TextEncoder;function pn(e,t={}){return"number"==typeof e||"bigint"==typeof e?function(e,t){const r=sr(e,t);return wn(r)}(e,t):"boolean"==typeof e?function(e,t={}){const r=new Uint8Array(1);if(r[0]=Number(e),"number"==typeof t.size)return Qt(r,{size:t.size}),Wt(r,{size:t.size});return r}(e,t):Xt(e)?wn(e,t):bn(e,t)}const gn={zero:48,nine:57,A:65,F:70,a:97,f:102};function yn(e){return e>=gn.zero&&e<=gn.nine?e-gn.zero:e>=gn.A&&e<=gn.F?e-(gn.A-10):e>=gn.a&&e<=gn.f?e-(gn.a-10):void 0}function wn(e,t={}){let r=e;t.size&&(Qt(r,{size:t.size}),r=Wt(r,{dir:"right",size:t.size}));let n=r.slice(2);n.length%2&&(n=`0${n}`);const i=n.length/2,o=new Uint8Array(i);for(let e=0,t=0;e<i;e++){const r=yn(n.charCodeAt(t++)),i=yn(n.charCodeAt(t++));if(void 0===r||void 0===i)throw new Mt(`Invalid byte sequence ("${n[t-2]}${n[t-1]}" in "${n}").`);o[e]=16*r+i}return o}function bn(e,t={}){const r=dn.encode(e);return"number"==typeof t.size?(Qt(r,{size:t.size}),Wt(r,{dir:"right",size:t.size})):r}const[mn,xn,En]=[[],[],[]],vn=BigInt(0),Bn=BigInt(1),In=BigInt(2),An=BigInt(7),Sn=BigInt(256),Pn=BigInt(113);for(let e=0,t=Bn,r=1,n=0;e<24;e++){[r,n]=[n,(2*r+3*n)%5],mn.push(2*(5*n+r)),xn.push((e+1)*(e+2)/2%64);let i=vn;for(let e=0;e<7;e++)t=(t<<Bn^(t>>An)*Pn)%Sn,t&In&&(i^=Bn<<(Bn<<BigInt(e))-Bn);En.push(i)}const[On,$n]=Z(En,!0),zn=(e,t,r)=>r>32?Y(e,t,r):_(e,t,r),Un=(e,t,r)=>r>32?X(e,t,r):W(e,t,r);class Ln extends w{constructor(e,t,r,n=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=n,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,i(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var s;this.state=new Uint8Array(200),this.state32=(s=this.state,new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4)))}keccak(){!function(e,t=24){const r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let t=0;t<10;t++)r[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const n=(t+8)%10,i=(t+2)%10,o=r[i],s=r[i+1],a=zn(o,s,1)^r[n],c=Un(o,s,1)^r[n+1];for(let r=0;r<50;r+=10)e[t+r]^=a,e[t+r+1]^=c}let t=e[2],i=e[3];for(let r=0;r<24;r++){const n=xn[r],o=zn(t,i,n),s=Un(t,i,n),a=mn[r];t=e[a],i=e[a+1],e[a]=o,e[a+1]=s}for(let t=0;t<50;t+=10){for(let n=0;n<10;n++)r[n]=e[t+n];for(let n=0;n<10;n++)e[t+n]^=~r[(n+2)%10]&r[(n+4)%10]}e[0]^=On[n],e[1]^=$n[n]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){a(this);const{blockLen:t,state:r}=this,n=(e=g(e)).length;for(let i=0;i<n;){const o=Math.min(t-this.pos,n-i);for(let t=0;t<o;t++)r[this.pos++]^=e[i++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:r,blockLen:n}=this;e[r]^=t,0!=(128&t)&&r===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){a(this,!1),o(e),this.finish();const t=this.state,{blockLen:r}=this;for(let n=0,i=e.length;n<i;){this.posOut>=r&&this.keccak();const o=Math.min(r-this.posOut,i-n);e.set(t.subarray(this.posOut,this.posOut+o),n),this.posOut+=o,n+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return i(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(c(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:n,rounds:i,enableXOF:o}=this;return e||(e=new Ln(t,r,n,o,i)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=i,e.suffix=r,e.outputLen=n,e.enableXOF=o,e.destroyed=this.destroyed,e}}const Rn=(e,t,r)=>m((()=>new Ln(t,e,r))),Nn=Rn(1,136,32);function Fn(e,t){const r=t||"hex",n=Nn(Xt(e,{strict:!1})?pn(e):e);return"bytes"===r?n:nr(n)}function Tn(e,t){const r=t?`${t}${e.toLowerCase()}`:e.substring(2).toLowerCase(),n=Fn(bn(r),"bytes"),i=(t?r.substring(`${t}0x`.length):r).split("");for(let e=0;e<40;e+=2)n[e>>1]>>4>=8&&i[e]&&(i[e]=i[e].toUpperCase()),(15&n[e>>1])>=8&&i[e+1]&&(i[e+1]=i[e+1].toUpperCase());return`0x${i.join("")}`}const Kn=/^0x[a-fA-F0-9]{40}$/,Hn=new ln(8192);function Cn(e,{strict:t=!0}={}){if(Hn.has(e))return Hn.get(e);const r=!(!Kn.test(e)||e.toLowerCase()!==e&&t&&Tn(e)!==e);return Hn.set(e,r),r}const jn="Ethereum Signed Message:\n";function kn(e){return"string"==typeof e[0]?qn(e):function(e){let t=0;for(const r of e)t+=r.length;const r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}(e)}function qn(e){return`0x${e.reduce(((e,t)=>e+t.replace("0x","")),"")}`}function Mn(e,t){const r="string"==typeof e?bn(e):e.raw instanceof Uint8Array?e.raw:pn(e.raw);return Fn(kn([bn(`${jn}${r.length}`),r]),t)}function Vn({r:e,s:t,v:r,yParity:n}){const i=(()=>{if(27n===r||0===n)return"1b";if(28n===r||1===n)return"1c";throw new Error("Invalid v value")})();return`0x${new fn.Signature(er(e),er(t)).toCompactHex()}${i}`}async function Dn({hash:e,privateKey:t}){const{r,s:n,recovery:i}=fn.sign(e.slice(2),t.slice(2));return{r:nr(r),s:nr(n),v:i?28n:27n,yParity:i}}const Gn={ether:-9,wei:9};function Zn(e,t){let r=e.toString();const n=r.startsWith("-");n&&(r=r.slice(1)),r=r.padStart(t,"0");let[i,o]=[r.slice(0,r.length-t),r.slice(r.length-t)];return o=o.replace(/(0+)$/,""),`${n?"-":""}${i||"0"}${o?`.${o}`:""}`}function _n(e,t="wei"){return Zn(e,Gn[t])}function Wn(e){const t=Object.entries(e).map((([e,t])=>void 0===t||!1===t?null:[e,t])).filter(Boolean),r=t.reduce(((e,[t])=>Math.max(e,t.length)),0);return t.map((([e,t])=>`  ${`${e}:`.padEnd(r+1)}  ${t}`)).join("\n")}class Yn extends Mt{constructor({v:e}){super(`Invalid \`v\` value "${e}". Expected 27 or 28.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidLegacyVError"})}}class Xn extends Mt{constructor({transaction:e}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",Wn(e),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- a Legacy Transaction with `gasPrice`"]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSerializableTransactionError"})}}class Jn extends Mt{constructor({storageKey:e}){super(`Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor((e.length-2)/2)} bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStorageKeySizeError"})}}function Qn(e){const{kzg:t}=e,r=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),n="string"==typeof e.blobs[0]?e.blobs.map((e=>wn(e))):e.blobs,i=[];for(const e of n)i.push(Uint8Array.from(t.blobToKzgCommitment(e)));return"bytes"===r?i:i.map((e=>or(e)))}function ei(e){const{kzg:t}=e,r=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),n="string"==typeof e.blobs[0]?e.blobs.map((e=>wn(e))):e.blobs,i="string"==typeof e.commitments[0]?e.commitments.map((e=>wn(e))):e.commitments,o=[];for(let e=0;e<n.length;e++){const r=n[e],s=i[e];o.push(Uint8Array.from(t.computeBlobKzgProof(r,s)))}return"bytes"===r?o:o.map((e=>or(e)))}function ti(e){const{commitment:t,version:r=1}=e,n=e.to??("string"==typeof t?"hex":"bytes"),i=function(e,t){const r=t||"hex",n=M(Xt(e,{strict:!1})?pn(e):e);return"bytes"===r?n:nr(n)}(t,"bytes");return i.set([r],0),"bytes"===n?i:or(i)}const ri=32,ni=4096,ii=ri*ni,oi=6*ii-1-1*ni*6,si=1;class ai extends Mt{constructor({maxSize:e,size:t}){super("Blob size is too large.",{metaMessages:[`Max: ${e} bytes`,`Given: ${t} bytes`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BlobSizeTooLargeError"})}}class ci extends Mt{constructor(){super("Blob data must not be empty."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"EmptyBlobError"})}}class ui extends Mt{constructor({hash:e,size:t}){super(`Versioned hash "${e}" size is invalid.`,{metaMessages:["Expected: 32",`Received: ${t}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidVersionedHashSizeError"})}}class fi extends Mt{constructor({hash:e,version:t}){super(`Versioned hash "${e}" version is invalid.`,{metaMessages:[`Expected: ${si}`,`Received: ${t}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidVersionedHashVersionError"})}}class hi extends Mt{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NegativeOffsetError"})}}class li extends Mt{constructor({length:e,position:t}){super(`Position \`${t}\` is out of bounds (\`0 < position < ${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PositionOutOfBoundsError"})}}class di extends Mt{constructor({count:e,limit:t}){super(`Recursive read limit of \`${t}\` exceeded (recursive read count: \`${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"RecursiveReadLimitExceededError"})}}const pi={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:1/0,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new di({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new li({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new hi({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new hi({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const r=t??this.position;return this.assertPosition(r+e-1),this.bytes.subarray(r,r+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,255&e),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const r=this.inspectBytes(e);return this.position+=t??e,r},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===1/0)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function gi(e,{recursiveReadLimit:t=8192}={}){const r=Object.create(pi);return r.bytes=e,r.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),r.positionReadCount=new Map,r.recursiveReadLimit=t,r}function yi(e){const{data:t,kzg:r,to:n}=e,i=e.blobs??function(e){const t=e.to??("string"==typeof e.data?"hex":"bytes"),r="string"==typeof e.data?wn(e.data):e.data,n=Jt(r);if(!n)throw new ci;if(n>oi)throw new ai({maxSize:oi,size:n});const i=[];let o=!0,s=0;for(;o;){const e=gi(new Uint8Array(ii));let t=0;for(;t<ni;){const n=r.slice(s,s+(ri-1));if(e.pushByte(0),e.pushBytes(n),n.length<31){e.pushByte(128),o=!1;break}t++,s+=31}i.push(e)}return"bytes"===t?i.map((e=>e.bytes)):i.map((e=>or(e.bytes)))}({data:t,to:n}),o=e.commitments??Qn({blobs:i,kzg:r,to:n}),s=e.proofs??ei({blobs:i,commitments:o,kzg:r,to:n}),a=[];for(let e=0;e<i.length;e++)a.push({blob:i[e],commitment:o[e],proof:s[e]});return a}function wi(e,{dir:t="left"}={}){let r="string"==typeof e?e.replace("0x",""):e,n=0;for(let e=0;e<r.length-1&&"0"===r["left"===t?e:r.length-e-1].toString();e++)n++;return r="left"===t?r.slice(n):r.slice(0,r.length-n),"string"==typeof e?(1===r.length&&"right"===t&&(r=`${r}0`),`0x${r.length%2==1?`0${r}`:r}`):r}function bi(e,t="hex"){const r=mi(e),n=gi(new Uint8Array(r.length));return r.encode(n),"hex"===t?or(n.bytes):n.bytes}function mi(e){return Array.isArray(e)?function(e){const t=e.reduce(((e,t)=>e+t.length),0),r=xi(t);return{length:t<=55?1+t:1+r+t,encode(n){t<=55?n.pushByte(192+t):(n.pushByte(247+r),1===r?n.pushUint8(t):2===r?n.pushUint16(t):3===r?n.pushUint24(t):n.pushUint32(t));for(const{encode:t}of e)t(n)}}}(e.map((e=>mi(e)))):function(e){const t="string"==typeof e?wn(e):e,r=xi(t.length),n=1===t.length&&t[0]<128?1:t.length<=55?1+t.length:1+r+t.length;return{length:n,encode(e){1===t.length&&t[0]<128?e.pushBytes(t):t.length<=55?(e.pushByte(128+t.length),e.pushBytes(t)):(e.pushByte(183+r),1===r?e.pushUint8(t.length):2===r?e.pushUint16(t.length):3===r?e.pushUint24(t.length):e.pushUint32(t.length),e.pushBytes(t))}}}(e)}function xi(e){if(e<256)return 1;if(e<65536)return 2;if(e<2**24)return 3;if(e<2**32)return 4;throw new Mt("Length is too large.")}class Ei extends Mt{constructor({chainId:e}){super("number"==typeof e?`Chain ID "${e}" is invalid.`:"Chain ID is invalid."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidChainIdError"})}}class vi extends Mt{constructor({cause:e,message:t}={}){const r=t?.replace("execution reverted: ","")?.replace("execution reverted","");super(`Execution reverted ${r?`with reason: ${r}`:"for an unknown reason"}.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ExecutionRevertedError"})}}Object.defineProperty(vi,"code",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(vi,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/execution reverted/});class Bi extends Mt{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${_n(t)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FeeCapTooHigh"})}}Object.defineProperty(Bi,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/});Object.defineProperty(class extends Mt{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${_n(t)}`:""} gwei) cannot be lower than the block base fee.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FeeCapTooLow"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/});Object.defineProperty(class extends Mt{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}is higher than the next one expected.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NonceTooHighError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too high/});Object.defineProperty(class extends Mt{constructor({cause:e,nonce:t}={}){super([`Nonce provided for the transaction ${t?`(${t}) `:""}is lower than the current nonce of the account.`,"Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"),{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NonceTooLowError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too low|transaction already imported|already known/});Object.defineProperty(class extends Mt{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}exceeds the maximum allowed nonce.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NonceMaxValueError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce has max value/});Object.defineProperty(class extends Mt{constructor({cause:e}={}){super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"),{cause:e,metaMessages:["This error could arise when the account does not have enough funds to:"," - pay for the total gas fee,"," - pay for the value to send."," ","The cost of the transaction is calculated as `gas * gas fee + value`, where:"," - `gas` is the amount of gas needed for transaction to execute,"," - `gas fee` is the gas fee,"," - `value` is the amount of ether to send to the recipient."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InsufficientFundsError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/insufficient funds/});Object.defineProperty(class extends Mt{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction exceeds the limit allowed for the block.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"IntrinsicGasTooHighError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too high|gas limit reached/});Object.defineProperty(class extends Mt{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction is too low.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"IntrinsicGasTooLowError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too low/});Object.defineProperty(class extends Mt{constructor({cause:e}){super("The transaction type is not supported for this chain.",{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"TransactionTypeNotSupportedError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/transaction type not valid/});class Ii extends Mt{constructor({cause:e,maxPriorityFeePerGas:t,maxFeePerGas:r}={}){super([`The provided tip (\`maxPriorityFeePerGas\`${t?` = ${_n(t)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r?` = ${_n(r)} gwei`:""}).`].join("\n"),{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"TipAboveFeeCapError"})}}Object.defineProperty(Ii,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max priority fee per gas higher than max fee per gas|tip higher than fee cap/});function Ai(e,t,r,{strict:n}={}){return Xt(e,{strict:!1})?function(e,t,r,{strict:n}={}){Si(e,t);const i=`0x${e.replace("0x","").slice(2*(t??0),2*(r??e.length))}`;n&&Pi(i,t,r);return i}(e,t,r,{strict:n}):function(e,t,r,{strict:n}={}){Si(e,t);const i=e.slice(t,r);n&&Pi(i,t,r);return i}(e,t,r,{strict:n})}function Si(e,t){if("number"==typeof t&&t>0&&t>Jt(e)-1)throw new Zt({offset:t,position:"start",size:Jt(e)})}function Pi(e,t,r){if("number"==typeof t&&"number"==typeof r&&Jt(e)!==r-t)throw new Zt({offset:r,position:"end",size:Jt(e)})}function Oi(e){const{chainId:t,maxPriorityFeePerGas:r,maxFeePerGas:n,to:i}=e;if(t<=0)throw new Ei({chainId:t});if(i&&!Cn(i))throw new hn({address:i});if(n&&n>2n**256n-1n)throw new Bi({maxFeePerGas:n});if(r&&n&&r>n)throw new Ii({maxFeePerGas:n,maxPriorityFeePerGas:r})}function $i(e){if(!e||0===e.length)return[];const t=[];for(let r=0;r<e.length;r++){const{address:n,storageKeys:i}=e[r];for(let e=0;e<i.length;e++)if(i[e].length-2!=64)throw new Jn({storageKey:i[e]});if(!Cn(n,{strict:!1}))throw new hn({address:n});t.push([n,i])}return t}function zi(e,t){const r=function(e){if(e.type)return e.type;if(void 0!==e.blobs||void 0!==e.blobVersionedHashes||void 0!==e.maxFeePerBlobGas||void 0!==e.sidecars)return"eip4844";if(void 0!==e.maxFeePerGas||void 0!==e.maxPriorityFeePerGas)return"eip1559";if(void 0!==e.gasPrice)return void 0!==e.accessList?"eip2930":"legacy";throw new Xn({transaction:e})}(e);return"eip1559"===r?function(e,t){const{chainId:r,gas:n,nonce:i,to:o,value:s,maxFeePerGas:a,maxPriorityFeePerGas:c,accessList:u,data:f}=e;Oi(e);const h=$i(u),l=[nr(r),i?nr(i):"0x",c?nr(c):"0x",a?nr(a):"0x",n?nr(n):"0x",o??"0x",s?nr(s):"0x",f??"0x",h,...Ui(e,t)];return qn(["0x02",bi(l)])}(e,t):"eip2930"===r?function(e,t){const{chainId:r,gas:n,data:i,nonce:o,to:s,value:a,accessList:c,gasPrice:u}=e;!function(e){const{chainId:t,maxPriorityFeePerGas:r,gasPrice:n,maxFeePerGas:i,to:o}=e;if(t<=0)throw new Ei({chainId:t});if(o&&!Cn(o))throw new hn({address:o});if(r||i)throw new Mt("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");if(n&&n>2n**256n-1n)throw new Bi({maxFeePerGas:n})}(e);const f=$i(c),h=[nr(r),o?nr(o):"0x",u?nr(u):"0x",n?nr(n):"0x",s??"0x",a?nr(a):"0x",i??"0x",f,...Ui(e,t)];return qn(["0x01",bi(h)])}(e,t):"eip4844"===r?function(e,t){const{chainId:r,gas:n,nonce:i,to:o,value:s,maxFeePerBlobGas:a,maxFeePerGas:c,maxPriorityFeePerGas:u,accessList:f,data:h}=e;!function(e){const{blobVersionedHashes:t}=e;if(t){if(0===t.length)throw new ci;for(const e of t){const t=Jt(e),r=tr(Ai(e,0,1));if(32!==t)throw new ui({hash:e,size:t});if(r!==si)throw new fi({hash:e,version:r})}}Oi(e)}(e);let l=e.blobVersionedHashes,d=e.sidecars;if(e.blobs){const t="string"==typeof e.blobs[0]?e.blobs:e.blobs.map((e=>or(e))),r=e.kzg,n=Qn({blobs:t,kzg:r}),i=ei({blobs:t,commitments:n,kzg:r});l=function(e){const{commitments:t,version:r}=e,n=e.to??("string"==typeof t[0]?"hex":"bytes"),i=[];for(const e of t)i.push(ti({commitment:e,to:n,version:r}));return i}({commitments:n}),!1!==d&&(d=yi({blobs:t,commitments:n,proofs:i}))}const p=$i(f),g=[nr(r),i?nr(i):"0x",u?nr(u):"0x",c?nr(c):"0x",n?nr(n):"0x",o??"0x",s?nr(s):"0x",h??"0x",p,a?nr(a):"0x",l??[],...Ui(e,t)],y=[],w=[],b=[];if(d)for(let e=0;e<d.length;e++){const{blob:t,commitment:r,proof:n}=d[e];y.push(t),w.push(r),b.push(n)}return qn(["0x03",bi(d?[g,y,w,b]:g)])}(e,t):function(e,t){const{chainId:r=0,gas:n,data:i,nonce:o,to:s,value:a,gasPrice:c}=e;!function(e){const{chainId:t,maxPriorityFeePerGas:r,gasPrice:n,maxFeePerGas:i,to:o,accessList:s}=e;if(o&&!Cn(o))throw new hn({address:o});if(void 0!==t&&t<=0)throw new Ei({chainId:t});if(r||i)throw new Mt("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");if(n&&n>2n**256n-1n)throw new Bi({maxFeePerGas:n});if(s)throw new Mt("`accessList` is not a valid Legacy Transaction attribute.")}(e);let u=[o?nr(o):"0x",c?nr(c):"0x",n?nr(n):"0x",s??"0x",a?nr(a):"0x",i??"0x"];if(t){const e=(()=>{if(t.v>=35n){return(t.v-35n)/2n>0?t.v:27n+(35n===t.v?0n:1n)}if(r>0)return BigInt(2*r)+BigInt(35n+t.v-27n);const e=27n+(27n===t.v?0n:1n);if(t.v!==e)throw new Yn({v:t.v});return e})();u=[...u,nr(e),t.r,t.s]}else r>0&&(u=[...u,nr(r),"0x","0x"]);return bi(u)}(e,t)}function Ui(e,t){const{r,s:n,v:i,yParity:o}=t??e;if(void 0===r)return[];if(void 0===n)return[];if(void 0===i&&void 0===o)return[];return["number"==typeof o?o?nr(1):"0x":0n===i?"0x":1n===i?nr(1):27n===i?"0x":nr(1),wi(r),wi(n)]}class Li extends Mt{constructor({expectedLength:e,givenLength:t,type:r}){super([`ABI encoding array length mismatch for type ${r}.`,`Expected length: ${e}`,`Given length: ${t}`].join("\n")),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiEncodingArrayLengthMismatchError"})}}class Ri extends Mt{constructor({expectedSize:e,value:t}){super(`Size of bytes "${t}" (bytes${Jt(t)}) does not match expected size (bytes${e}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiEncodingBytesSizeMismatchError"})}}class Ni extends Mt{constructor({expectedLength:e,givenLength:t}){super(["ABI encoding params/values length mismatch.",`Expected length (params): ${e}`,`Given length (values): ${t}`].join("\n")),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiEncodingLengthMismatchError"})}}class Fi extends Mt{constructor({expectedSize:e,givenSize:t}){super(`Expected bytes${e}, got bytes${t}.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BytesSizeMismatchError"})}}class Ti extends Mt{constructor(e,{docsPath:t}){super([`Type "${e}" is not a valid encoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:t}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiEncodingType"})}}class Ki extends Mt{constructor(e){super([`Value "${e}" is not a valid array.`].join("\n")),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidArrayError"})}}function Hi(e,t){if(e.length!==t.length)throw new Ni({expectedLength:e.length,givenLength:t.length});const r=function({params:e,values:t}){const r=[];for(let n=0;n<e.length;n++)r.push(Ci({param:e[n],value:t[n]}));return r}({params:e,values:t}),n=ji(r);return 0===n.length?"0x":n}function Ci({param:e,value:t}){const r=function(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}(e.type);if(r){const[n,i]=r;return function(e,{length:t,param:r}){const n=null===t;if(!Array.isArray(e))throw new Ki(e);if(!n&&e.length!==t)throw new Li({expectedLength:t,givenLength:e.length,type:`${r.type}[${t}]`});let i=!1;const o=[];for(let t=0;t<e.length;t++){const n=Ci({param:r,value:e[t]});n.dynamic&&(i=!0),o.push(n)}if(n||i){const e=ji(o);if(n){const t=sr(o.length,{size:32});return{dynamic:!0,encoded:o.length>0?kn([t,e]):t}}if(i)return{dynamic:!0,encoded:e}}return{dynamic:!1,encoded:kn(o.map((({encoded:e})=>e)))}}(t,{length:n,param:{...e,type:i}})}if("tuple"===e.type)return function(e,{param:t}){let r=!1;const n=[];for(let i=0;i<t.components.length;i++){const o=t.components[i],s=Ci({param:o,value:e[Array.isArray(e)?i:o.name]});n.push(s),s.dynamic&&(r=!0)}return{dynamic:r,encoded:r?ji(n):kn(n.map((({encoded:e})=>e)))}}(t,{param:e});if("address"===e.type)return function(e){if(!Cn(e))throw new hn({address:e});return{dynamic:!1,encoded:Yt(e.toLowerCase())}}(t);if("bool"===e.type)return function(e){if("boolean"!=typeof e)throw new Mt(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:Yt(ir(e))}}(t);if(e.type.startsWith("uint")||e.type.startsWith("int")){return function(e,{signed:t}){return{dynamic:!1,encoded:sr(e,{size:32,signed:t})}}(t,{signed:e.type.startsWith("int")})}if(e.type.startsWith("bytes"))return function(e,{param:t}){const[,r]=t.type.split("bytes"),n=Jt(e);if(!r){let t=e;return n%32!=0&&(t=Yt(t,{dir:"right",size:32*Math.ceil((e.length-2)/2/32)})),{dynamic:!0,encoded:kn([Yt(sr(n,{size:32})),t])}}if(n!==parseInt(r))throw new Ri({expectedSize:parseInt(r),value:e});return{dynamic:!1,encoded:Yt(e,{dir:"right"})}}(t,{param:e});if("string"===e.type)return function(e){const t=cr(e),r=Math.ceil(Jt(t)/32),n=[];for(let e=0;e<r;e++)n.push(Yt(Ai(t,32*e,32*(e+1)),{dir:"right"}));return{dynamic:!0,encoded:kn([Yt(sr(Jt(t),{size:32})),...n])}}(t);throw new Ti(e.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function ji(e){let t=0;for(let r=0;r<e.length;r++){const{dynamic:n,encoded:i}=e[r];t+=n?32:Jt(i)}const r=[],n=[];let i=0;for(let o=0;o<e.length;o++){const{dynamic:s,encoded:a}=e[o];s?(r.push(sr(t+i,{size:32})),n.push(a),i+=Jt(a)):r.push(a)}return kn([...r,...n])}const ki=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,qi=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;function Mi({domain:e}){return["string"==typeof e?.name&&{name:"name",type:"string"},e?.version&&{name:"version",type:"string"},"number"==typeof e?.chainId&&{name:"chainId",type:"uint256"},e?.verifyingContract&&{name:"verifyingContract",type:"address"},e?.salt&&{name:"salt",type:"bytes32"}].filter(Boolean)}function Vi(e){const{domain:t={},message:r,primaryType:n}=e,i={EIP712Domain:Mi({domain:t}),...e.types};!function(e){const{domain:t,message:r,primaryType:n,types:i}=e,o=(e,t)=>{for(const r of e){const{name:e,type:n}=r,s=t[e],a=n.match(qi);if(a&&("number"==typeof s||"bigint"==typeof s)){const[e,t,r]=a;sr(s,{signed:"int"===t,size:parseInt(r)/8})}if("address"===n&&"string"==typeof s&&!Cn(s))throw new hn({address:s});const c=n.match(ki);if(c){const[e,t]=c;if(t&&Jt(s)!==parseInt(t))throw new Fi({expectedSize:parseInt(t),givenSize:Jt(s)})}const u=i[n];u&&o(u,s)}};if(i.EIP712Domain&&t&&o(i.EIP712Domain,t),"EIP712Domain"!==n){const e=i[n];o(e,r)}}({domain:t,message:r,primaryType:n,types:i});const o=["0x1901"];return t&&o.push(function({domain:e,types:t}){return Di({data:e,primaryType:"EIP712Domain",types:t})}({domain:t,types:i})),"EIP712Domain"!==n&&o.push(Di({data:r,primaryType:n,types:i})),Fn(kn(o))}function Di({data:e,primaryType:t,types:r}){return Fn(Gi({data:e,primaryType:t,types:r}))}function Gi({data:e,primaryType:t,types:r}){const n=[{type:"bytes32"}],i=[Zi({primaryType:t,types:r})];for(const o of r[t]){const[t,s]=Wi({types:r,name:o.name,type:o.type,value:e[o.name]});n.push(t),i.push(s)}return Hi(n,i)}function Zi({primaryType:e,types:t}){const r=nr(function({primaryType:e,types:t}){let r="";const n=_i({primaryType:e,types:t});n.delete(e);const i=[e,...Array.from(n).sort()];for(const e of i)r+=`${e}(${t[e].map((({name:e,type:t})=>`${t} ${e}`)).join(",")})`;return r}({primaryType:e,types:t}));return Fn(r)}function _i({primaryType:e,types:t},r=new Set){const n=e.match(/^\w*/u)?.[0];if(r.has(n)||void 0===t[n])return r;r.add(n);for(const e of t[n])_i({primaryType:e.type,types:t},r);return r}function Wi({types:e,name:t,type:r,value:n}){if(void 0!==e[r])return[{type:"bytes32"},Fn(Gi({data:n,primaryType:r,types:e}))];if("bytes"===r){return[{type:"bytes32"},Fn(n=`0x${(n.length%2?"0":"")+n.slice(2)}`)]}if("string"===r)return[{type:"bytes32"},Fn(nr(n))];if(r.lastIndexOf("]")===r.length-1){const i=r.slice(0,r.lastIndexOf("[")),o=n.map((r=>Wi({name:t,type:i,types:e,value:r})));return[{type:"bytes32"},Fn(Hi(o.map((([e])=>e)),o.map((([,e])=>e))))]}return[{type:r},n]}function Yi(e){const t=nr(fn.getPublicKey(e.slice(2),!1)),r=function(e){return Tn(`0x${Fn(`0x${e.substring(4)}`).substring(26)}`)}(t),n=function(e){if("string"==typeof e){if(!Cn(e,{strict:!1}))throw new hn({address:e});return{address:e,type:"json-rpc"}}if(!Cn(e.address,{strict:!1}))throw new hn({address:e.address});return{address:e.address,signMessage:e.signMessage,signTransaction:e.signTransaction,signTypedData:e.signTypedData,source:"custom",type:"local"}}({address:r,signMessage:async({message:t})=>async function({message:e,privateKey:t}){return Vn(await Dn({hash:Mn(e),privateKey:t}))}({message:t,privateKey:e}),signTransaction:async(t,{serializer:r}={})=>async function(e){const{privateKey:t,transaction:r,serializer:n=zi}=e,i="eip4844"===r.type?{...r,sidecars:!1}:r,o=await Dn({hash:Fn(n(i)),privateKey:t});return n(r,o)}({privateKey:e,transaction:t,serializer:r}),signTypedData:async t=>async function(e){const{privateKey:t,...r}=e;return Vn(await Dn({hash:Vi(r),privateKey:t}))}({...t,privateKey:e})});return{...n,publicKey:t,source:"privateKey"}}function Xi(e,t={}){const r=qt(e);return function(e,{accountIndex:t=0,addressIndex:r=0,changeIndex:n=0,path:i}={}){const o=e.derive(i||`m/44'/60'/${t}'/${n}/${r}`);return{...Yi(nr(o.privateKey)),getHdKey:()=>o,source:"hd"}}(Tt.fromMasterSeed(r),t)}var Ji,Qi;window.onDataCallback=(Ji=regeneratorRuntime.mark((function e(t,r){var n,i,o;return regeneratorRuntime.wrap((function(e){for(;;)switch(e.prev=e.next){case 0:return e.prev=0,n=Xi(r),e.next=1,n.signMessage({message:t});case 1:i=e.sent,window.ReactNativeWebView.postMessage(JSON.stringify({result:"success",signature:i})),e.next=3;break;case 2:e.prev=2,o=e.catch(0),window.ReactNativeWebView.postMessage(JSON.stringify({result:"failure",error:o.message}));case 3:case"end":return e.stop()}}),e,null,[[0,2]])})),Qi=function(){var e=this,t=arguments;return new Promise((function(r,i){var o=Ji.apply(e,t);function s(e){n(o,r,i,s,a,"next",e)}function a(e){n(o,r,i,s,a,"throw",e)}s(void 0)}))},function(e,t){return Qi.apply(this,arguments)})})();