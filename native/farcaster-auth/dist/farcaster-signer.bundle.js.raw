/*! For license information please see farcaster-signer.bundle.js.raw.LICENSE.txt */
(()=>{"use strict";var e={d:(t,r)=>{for(var n in r)e.o(r,n)&&!e.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:r[n]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{OG:()=>we,My:()=>ce,Ph:()=>he,lX:()=>le,Id:()=>ye,fg:()=>xe,qj:()=>ge,aT:()=>fe,lq:()=>de,z:()=>pe,Q5:()=>ve});var r={};function n(e){if(!Number.isSafeInteger(e)||e<0)throw new Error(`Wrong positive integer: ${e}`)}function i(e,...t){if(!(e instanceof Uint8Array))throw new Error("Expected Uint8Array");if(t.length>0&&!t.includes(e.length))throw new Error(`Expected Uint8Array of length ${t}, not of length=${e.length}`)}function o(e){if("function"!=typeof e||"function"!=typeof e.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");n(e.outputLen),n(e.blockLen)}function s(e,t=!0){if(e.destroyed)throw new Error("Hash instance has been destroyed");if(t&&e.finished)throw new Error("Hash#digest() has already been called")}function a(e,t){i(e);const r=t.outputLen;if(e.length<r)throw new Error(`digestInto() expects output buffer of length at least ${r}`)}e.r(r),e.d(r,{OG:()=>Er,My:()=>lr,Ph:()=>gr,lX:()=>yr,Id:()=>xr,fg:()=>Ir,qj:()=>mr,aT:()=>pr,lq:()=>wr,z:()=>br,Q5:()=>Sr});const c="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0,u=e=>e instanceof Uint8Array,f=e=>new DataView(e.buffer,e.byteOffset,e.byteLength),h=(e,t)=>e<<32-t|e>>>t;if(!(68===new Uint8Array(new Uint32Array([287454020]).buffer)[0]))throw new Error("Non little-endian hardware is not supported");const l=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function d(e){if("string"!=typeof e)throw new Error("utf8ToBytes expected string, got "+typeof e);return new Uint8Array((new TextEncoder).encode(e))}function p(e){if("string"==typeof e&&(e=d(e)),!u(e))throw new Error("expected Uint8Array, got "+typeof e);return e}function g(...e){const t=new Uint8Array(e.reduce(((e,t)=>e+t.length),0));let r=0;return e.forEach((e=>{if(!u(e))throw new Error("Uint8Array expected");t.set(e,r),r+=e.length})),t}class y{clone(){return this._cloneInto()}}const w={}.toString;function b(e){const t=t=>e().update(p(t)).digest(),r=e();return t.outputLen=r.outputLen,t.blockLen=r.blockLen,t.create=()=>e(),t}function m(e=32){if(c&&"function"==typeof c.getRandomValues)return c.getRandomValues(new Uint8Array(e));throw new Error("crypto.getRandomValues must be defined")}class x extends y{constructor(e,t){super(),this.finished=!1,this.destroyed=!1,o(e);const r=p(t);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,i=new Uint8Array(n);i.set(r.length>n?e.create().update(r).digest():r);for(let e=0;e<i.length;e++)i[e]^=54;this.iHash.update(i),this.oHash=e.create();for(let e=0;e<i.length;e++)i[e]^=106;this.oHash.update(i),i.fill(0)}update(e){return s(this),this.iHash.update(e),this}digestInto(e){s(this),i(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:t,iHash:r,finished:n,destroyed:i,blockLen:o,outputLen:s}=this;return e.finished=n,e.destroyed=i,e.blockLen=o,e.outputLen=s,e.oHash=t._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const E=(e,t,r)=>new x(e,t).update(r).digest();E.create=(e,t)=>new x(e,t);class v extends y{constructor(e,t,r,n){super(),this.blockLen=e,this.outputLen=t,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=f(this.buffer)}update(e){s(this);const{view:t,buffer:r,blockLen:n}=this,i=(e=p(e)).length;for(let o=0;o<i;){const s=Math.min(n-this.pos,i-o);if(s!==n)r.set(e.subarray(o,o+s),this.pos),this.pos+=s,o+=s,this.pos===n&&(this.process(t,0),this.pos=0);else{const t=f(e);for(;n<=i-o;o+=n)this.process(t,o)}}return this.length+=e.length,this.roundClean(),this}digestInto(e){s(this),a(e,this),this.finished=!0;const{buffer:t,view:r,blockLen:n,isLE:i}=this;let{pos:o}=this;t[o++]=128,this.buffer.subarray(o).fill(0),this.padOffset>n-o&&(this.process(r,0),o=0);for(let e=o;e<n;e++)t[e]=0;!function(e,t,r,n){if("function"==typeof e.setBigUint64)return e.setBigUint64(t,r,n);const i=BigInt(32),o=BigInt(4294967295),s=Number(r>>i&o),a=Number(r&o),c=n?4:0,u=n?0:4;e.setUint32(t+c,s,n),e.setUint32(t+u,a,n)}(r,n-8,BigInt(8*this.length),i),this.process(r,0);const c=f(e),u=this.outputLen;if(u%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=u/4,l=this.get();if(h>l.length)throw new Error("_sha2: outputLen bigger than state");for(let e=0;e<h;e++)c.setUint32(4*e,l[e],i)}digest(){const{buffer:e,outputLen:t}=this;this.digestInto(e);const r=e.slice(0,t);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:t,buffer:r,length:n,finished:i,destroyed:o,pos:s}=this;return e.length=n,e.pos=s,e.finished=i,e.destroyed=o,n%t&&e.buffer.set(r),e}}const B=new Uint8Array([7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8]),I=Uint8Array.from({length:16},((e,t)=>t));let A=[I],S=[I.map((e=>(9*e+5)%16))];for(let e=0;e<4;e++)for(let t of[A,S])t.push(t[e].map((e=>B[e])));const P=[[11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8],[12,13,11,15,6,9,9,7,12,15,11,13,7,8,7,7],[13,15,14,11,7,7,6,8,13,14,13,12,5,5,6,9],[14,11,12,14,8,6,5,5,15,12,15,14,9,9,8,6],[15,12,13,13,9,5,8,6,14,11,12,11,8,6,5,5]].map((e=>new Uint8Array(e))),O=A.map(((e,t)=>e.map((e=>P[t][e])))),$=S.map(((e,t)=>e.map((e=>P[t][e])))),z=new Uint32Array([0,1518500249,1859775393,2400959708,2840853838]),U=new Uint32Array([1352829926,1548603684,1836072691,2053994217,0]),L=(e,t)=>e<<t|e>>>32-t;function R(e,t,r,n){return 0===e?t^r^n:1===e?t&r|~t&n:2===e?(t|~r)^n:3===e?t&n|r&~n:t^(r|~n)}const N=new Uint32Array(16);class F extends v{constructor(){super(64,20,8,!0),this.h0=1732584193,this.h1=-271733879,this.h2=-1732584194,this.h3=271733878,this.h4=-1009589776}get(){const{h0:e,h1:t,h2:r,h3:n,h4:i}=this;return[e,t,r,n,i]}set(e,t,r,n,i){this.h0=0|e,this.h1=0|t,this.h2=0|r,this.h3=0|n,this.h4=0|i}process(e,t){for(let r=0;r<16;r++,t+=4)N[r]=e.getUint32(t,!0);let r=0|this.h0,n=r,i=0|this.h1,o=i,s=0|this.h2,a=s,c=0|this.h3,u=c,f=0|this.h4,h=f;for(let e=0;e<5;e++){const t=4-e,l=z[e],d=U[e],p=A[e],g=S[e],y=O[e],w=$[e];for(let t=0;t<16;t++){const n=L(r+R(e,i,s,c)+N[p[t]]+l,y[t])+f|0;r=f,f=c,c=0|L(s,10),s=i,i=n}for(let e=0;e<16;e++){const r=L(n+R(t,o,a,u)+N[g[e]]+d,w[e])+h|0;n=h,h=u,u=0|L(a,10),a=o,o=r}}this.set(this.h1+s+u|0,this.h2+c+h|0,this.h3+f+n|0,this.h4+r+o|0,this.h0+i+a|0)}roundClean(){N.fill(0)}destroy(){this.destroyed=!0,this.buffer.fill(0),this.set(0,0,0,0,0)}}const T=b((()=>new F)),K=(e,t,r)=>e&t^e&r^t&r,H=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),C=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),j=new Uint32Array(64);class k extends v{constructor(){super(64,32,8,!1),this.A=0|C[0],this.B=0|C[1],this.C=0|C[2],this.D=0|C[3],this.E=0|C[4],this.F=0|C[5],this.G=0|C[6],this.H=0|C[7]}get(){const{A:e,B:t,C:r,D:n,E:i,F:o,G:s,H:a}=this;return[e,t,r,n,i,o,s,a]}set(e,t,r,n,i,o,s,a){this.A=0|e,this.B=0|t,this.C=0|r,this.D=0|n,this.E=0|i,this.F=0|o,this.G=0|s,this.H=0|a}process(e,t){for(let r=0;r<16;r++,t+=4)j[r]=e.getUint32(t,!1);for(let e=16;e<64;e++){const t=j[e-15],r=j[e-2],n=h(t,7)^h(t,18)^t>>>3,i=h(r,17)^h(r,19)^r>>>10;j[e]=i+j[e-7]+n+j[e-16]|0}let{A:r,B:n,C:i,D:o,E:s,F:a,G:c,H:u}=this;for(let e=0;e<64;e++){const t=u+(h(s,6)^h(s,11)^h(s,25))+((f=s)&a^~f&c)+H[e]+j[e]|0,l=(h(r,2)^h(r,13)^h(r,22))+K(r,n,i)|0;u=c,c=a,a=s,s=o+t|0,o=i,i=n,n=r,r=t+l|0}var f;r=r+this.A|0,n=n+this.B|0,i=i+this.C|0,o=o+this.D|0,s=s+this.E|0,a=a+this.F|0,c=c+this.G|0,u=u+this.H|0,this.set(r,n,i,o,s,a,c,u)}roundClean(){j.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const q=b((()=>new k)),M=BigInt(2**32-1),V=BigInt(32);function D(e,t=!1){return t?{h:Number(e&M),l:Number(e>>V&M)}:{h:0|Number(e>>V&M),l:0|Number(e&M)}}function G(e,t=!1){let r=new Uint32Array(e.length),n=new Uint32Array(e.length);for(let i=0;i<e.length;i++){const{h:o,l:s}=D(e[i],t);[r[i],n[i]]=[o,s]}return[r,n]}const Z=(e,t,r)=>e<<r|t>>>32-r,_=(e,t,r)=>t<<r|e>>>32-r,W=(e,t,r)=>t<<r-32|e>>>64-r,Y=(e,t,r)=>e<<r-32|t>>>64-r;const X={fromBig:D,split:G,toBig:(e,t)=>BigInt(e>>>0)<<V|BigInt(t>>>0),shrSH:(e,t,r)=>e>>>r,shrSL:(e,t,r)=>e<<32-r|t>>>r,rotrSH:(e,t,r)=>e>>>r|t<<32-r,rotrSL:(e,t,r)=>e<<32-r|t>>>r,rotrBH:(e,t,r)=>e<<64-r|t>>>r-32,rotrBL:(e,t,r)=>e>>>r-32|t<<64-r,rotr32H:(e,t)=>t,rotr32L:(e,t)=>e,rotlSH:Z,rotlSL:_,rotlBH:W,rotlBL:Y,add:function(e,t,r,n){const i=(t>>>0)+(n>>>0);return{h:e+r+(i/2**32|0)|0,l:0|i}},add3L:(e,t,r)=>(e>>>0)+(t>>>0)+(r>>>0),add3H:(e,t,r,n)=>t+r+n+(e/2**32|0)|0,add4L:(e,t,r,n)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0),add4H:(e,t,r,n,i)=>t+r+n+i+(e/2**32|0)|0,add5H:(e,t,r,n,i,o)=>t+r+n+i+o+(e/2**32|0)|0,add5L:(e,t,r,n,i)=>(e>>>0)+(t>>>0)+(r>>>0)+(n>>>0)+(i>>>0)},[J,Q]=(()=>X.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((e=>BigInt(e)))))(),ee=new Uint32Array(80),te=new Uint32Array(80);class re extends v{constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}get(){const{Ah:e,Al:t,Bh:r,Bl:n,Ch:i,Cl:o,Dh:s,Dl:a,Eh:c,El:u,Fh:f,Fl:h,Gh:l,Gl:d,Hh:p,Hl:g}=this;return[e,t,r,n,i,o,s,a,c,u,f,h,l,d,p,g]}set(e,t,r,n,i,o,s,a,c,u,f,h,l,d,p,g){this.Ah=0|e,this.Al=0|t,this.Bh=0|r,this.Bl=0|n,this.Ch=0|i,this.Cl=0|o,this.Dh=0|s,this.Dl=0|a,this.Eh=0|c,this.El=0|u,this.Fh=0|f,this.Fl=0|h,this.Gh=0|l,this.Gl=0|d,this.Hh=0|p,this.Hl=0|g}process(e,t){for(let r=0;r<16;r++,t+=4)ee[r]=e.getUint32(t),te[r]=e.getUint32(t+=4);for(let e=16;e<80;e++){const t=0|ee[e-15],r=0|te[e-15],n=X.rotrSH(t,r,1)^X.rotrSH(t,r,8)^X.shrSH(t,r,7),i=X.rotrSL(t,r,1)^X.rotrSL(t,r,8)^X.shrSL(t,r,7),o=0|ee[e-2],s=0|te[e-2],a=X.rotrSH(o,s,19)^X.rotrBH(o,s,61)^X.shrSH(o,s,6),c=X.rotrSL(o,s,19)^X.rotrBL(o,s,61)^X.shrSL(o,s,6),u=X.add4L(i,c,te[e-7],te[e-16]),f=X.add4H(u,n,a,ee[e-7],ee[e-16]);ee[e]=0|f,te[e]=0|u}let{Ah:r,Al:n,Bh:i,Bl:o,Ch:s,Cl:a,Dh:c,Dl:u,Eh:f,El:h,Fh:l,Fl:d,Gh:p,Gl:g,Hh:y,Hl:w}=this;for(let e=0;e<80;e++){const t=X.rotrSH(f,h,14)^X.rotrSH(f,h,18)^X.rotrBH(f,h,41),b=X.rotrSL(f,h,14)^X.rotrSL(f,h,18)^X.rotrBL(f,h,41),m=f&l^~f&p,x=h&d^~h&g,E=X.add5L(w,b,x,Q[e],te[e]),v=X.add5H(E,y,t,m,J[e],ee[e]),B=0|E,I=X.rotrSH(r,n,28)^X.rotrBH(r,n,34)^X.rotrBH(r,n,39),A=X.rotrSL(r,n,28)^X.rotrBL(r,n,34)^X.rotrBL(r,n,39),S=r&i^r&s^i&s,P=n&o^n&a^o&a;y=0|p,w=0|g,p=0|l,g=0|d,l=0|f,d=0|h,({h:f,l:h}=X.add(0|c,0|u,0|v,0|B)),c=0|s,u=0|a,s=0|i,a=0|o,i=0|r,o=0|n;const O=X.add3L(B,A,P);r=X.add3H(O,v,I,S),n=0|O}({h:r,l:n}=X.add(0|this.Ah,0|this.Al,0|r,0|n)),({h:i,l:o}=X.add(0|this.Bh,0|this.Bl,0|i,0|o)),({h:s,l:a}=X.add(0|this.Ch,0|this.Cl,0|s,0|a)),({h:c,l:u}=X.add(0|this.Dh,0|this.Dl,0|c,0|u)),({h:f,l:h}=X.add(0|this.Eh,0|this.El,0|f,0|h)),({h:l,l:d}=X.add(0|this.Fh,0|this.Fl,0|l,0|d)),({h:p,l:g}=X.add(0|this.Gh,0|this.Gl,0|p,0|g)),({h:y,l:w}=X.add(0|this.Hh,0|this.Hl,0|y,0|w)),this.set(r,n,i,o,s,a,c,u,f,h,l,d,p,g,y,w)}roundClean(){ee.fill(0),te.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const ne=b((()=>new re)),ie=(BigInt(0),BigInt(1)),oe=BigInt(2),se=e=>e instanceof Uint8Array,ae=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function ce(e){if(!se(e))throw new Error("Uint8Array expected");let t="";for(let r=0;r<e.length;r++)t+=ae[e[r]];return t}function ue(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}function fe(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let t=0;t<r.length;t++){const n=2*t,i=e.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[t]=o}return r}function he(e){return ue(ce(e))}function le(e){if(!se(e))throw new Error("Uint8Array expected");return ue(ce(Uint8Array.from(e).reverse()))}function de(e,t){return fe(e.toString(16).padStart(2*t,"0"))}function pe(e,t){return de(e,t).reverse()}function ge(e,t,r){let n;if("string"==typeof t)try{n=fe(t)}catch(r){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${r}`)}else{if(!se(t))throw new Error(`${e} must be hex string or Uint8Array`);n=Uint8Array.from(t)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(`${e} expected ${r} bytes, got ${i}`);return n}function ye(...e){const t=new Uint8Array(e.reduce(((e,t)=>e+t.length),0));let r=0;return e.forEach((e=>{if(!se(e))throw new Error("Uint8Array expected");t.set(e,r),r+=e.length})),t}const we=e=>(oe<<BigInt(e-1))-ie,be=e=>new Uint8Array(e),me=e=>Uint8Array.from(e);function xe(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=be(e),i=be(e),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},a=(...e)=>r(i,n,...e),c=(e=be())=>{i=a(me([0]),e),n=a(),0!==e.length&&(i=a(me([1]),e),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){n=a();const t=n.slice();r.push(t),e+=n.length}return ye(...r)};return(e,t)=>{let r;for(s(),c(e);!(r=t(u()));)c();return s(),r}}const Ee={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||e instanceof Uint8Array,isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function ve(e,t,r={}){const n=(t,r,n)=>{const i=Ee[r];if("function"!=typeof i)throw new Error(`Invalid validator "${r}", expected function`);const o=e[t];if(!(n&&void 0===o||i(o,e)))throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${r}`)};for(const[e,r]of Object.entries(t))n(e,r,!1);for(const[e,t]of Object.entries(r))n(e,t,!0);return e}const Be=BigInt(0),Ie=BigInt(1),Ae=BigInt(2),Se=BigInt(3),Pe=BigInt(4),Oe=BigInt(5),$e=BigInt(8);BigInt(9),BigInt(16);function ze(e,t){const r=e%t;return r>=Be?r:t+r}function Ue(e,t,r){if(r<=Be||t<Be)throw new Error("Expected power/modulo > 0");if(r===Ie)return Be;let n=Ie;for(;t>Be;)t&Ie&&(n=n*e%r),e=e*e%r,t>>=Ie;return n}function Le(e,t,r){let n=e;for(;t-- >Be;)n*=n,n%=r;return n}function Re(e,t){if(e===Be||t<=Be)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=ze(e,t),n=t,i=Be,o=Ie,s=Ie,a=Be;for(;r!==Be;){const e=n/r,t=n%r,c=i-s*e,u=o-a*e;n=r,r=t,i=s,o=a,s=c,a=u}if(n!==Ie)throw new Error("invert: does not exist");return ze(i,t)}function Ne(e){if(e%Pe===Se){const t=(e+Ie)/Pe;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}if(e%$e===Oe){const t=(e-Oe)/$e;return function(e,r){const n=e.mul(r,Ae),i=e.pow(n,t),o=e.mul(r,i),s=e.mul(e.mul(o,Ae),i),a=e.mul(o,e.sub(s,e.ONE));if(!e.eql(e.sqr(a),r))throw new Error("Cannot find square root");return a}}return function(e){const t=(e-Ie)/Ae;let r,n,i;for(r=e-Ie,n=0;r%Ae===Be;r/=Ae,n++);for(i=Ae;i<e&&Ue(i,t,e)!==e-Ie;i++);if(1===n){const t=(e+Ie)/Pe;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}const o=(r+Ie)/Ae;return function(e,s){if(e.pow(s,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let a=n,c=e.pow(e.mul(e.ONE,i),r),u=e.pow(s,o),f=e.pow(s,r);for(;!e.eql(f,e.ONE);){if(e.eql(f,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(f);t<a&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const r=e.pow(c,Ie<<BigInt(a-t-1));c=e.sqr(r),u=e.mul(u,r),f=e.mul(f,c),a=t}return u}}(e)}const Fe=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Te(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function Ke(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function He(e){const t=Ke(e);return t+Math.ceil(t/2)}const Ce=BigInt(0),je=BigInt(1);function ke(e){return ve(e.Fp,Fe.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),ve(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Te(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const{Ph:qe,aT:Me}=t,Ve={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=Ve;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const r=e[1],n=e.subarray(2,r+2);if(!r||n.length!==r)throw new t("Invalid signature integer: wrong length");if(128&n[0])throw new t("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:qe(n),l:e.subarray(r+2)}},toSig(e){const{Err:t}=Ve,r="string"==typeof e?Me(e):e;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new t("Invalid signature tag");if(r[1]!==n-2)throw new t("Invalid signature: incorrect length");const{d:i,l:o}=Ve._parseInt(r.subarray(2)),{d:s,l:a}=Ve._parseInt(o);if(a.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(e){const t=e=>8&Number.parseInt(e[0],16)?"00"+e:e,r=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},n=t(r(e.s)),i=t(r(e.r)),o=n.length/2,s=i.length/2,a=r(o),c=r(s);return`30${r(s+o+4)}02${c}${i}02${a}${n}`}},De=BigInt(0),Ge=BigInt(1),Ze=(BigInt(2),BigInt(3));BigInt(4);function _e(e){const t=function(e){const t=ke(e);ve(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=t;if(r){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:r}=t,n=t.toBytes||((e,t,n)=>{const i=t.toAffine();return ye(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),i=t.fromBytes||(e=>{const t=e.subarray(1);return{x:r.fromBytes(t.subarray(0,r.BYTES)),y:r.fromBytes(t.subarray(r.BYTES,2*r.BYTES))}});function o(e){const{a:n,b:i}=t,o=r.sqr(e),s=r.mul(o,e);return r.add(r.add(s,r.mul(e,n)),i)}if(!r.eql(r.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function s(e){return"bigint"==typeof e&&De<e&&e<t.n}function a(e){if(!s(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(e){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=t;if(r&&"bigint"!=typeof e){if(e instanceof Uint8Array&&(e=ce(e)),"string"!=typeof e||!r.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*n,"0")}let s;try{s="bigint"==typeof e?e:he(ge("private key",e,n))}catch(t){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof e}`)}return i&&(s=ze(s,o)),a(s),s}const u=new Map;function f(e){if(!(e instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(e,t,n){if(this.px=e,this.py=t,this.pz=n,null==e||!r.isValid(e))throw new Error("x required");if(null==t||!r.isValid(t))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!r.isValid(t)||!r.isValid(n))throw new Error("invalid affine point");if(e instanceof h)throw new Error("projective point not allowed");const i=e=>r.eql(e,r.ZERO);return i(t)&&i(n)?h.ZERO:new h(t,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(h.fromAffine)}static fromHex(e){const t=h.fromAffine(i(ge("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return h.BASE.multiply(c(e))}_setWindowSize(e){this._WINDOW_SIZE=e,u.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:n}=this.toAffine();if(!r.isValid(e)||!r.isValid(n))throw new Error("bad point: x or y not FE");const i=r.sqr(n),s=o(e);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(r.isOdd)return!r.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){f(e);const{px:t,py:n,pz:i}=this,{px:o,py:s,pz:a}=e,c=r.eql(r.mul(t,a),r.mul(o,i)),u=r.eql(r.mul(n,a),r.mul(s,i));return c&&u}negate(){return new h(this.px,r.neg(this.py),this.pz)}double(){const{a:e,b:n}=t,i=r.mul(n,Ze),{px:o,py:s,pz:a}=this;let c=r.ZERO,u=r.ZERO,f=r.ZERO,l=r.mul(o,o),d=r.mul(s,s),p=r.mul(a,a),g=r.mul(o,s);return g=r.add(g,g),f=r.mul(o,a),f=r.add(f,f),c=r.mul(e,f),u=r.mul(i,p),u=r.add(c,u),c=r.sub(d,u),u=r.add(d,u),u=r.mul(c,u),c=r.mul(g,c),f=r.mul(i,f),p=r.mul(e,p),g=r.sub(l,p),g=r.mul(e,g),g=r.add(g,f),f=r.add(l,l),l=r.add(f,l),l=r.add(l,p),l=r.mul(l,g),u=r.add(u,l),p=r.mul(s,a),p=r.add(p,p),l=r.mul(p,g),c=r.sub(c,l),f=r.mul(p,d),f=r.add(f,f),f=r.add(f,f),new h(c,u,f)}add(e){f(e);const{px:n,py:i,pz:o}=this,{px:s,py:a,pz:c}=e;let u=r.ZERO,l=r.ZERO,d=r.ZERO;const p=t.a,g=r.mul(t.b,Ze);let y=r.mul(n,s),w=r.mul(i,a),b=r.mul(o,c),m=r.add(n,i),x=r.add(s,a);m=r.mul(m,x),x=r.add(y,w),m=r.sub(m,x),x=r.add(n,o);let E=r.add(s,c);return x=r.mul(x,E),E=r.add(y,b),x=r.sub(x,E),E=r.add(i,o),u=r.add(a,c),E=r.mul(E,u),u=r.add(w,b),E=r.sub(E,u),d=r.mul(p,x),u=r.mul(g,b),d=r.add(u,d),u=r.sub(w,d),d=r.add(w,d),l=r.mul(u,d),w=r.add(y,y),w=r.add(w,y),b=r.mul(p,b),x=r.mul(g,x),w=r.add(w,b),b=r.sub(y,b),b=r.mul(p,b),x=r.add(x,b),y=r.mul(w,x),l=r.add(l,y),y=r.mul(E,x),u=r.mul(m,u),u=r.sub(u,y),y=r.mul(m,w),d=r.mul(E,d),d=r.add(d,y),new h(u,l,d)}subtract(e){return this.add(e.negate())}is0(){return this.equals(h.ZERO)}wNAF(e){return d.wNAFCached(this,u,e,(e=>{const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(h.fromAffine)}))}multiplyUnsafe(e){const n=h.ZERO;if(e===De)return n;if(a(e),e===Ge)return this;const{endo:i}=t;if(!i)return d.unsafeLadder(this,e);let{k1neg:o,k1:s,k2neg:c,k2:u}=i.splitScalar(e),f=n,l=n,p=this;for(;s>De||u>De;)s&Ge&&(f=f.add(p)),u&Ge&&(l=l.add(p)),p=p.double(),s>>=Ge,u>>=Ge;return o&&(f=f.negate()),c&&(l=l.negate()),l=new h(r.mul(l.px,i.beta),l.py,l.pz),f.add(l)}multiply(e){a(e);let n,i,o=e;const{endo:s}=t;if(s){const{k1neg:e,k1:t,k2neg:a,k2:c}=s.splitScalar(o);let{p:u,f}=this.wNAF(t),{p:l,f:p}=this.wNAF(c);u=d.constTimeNegate(e,u),l=d.constTimeNegate(a,l),l=new h(r.mul(l.px,s.beta),l.py,l.pz),n=u.add(l),i=f.add(p)}else{const{p:e,f:t}=this.wNAF(o);n=e,i=t}return h.normalizeZ([n,i])[0]}multiplyAndAddUnsafe(e,t,r){const n=h.BASE,i=(e,t)=>t!==De&&t!==Ge&&e.equals(n)?e.multiply(t):e.multiplyUnsafe(t),o=i(this,t).add(i(e,r));return o.is0()?void 0:o}toAffine(e){const{px:t,py:n,pz:i}=this,o=this.is0();null==e&&(e=o?r.ONE:r.inv(i));const s=r.mul(t,e),a=r.mul(n,e),c=r.mul(i,e);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:e,isTorsionFree:r}=t;if(e===Ge)return!0;if(r)return r(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:r}=t;return e===Ge?this:r?r(h,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),n(h,this,e)}toHex(e=!0){return ce(this.toRawBytes(e))}}h.BASE=new h(t.Gx,t.Gy,r.ONE),h.ZERO=new h(r.ZERO,r.ONE,r.ZERO);const l=t.nBitLength,d=function(e,t){const r=(e,t)=>{const r=t.negate();return e?r:t},n=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate:r,unsafeLadder(t,r){let n=e.ZERO,i=t;for(;r>Ce;)r&je&&(n=n.add(i)),i=i.double(),r>>=je;return n},precomputeWindow(e,t){const{windows:r,windowSize:i}=n(t),o=[];let s=e,a=s;for(let e=0;e<r;e++){a=s,o.push(a);for(let e=1;e<i;e++)a=a.add(s),o.push(a);s=a.double()}return o},wNAF(t,i,o){const{windows:s,windowSize:a}=n(t);let c=e.ZERO,u=e.BASE;const f=BigInt(2**t-1),h=2**t,l=BigInt(t);for(let e=0;e<s;e++){const t=e*a;let n=Number(o&f);o>>=l,n>a&&(n-=h,o+=je);const s=t,d=t+Math.abs(n)-1,p=e%2!=0,g=n<0;0===n?u=u.add(r(p,i[s])):c=c.add(r(g,i[d]))}return{p:c,f:u}},wNAFCached(e,t,r,n){const i=e._WINDOW_SIZE||1;let o=t.get(e);return o||(o=this.precomputeWindow(e,i),1!==i&&t.set(e,n(o))),this.wNAF(i,o,r)}}}(h,t.endo?Math.ceil(l/2):l);return{CURVE:t,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:s}}function We(e){const t=function(e){const t=ke(e);return ve(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:r,n}=t,i=r.BYTES+1,o=2*r.BYTES+1;function s(e){return ze(e,n)}function a(e){return Re(e,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:f,isWithinCurveOrder:h}=_e({...t,toBytes(e,t,n){const i=t.toAffine(),o=r.toBytes(i.x),s=ye;return n?s(Uint8Array.from([t.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(e){const t=e.length,n=e[0],s=e.subarray(1);if(t!==i||2!==n&&3!==n){if(t===o&&4===n){return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}{const e=he(s);if(!(De<(a=e)&&a<r.ORDER))throw new Error("Point is not on curve");const t=f(e);let i=r.sqrt(t);return 1==(1&n)!==((i&Ge)===Ge)&&(i=r.neg(i)),{x:e,y:i}}var a}}),l=e=>ce(de(e,t.nByteLength));function d(e){return e>n>>Ge}const p=(e,t,r)=>he(e.slice(t,r));class g{constructor(e,t,r){this.r=e,this.s=t,this.recovery=r,this.assertValidity()}static fromCompact(e){const r=t.nByteLength;return e=ge("compactSignature",e,2*r),new g(p(e,0,r),p(e,r,2*r))}static fromDER(e){const{r:t,s:r}=Ve.toSig(ge("DER",e));return new g(t,r)}assertValidity(){if(!h(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!h(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new g(this.r,this.s,e)}recoverPublicKey(e){const{r:n,s:i,recovery:o}=this,u=m(ge("msgHash",e));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const f=2===o||3===o?n+t.n:n;if(f>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=0==(1&o)?"02":"03",d=c.fromHex(h+l(f)),p=a(f),g=s(-u*p),y=s(i*p),w=c.BASE.multiplyAndAddUnsafe(d,g,y);if(!w)throw new Error("point at infinify");return w.assertValidity(),w}hasHighS(){return d(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return fe(this.toDERHex())}toDERHex(){return Ve.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return fe(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const y={isValidPrivateKey(e){try{return u(e),!0}catch(e){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const e=He(t.n);return function(e,t,r=!1){const n=e.length,i=Ke(t),o=He(t);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const s=ze(r?he(e):le(e),t-Ie)+Ie;return r?pe(s,i):de(s,i)}(t.randomBytes(e),t.n)},precompute:(e=8,t=c.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function w(e){const t=e instanceof Uint8Array,r="string"==typeof e,n=(t||r)&&e.length;return t?n===i||n===o:r?n===2*i||n===2*o:e instanceof c}const b=t.bits2int||function(e){const r=he(e),n=8*e.length-t.nBitLength;return n>0?r>>BigInt(n):r},m=t.bits2int_modN||function(e){return s(b(e))},x=we(t.nBitLength);function E(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(De<=e&&e<x))throw new Error(`bigint expected < 2^${t.nBitLength}`);return de(e,t.nByteLength)}function v(e,n,i=B){if(["recovered","canonical"].some((e=>e in i)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:f}=t;let{lowS:l,prehash:p,extraEntropy:y}=i;null==l&&(l=!0),e=ge("msgHash",e),p&&(e=ge("prehashed msgHash",o(e)));const w=m(e),x=u(n),v=[E(x),E(w)];if(null!=y){const e=!0===y?f(r.BYTES):y;v.push(ge("extraEntropy",e))}const I=ye(...v),A=w;return{seed:I,k2sig:function(e){const t=b(e);if(!h(t))return;const r=a(t),n=c.BASE.multiply(t).toAffine(),i=s(n.x);if(i===De)return;const o=s(r*s(A+i*x));if(o===De)return;let u=(n.x===i?0:2)|Number(n.y&Ge),f=o;return l&&d(o)&&(f=function(e){return d(e)?s(-e):e}(o),u^=1),new g(i,f,u)}}}const B={lowS:t.lowS,prehash:!1},I={lowS:t.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return c.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,r=!0){if(w(e))throw new Error("first arg must be private key");if(!w(t))throw new Error("second arg must be public key");return c.fromHex(t).multiply(u(e)).toRawBytes(r)},sign:function(e,r,n=B){const{seed:i,k2sig:o}=v(e,r,n),s=t;return xe(s.hash.outputLen,s.nByteLength,s.hmac)(i,o)},verify:function(e,r,n,i=I){const o=e;if(r=ge("msgHash",r),n=ge("publicKey",n),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:u,prehash:f}=i;let h,l;try{if("string"==typeof o||o instanceof Uint8Array)try{h=g.fromDER(o)}catch(e){if(!(e instanceof Ve.Err))throw e;h=g.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:e,s:t}=o;h=new g(e,t)}}l=c.fromHex(n)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(u&&h.hasHighS())return!1;f&&(r=t.hash(r));const{r:d,s:p}=h,y=m(r),w=a(p),b=s(y*w),x=s(d*w),E=c.BASE.multiplyAndAddUnsafe(l,b,x)?.toAffine();return!!E&&s(E.x)===d},ProjectivePoint:c,Signature:g,utils:y}}function Ye(e){return{hash:e,hmac:(t,...r)=>E(e,t,g(...r)),randomBytes:m}}const Xe=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),Je=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Qe=BigInt(1),et=BigInt(2),tt=(e,t)=>(e+t/et)/t;function rt(e){const t=Xe,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),u=e*e*e%t,f=u*u*e%t,h=Le(f,r,t)*f%t,l=Le(h,r,t)*f%t,d=Le(l,et,t)*u%t,p=Le(d,i,t)*d%t,g=Le(p,o,t)*p%t,y=Le(g,a,t)*g%t,w=Le(y,c,t)*y%t,b=Le(w,a,t)*g%t,m=Le(b,r,t)*f%t,x=Le(m,s,t)*p%t,E=Le(x,n,t)*u%t,v=Le(E,et,t);if(!nt.eql(nt.sqr(v),e))throw new Error("Cannot find square root");return v}const nt=function(e,t,r=!1,n={}){if(e<=Be)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:i,nByteLength:o}=Te(e,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=Ne(e),a=Object.freeze({ORDER:e,BITS:i,BYTES:o,MASK:we(i),ZERO:Be,ONE:Ie,create:t=>ze(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return Be<=t&&t<e},is0:e=>e===Be,isOdd:e=>(e&Ie)===Ie,neg:t=>ze(-t,e),eql:(e,t)=>e===t,sqr:t=>ze(t*t,e),add:(t,r)=>ze(t+r,e),sub:(t,r)=>ze(t-r,e),mul:(t,r)=>ze(t*r,e),pow:(e,t)=>function(e,t,r){if(r<Be)throw new Error("Expected power > 0");if(r===Be)return e.ONE;if(r===Ie)return t;let n=e.ONE,i=t;for(;r>Be;)r&Ie&&(n=e.mul(n,i)),i=e.sqr(i),r>>=Ie;return n}(a,e,t),div:(t,r)=>ze(t*Re(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>Re(t,e),sqrt:n.sqrt||(e=>s(a,e)),invertBatch:e=>function(e,t){const r=new Array(t.length),n=t.reduce(((t,n,i)=>e.is0(n)?t:(r[i]=t,e.mul(t,n))),e.ONE),i=e.inv(n);return t.reduceRight(((t,n,i)=>e.is0(n)?t:(r[i]=e.mul(t,r[i]),e.mul(t,n))),i),r}(a,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?pe(e,o):de(e,o),fromBytes:e=>{if(e.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`);return r?le(e):he(e)}});return Object.freeze(a)}(Xe,void 0,void 0,{sqrt:rt}),it=function(e,t){const r=t=>We({...e,...Ye(t)});return Object.freeze({...r(t),create:r})}({a:BigInt(0),b:BigInt(7),Fp:nt,n:Je,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=Je,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Qe*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),a=tt(o*e,t),c=tt(-n*e,t);let u=ze(e-a*r-c*i,t),f=ze(-a*n-c*o,t);const h=u>s,l=f>s;if(h&&(u=t-u),l&&(f=t-f),u>s||f>s)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:h,k1:u,k2neg:l,k2:f}}}},q);BigInt(0);it.ProjectivePoint;function ot(e){if(!Number.isSafeInteger(e))throw new Error(`Wrong integer: ${e}`)}function st(...e){const t=(e,t)=>r=>e(t(r));return{encode:Array.from(e).reverse().reduce(((e,r)=>e?t(e,r.encode):r.encode),void 0),decode:e.reduce(((e,r)=>e?t(e,r.decode):r.decode),void 0)}}function at(e){return{encode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("alphabet.encode input should be an array of numbers");return t.map((t=>{if(ot(t),t<0||t>=e.length)throw new Error(`Digit index outside alphabet: ${t} (alphabet: ${e.length})`);return e[t]}))},decode:t=>{if(!Array.isArray(t)||t.length&&"string"!=typeof t[0])throw new Error("alphabet.decode input should be array of strings");return t.map((t=>{if("string"!=typeof t)throw new Error(`alphabet.decode: not string element=${t}`);const r=e.indexOf(t);if(-1===r)throw new Error(`Unknown letter: "${t}". Allowed: ${e}`);return r}))}}}function ct(e=""){if("string"!=typeof e)throw new Error("join separator should be string");return{encode:t=>{if(!Array.isArray(t)||t.length&&"string"!=typeof t[0])throw new Error("join.encode input should be array of strings");for(let e of t)if("string"!=typeof e)throw new Error(`join.encode: non-string input=${e}`);return t.join(e)},decode:t=>{if("string"!=typeof t)throw new Error("join.decode input should be string");return t.split(e)}}}function ut(e,t="="){if(ot(e),"string"!=typeof t)throw new Error("padding chr should be string");return{encode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let e of r)if("string"!=typeof e)throw new Error(`padding.encode: non-string input=${e}`);for(;r.length*e%8;)r.push(t);return r},decode(r){if(!Array.isArray(r)||r.length&&"string"!=typeof r[0])throw new Error("padding.encode input should be array of strings");for(let e of r)if("string"!=typeof e)throw new Error(`padding.decode: non-string input=${e}`);let n=r.length;if(n*e%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;n>0&&r[n-1]===t;n--)if(!((n-1)*e%8))throw new Error("Invalid padding: string has too much padding");return r.slice(0,n)}}}function ft(e){if("function"!=typeof e)throw new Error("normalize fn should be function");return{encode:e=>e,decode:t=>e(t)}}function ht(e,t,r){if(t<2)throw new Error(`convertRadix: wrong from=${t}, base cannot be less than 2`);if(r<2)throw new Error(`convertRadix: wrong to=${r}, base cannot be less than 2`);if(!Array.isArray(e))throw new Error("convertRadix: data should be array");if(!e.length)return[];let n=0;const i=[],o=Array.from(e);for(o.forEach((e=>{if(ot(e),e<0||e>=t)throw new Error(`Wrong integer: ${e}`)}));;){let e=0,s=!0;for(let i=n;i<o.length;i++){const a=o[i],c=t*e+a;if(!Number.isSafeInteger(c)||t*e/t!==e||c-a!=t*e)throw new Error("convertRadix: carry overflow");e=c%r;const u=Math.floor(c/r);if(o[i]=u,!Number.isSafeInteger(u)||u*r+e!==c)throw new Error("convertRadix: carry overflow");s&&(u?s=!1:n=i)}if(i.push(e),s)break}for(let t=0;t<e.length-1&&0===e[t];t++)i.push(0);return i.reverse()}const lt=(e,t)=>t?lt(t,e%t):e,dt=(e,t)=>e+(t-lt(e,t));function pt(e,t,r,n){if(!Array.isArray(e))throw new Error("convertRadix2: data should be array");if(t<=0||t>32)throw new Error(`convertRadix2: wrong from=${t}`);if(r<=0||r>32)throw new Error(`convertRadix2: wrong to=${r}`);if(dt(t,r)>32)throw new Error(`convertRadix2: carry overflow from=${t} to=${r} carryBits=${dt(t,r)}`);let i=0,o=0;const s=2**r-1,a=[];for(const n of e){if(ot(n),n>=2**t)throw new Error(`convertRadix2: invalid data word=${n} from=${t}`);if(i=i<<t|n,o+t>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${t}`);for(o+=t;o>=r;o-=r)a.push((i>>o-r&s)>>>0);i&=2**o-1}if(i=i<<r-o&s,!n&&o>=t)throw new Error("Excess padding");if(!n&&i)throw new Error(`Non-zero padding: ${i}`);return n&&o>0&&a.push(i>>>0),a}function gt(e){return ot(e),{encode:t=>{if(!(t instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return ht(Array.from(t),256,e)},decode:t=>{if(!Array.isArray(t)||t.length&&"number"!=typeof t[0])throw new Error("radix.decode input should be array of strings");return Uint8Array.from(ht(t,e,256))}}}function yt(e,t=!1){if(ot(e),e<=0||e>32)throw new Error("radix2: bits should be in (0..32]");if(dt(8,e)>32||dt(e,8)>32)throw new Error("radix2: carry overflow");return{encode:r=>{if(!(r instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return pt(Array.from(r),8,e,!t)},decode:r=>{if(!Array.isArray(r)||r.length&&"number"!=typeof r[0])throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(pt(r,e,8,t))}}}function wt(e,t){if(ot(e),"function"!=typeof t)throw new Error("checksum fn should be function");return{encode(r){if(!(r instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const n=t(r).slice(0,e),i=new Uint8Array(r.length+e);return i.set(r),i.set(n,r.length),i},decode(r){if(!(r instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const n=r.slice(0,-e),i=t(n).slice(0,e),o=r.slice(-e);for(let t=0;t<e;t++)if(i[t]!==o[t])throw new Error("Invalid checksum");return n}}}const bt=st(yt(4),at("0123456789ABCDEF"),ct("")),mt=st(yt(5),at("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),ut(5),ct("")),xt=(yt(5),at("0123456789ABCDEFGHIJKLMNOPQRSTUV"),ut(5),ct(""),yt(5),at("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),ct(""),ft((e=>e.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),st(yt(6),at("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),ut(6),ct(""))),Et=st(yt(6),at("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),ut(6),ct("")),vt=(yt(6),at("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),ct(""),e=>st(gt(58),at(e),ct(""))),Bt=vt("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),It=[0,2,3,5,6,7,9,10,11],At={encode(e){let t="";for(let r=0;r<e.length;r+=8){const n=e.subarray(r,r+8);t+=Bt.encode(n).padStart(It[n.length],"1")}return t},decode(e){let t=[];for(let r=0;r<e.length;r+=11){const n=e.slice(r,r+11),i=It.indexOf(n.length),o=Bt.decode(n);for(let e=0;e<o.length-i;e++)if(0!==o[e])throw new Error("base58xmr: wrong padding");t=t.concat(Array.from(o.slice(o.length-i)))}return Uint8Array.from(t)}};at("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),ct("");const St={encode:e=>(new TextDecoder).decode(e),decode:e=>(new TextEncoder).encode(e)},Pt=(yt(4),at("0123456789abcdef"),ct(""),ft((e=>{if("string"!=typeof e||e.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof e} with length ${e.length}`);return e.toLowerCase()})),it.ProjectivePoint),Ot=(e=>st(wt(4,(t=>e(e(t)))),Bt))(q);function $t(e){return BigInt(`0x${function(e){if(!u(e))throw new Error("Uint8Array expected");let t="";for(let r=0;r<e.length;r++)t+=l[e[r]];return t}(e)}`)}function zt(e){return function(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let t=0;t<r.length;t++){const n=2*t,i=e.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[t]=o}return r}(e.toString(16).padStart(64,"0"))}const Ut=d("Bitcoin seed"),Lt={private:76066276,public:76067358},Rt=2147483648,Nt=e=>{if(!Number.isSafeInteger(e)||e<0||e>2**32-1)throw new Error(`Invalid number=${e}. Should be from 0 to 2 ** 32 - 1`);const t=new Uint8Array(4);return f(t).setUint32(0,e,!1),t};class Ft{get fingerprint(){if(!this.pubHash)throw new Error("No publicKey set!");return e=this.pubHash,f(e).getUint32(0,!1);var e}get identifier(){return this.pubHash}get pubKeyHash(){return this.pubHash}get privateKey(){return this.privKeyBytes||null}get publicKey(){return this.pubKey||null}get privateExtendedKey(){const e=this.privateKey;if(!e)throw new Error("No private key");return Ot.encode(this.serialize(this.versions.private,g(new Uint8Array([0]),e)))}get publicExtendedKey(){if(!this.pubKey)throw new Error("No public key");return Ot.encode(this.serialize(this.versions.public,this.pubKey))}static fromMasterSeed(e,t=Lt){if(i(e),8*e.length<128||8*e.length>512)throw new Error(`HDKey: wrong seed length=${e.length}. Should be between 128 and 512 bits; 256 bits is advised)`);const r=E(ne,Ut,e);return new Ft({versions:t,chainCode:r.slice(32),privateKey:r.slice(0,32)})}static fromExtendedKey(e,t=Lt){const r=Ot.decode(e),n=f(r),i=n.getUint32(0,!1),o={versions:t,depth:r[4],parentFingerprint:n.getUint32(5,!1),index:n.getUint32(9,!1),chainCode:r.slice(13,45)},s=r.slice(45),a=0===s[0];if(i!==t[a?"private":"public"])throw new Error("Version mismatch");return new Ft(a?{...o,privateKey:s.slice(1)}:{...o,publicKey:s})}static fromJSON(e){return Ft.fromExtendedKey(e.xpriv)}constructor(e){if(this.depth=0,this.index=0,this.chainCode=null,this.parentFingerprint=0,!e||"object"!=typeof e)throw new Error("HDKey.constructor must not be called directly");if(this.versions=e.versions||Lt,this.depth=e.depth||0,this.chainCode=e.chainCode,this.index=e.index||0,this.parentFingerprint=e.parentFingerprint||0,!this.depth&&(this.parentFingerprint||this.index))throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");if(e.publicKey&&e.privateKey)throw new Error("HDKey: publicKey and privateKey at same time.");if(e.privateKey){if(!it.utils.isValidPrivateKey(e.privateKey))throw new Error("Invalid private key");this.privKey="bigint"==typeof e.privateKey?e.privateKey:$t(e.privateKey),this.privKeyBytes=zt(this.privKey),this.pubKey=it.getPublicKey(e.privateKey,!0)}else{if(!e.publicKey)throw new Error("HDKey: no public or private key provided");this.pubKey=Pt.fromHex(e.publicKey).toRawBytes(!0)}var t;this.pubHash=(t=this.pubKey,T(q(t)))}derive(e){if(!/^[mM]'?/.test(e))throw new Error('Path must start with "m" or "M"');if(/^[mM]'?$/.test(e))return this;const t=e.replace(/^[mM]'?\//,"").split("/");let r=this;for(const e of t){const t=/^(\d+)('?)$/.exec(e),n=t&&t[1];if(!t||3!==t.length||"string"!=typeof n)throw new Error(`Invalid child index: ${e}`);let i=+n;if(!Number.isSafeInteger(i)||i>=Rt)throw new Error("Invalid index");"'"===t[2]&&(i+=Rt),r=r.deriveChild(i)}return r}deriveChild(e){if(!this.pubKey||!this.chainCode)throw new Error("No publicKey or chainCode set");let t=Nt(e);if(e>=Rt){const e=this.privateKey;if(!e)throw new Error("Could not derive hardened child key");t=g(new Uint8Array([0]),e,t)}else t=g(this.pubKey,t);const r=E(ne,this.chainCode,t),n=$t(r.slice(0,32)),i=r.slice(32);if(!it.utils.isValidPrivateKey(n))throw new Error("Tweak bigger than curve order");const o={versions:this.versions,chainCode:i,depth:this.depth+1,parentFingerprint:this.fingerprint,index:e};try{if(this.privateKey){const e=ze(this.privKey+n,it.CURVE.n);if(!it.utils.isValidPrivateKey(e))throw new Error("The tweak was out of range or the resulted private key is invalid");o.privateKey=e}else{const e=Pt.fromHex(this.pubKey).add(Pt.fromPrivateKey(n));if(e.equals(Pt.ZERO))throw new Error("The tweak was equal to negative P, which made the result key invalid");o.publicKey=e.toRawBytes(!0)}return new Ft(o)}catch(t){return this.deriveChild(e+1)}}sign(e){if(!this.privateKey)throw new Error("No privateKey set!");return i(e,32),it.sign(e,this.privKey).toCompactRawBytes()}verify(e,t){if(i(e,32),i(t,64),!this.publicKey)throw new Error("No publicKey set!");let r;try{r=it.Signature.fromCompact(t)}catch(e){return!1}return it.verify(r,e,this.publicKey)}wipePrivateData(){return this.privKey=void 0,this.privKeyBytes&&(this.privKeyBytes.fill(0),this.privKeyBytes=void 0),this}toJSON(){return{xpriv:this.privateExtendedKey,xpub:this.publicExtendedKey}}serialize(e,t){if(!this.chainCode)throw new Error("No chainCode set");return i(t,33),g(Nt(e),new Uint8Array([this.depth]),Nt(this.parentFingerprint),Nt(this.index),this.chainCode,t)}}function Tt(e,t,r,i){o(e);const s=function(e,t){if(void 0!==t&&"[object Object]"!==w.call(t))throw new Error("Options should be object or undefined");return Object.assign(e,t)}({dkLen:32,asyncTick:10},i),{c:a,dkLen:c,asyncTick:u}=s;if(n(a),n(c),n(u),a<1)throw new Error("PBKDF2: iterations (c) should be >= 1");const f=p(t),h=p(r),l=new Uint8Array(c),d=E.create(e,f),g=d._cloneInto().update(h);return{c:a,dkLen:c,asyncTick:u,DK:l,PRF:d,PRFSalt:g}}function Kt(e,t,r,n,i){return e.destroy(),t.destroy(),n&&n.destroy(),i.fill(0),r}function Ht(e){if("string"!=typeof e)throw new TypeError("Invalid mnemonic type: "+typeof e);return e.normalize("NFKD")}function Ct(e){const t=Ht(e),r=t.split(" ");if(![12,15,18,21,24].includes(r.length))throw new Error("Invalid mnemonic");return{nfkd:t,words:r}}const jt=e=>Ht(`mnemonic${e}`);function kt(e,t=""){return function(e,t,r,n){const{c:i,dkLen:o,DK:s,PRF:a,PRFSalt:c}=Tt(e,t,r,n);let u;const h=new Uint8Array(4),l=f(h),d=new Uint8Array(a.outputLen);for(let e=1,t=0;t<o;e++,t+=a.outputLen){const r=s.subarray(t,t+a.outputLen);l.setInt32(0,e,!1),(u=c._cloneInto(u)).update(h).digestInto(d),r.set(d.subarray(0,r.length));for(let e=1;e<i;e++){a._cloneInto(u).update(d).digestInto(d);for(let e=0;e<r.length;e++)r[e]^=d[e]}}return Kt(a,c,s,u,d)}(ne,Ct(e).nfkd,jt(t),{c:2048,dkLen:64})}class qt extends Error{constructor(e,t={}){super(),Object.defineProperty(this,"details",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"docsPath",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"metaMessages",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"shortMessage",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ViemError"}),Object.defineProperty(this,"version",{enumerable:!0,configurable:!0,writable:!0,value:"viem@2.9.5"});const r=t.cause instanceof qt?t.cause.details:t.cause?.message?t.cause.message:t.details,n=t.cause instanceof qt&&t.cause.docsPath||t.docsPath;this.message=[e||"An error occurred.","",...t.metaMessages?[...t.metaMessages,""]:[],...n?[`Docs: https://viem.sh${n}${t.docsSlug?`#${t.docsSlug}`:""}`]:[],...r?[`Details: ${r}`]:[],`Version: ${this.version}`].join("\n"),t.cause&&(this.cause=t.cause),this.details=r,this.docsPath=n,this.metaMessages=t.metaMessages,this.shortMessage=e}walk(e){return Mt(this,e)}}function Mt(e,t){return t?.(e)?e:e&&"object"==typeof e&&"cause"in e?Mt(e.cause,t):t?null:e}class Vt extends qt{constructor({max:e,min:t,signed:r,size:n,value:i}){super(`Number "${i}" is not in safe ${n?`${8*n}-bit ${r?"signed":"unsigned"} `:""}integer range ${e?`(${t} to ${e})`:`(above ${t})`}`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"IntegerOutOfRangeError"})}}class Dt extends qt{constructor({givenSize:e,maxSize:t}){super(`Size cannot exceed ${t} bytes. Given size: ${e} bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SizeOverflowError"})}}class Gt extends qt{constructor({offset:e,position:t,size:r}){super(`Slice ${"start"===t?"starting":"ending"} at offset "${e}" is out-of-bounds (size: ${r}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SliceOffsetOutOfBoundsError"})}}class Zt extends qt{constructor({size:e,targetSize:t,type:r}){super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${e}) exceeds padding size (${t}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"SizeExceedsPaddingSizeError"})}}function _t(e,{dir:t,size:r=32}={}){return"string"==typeof e?Wt(e,{dir:t,size:r}):function(e,{dir:t,size:r=32}={}){if(null===r)return e;if(e.length>r)throw new Zt({size:e.length,targetSize:r,type:"bytes"});const n=new Uint8Array(r);for(let i=0;i<r;i++){const o="right"===t;n[o?i:r-i-1]=e[o?i:e.length-i-1]}return n}(e,{dir:t,size:r})}function Wt(e,{dir:t,size:r=32}={}){if(null===r)return e;const n=e.replace("0x","");if(n.length>2*r)throw new Zt({size:Math.ceil(n.length/2),targetSize:r,type:"hex"});return`0x${n["right"===t?"padEnd":"padStart"](2*r,"0")}`}function Yt(e,{strict:t=!0}={}){return!!e&&("string"==typeof e&&(t?/^0x[0-9a-fA-F]*$/.test(e):e.startsWith("0x")))}function Xt(e){return Yt(e,{strict:!1})?Math.ceil((e.length-2)/2):e.length}function Jt(e,{size:t}){if(Xt(e)>t)throw new Dt({givenSize:Xt(e),maxSize:t})}function Qt(e,t={}){const{signed:r}=t;t.size&&Jt(e,{size:t.size});const n=BigInt(e);if(!r)return n;const i=(e.length-2)/2;return n<=(1n<<8n*BigInt(i)-1n)-1n?n:n-BigInt(`0x${"f".padStart(2*i,"f")}`)-1n}function er(e,t={}){return Number(Qt(e,t))}const tr=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function rr(e,t={}){return"number"==typeof e||"bigint"==typeof e?or(e,t):"string"==typeof e?ar(e,t):"boolean"==typeof e?nr(e,t):ir(e,t)}function nr(e,t={}){const r=`0x${Number(e)}`;return"number"==typeof t.size?(Jt(r,{size:t.size}),_t(r,{size:t.size})):r}function ir(e,t={}){let r="";for(let t=0;t<e.length;t++)r+=tr[e[t]];const n=`0x${r}`;return"number"==typeof t.size?(Jt(n,{size:t.size}),_t(n,{dir:"right",size:t.size})):n}function or(e,t={}){const{signed:r,size:n}=t,i=BigInt(e);let o;n?o=r?(1n<<8n*BigInt(n)-1n)-1n:2n**(8n*BigInt(n))-1n:"number"==typeof e&&(o=BigInt(Number.MAX_SAFE_INTEGER));const s="bigint"==typeof o&&r?-o-1n:0;if(o&&i>o||i<s){const t="bigint"==typeof e?"n":"";throw new Vt({max:o?`${o}${t}`:void 0,min:`${s}${t}`,signed:r,size:n,value:`${e}${t}`})}const a=`0x${(r&&i<0?(1n<<BigInt(8*n))+BigInt(i):i).toString(16)}`;return n?_t(a,{size:n}):a}const sr=new TextEncoder;function ar(e,t={}){return ir(sr.encode(e),t)}BigInt(0);const cr=BigInt(1),ur=BigInt(2),fr=e=>e instanceof Uint8Array,hr=Array.from({length:256},((e,t)=>t.toString(16).padStart(2,"0")));function lr(e){if(!fr(e))throw new Error("Uint8Array expected");let t="";for(let r=0;r<e.length;r++)t+=hr[e[r]];return t}function dr(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);return BigInt(""===e?"0":`0x${e}`)}function pr(e){if("string"!=typeof e)throw new Error("hex string expected, got "+typeof e);const t=e.length;if(t%2)throw new Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(t/2);for(let t=0;t<r.length;t++){const n=2*t,i=e.slice(n,n+2),o=Number.parseInt(i,16);if(Number.isNaN(o)||o<0)throw new Error("Invalid byte sequence");r[t]=o}return r}function gr(e){return dr(lr(e))}function yr(e){if(!fr(e))throw new Error("Uint8Array expected");return dr(lr(Uint8Array.from(e).reverse()))}function wr(e,t){return pr(e.toString(16).padStart(2*t,"0"))}function br(e,t){return wr(e,t).reverse()}function mr(e,t,r){let n;if("string"==typeof t)try{n=pr(t)}catch(r){throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${r}`)}else{if(!fr(t))throw new Error(`${e} must be hex string or Uint8Array`);n=Uint8Array.from(t)}const i=n.length;if("number"==typeof r&&i!==r)throw new Error(`${e} expected ${r} bytes, got ${i}`);return n}function xr(...e){const t=new Uint8Array(e.reduce(((e,t)=>e+t.length),0));let r=0;return e.forEach((e=>{if(!fr(e))throw new Error("Uint8Array expected");t.set(e,r),r+=e.length})),t}const Er=e=>(ur<<BigInt(e-1))-cr,vr=e=>new Uint8Array(e),Br=e=>Uint8Array.from(e);function Ir(e,t,r){if("number"!=typeof e||e<2)throw new Error("hashLen must be a number");if("number"!=typeof t||t<2)throw new Error("qByteLen must be a number");if("function"!=typeof r)throw new Error("hmacFn must be a function");let n=vr(e),i=vr(e),o=0;const s=()=>{n.fill(1),i.fill(0),o=0},a=(...e)=>r(i,n,...e),c=(e=vr())=>{i=a(Br([0]),e),n=a(),0!==e.length&&(i=a(Br([1]),e),n=a())},u=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let e=0;const r=[];for(;e<t;){n=a();const t=n.slice();r.push(t),e+=n.length}return xr(...r)};return(e,t)=>{let r;for(s(),c(e);!(r=t(u()));)c();return s(),r}}const Ar={bigint:e=>"bigint"==typeof e,function:e=>"function"==typeof e,boolean:e=>"boolean"==typeof e,string:e=>"string"==typeof e,stringOrUint8Array:e=>"string"==typeof e||e instanceof Uint8Array,isSafeInteger:e=>Number.isSafeInteger(e),array:e=>Array.isArray(e),field:(e,t)=>t.Fp.isValid(e),hash:e=>"function"==typeof e&&Number.isSafeInteger(e.outputLen)};function Sr(e,t,r={}){const n=(t,r,n)=>{const i=Ar[r];if("function"!=typeof i)throw new Error(`Invalid validator "${r}", expected function`);const o=e[t];if(!(n&&void 0===o||i(o,e)))throw new Error(`Invalid param ${String(t)}=${o} (${typeof o}), expected ${r}`)};for(const[e,r]of Object.entries(t))n(e,r,!1);for(const[e,t]of Object.entries(r))n(e,t,!0);return e}const Pr=BigInt(0),Or=BigInt(1),$r=BigInt(2),zr=BigInt(3),Ur=BigInt(4),Lr=BigInt(5),Rr=BigInt(8);BigInt(9),BigInt(16);function Nr(e,t){const r=e%t;return r>=Pr?r:t+r}function Fr(e,t,r){if(r<=Pr||t<Pr)throw new Error("Expected power/modulo > 0");if(r===Or)return Pr;let n=Or;for(;t>Pr;)t&Or&&(n=n*e%r),e=e*e%r,t>>=Or;return n}function Tr(e,t,r){let n=e;for(;t-- >Pr;)n*=n,n%=r;return n}function Kr(e,t){if(e===Pr||t<=Pr)throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);let r=Nr(e,t),n=t,i=Pr,o=Or,s=Or,a=Pr;for(;r!==Pr;){const e=n/r,t=n%r,c=i-s*e,u=o-a*e;n=r,r=t,i=s,o=a,s=c,a=u}if(n!==Or)throw new Error("invert: does not exist");return Nr(i,t)}function Hr(e){if(e%Ur===zr){const t=(e+Or)/Ur;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}if(e%Rr===Lr){const t=(e-Lr)/Rr;return function(e,r){const n=e.mul(r,$r),i=e.pow(n,t),o=e.mul(r,i),s=e.mul(e.mul(o,$r),i),a=e.mul(o,e.sub(s,e.ONE));if(!e.eql(e.sqr(a),r))throw new Error("Cannot find square root");return a}}return function(e){const t=(e-Or)/$r;let r,n,i;for(r=e-Or,n=0;r%$r===Pr;r/=$r,n++);for(i=$r;i<e&&Fr(i,t,e)!==e-Or;i++);if(1===n){const t=(e+Or)/Ur;return function(e,r){const n=e.pow(r,t);if(!e.eql(e.sqr(n),r))throw new Error("Cannot find square root");return n}}const o=(r+Or)/$r;return function(e,s){if(e.pow(s,t)===e.neg(e.ONE))throw new Error("Cannot find square root");let a=n,c=e.pow(e.mul(e.ONE,i),r),u=e.pow(s,o),f=e.pow(s,r);for(;!e.eql(f,e.ONE);){if(e.eql(f,e.ZERO))return e.ZERO;let t=1;for(let r=e.sqr(f);t<a&&!e.eql(r,e.ONE);t++)r=e.sqr(r);const r=e.pow(c,Or<<BigInt(a-t-1));c=e.sqr(r),u=e.mul(u,r),f=e.mul(f,c),a=t}return u}}(e)}const Cr=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function jr(e,t){const r=void 0!==t?t:e.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function kr(e){if("bigint"!=typeof e)throw new Error("field order must be bigint");const t=e.toString(2).length;return Math.ceil(t/8)}function qr(e){const t=kr(e);return t+Math.ceil(t/2)}const Mr=BigInt(0),Vr=BigInt(1);function Dr(e){return Sr(e.Fp,Cr.reduce(((e,t)=>(e[t]="function",e)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),Sr(e,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...jr(e.n,e.nBitLength),...e,p:e.Fp.ORDER})}const{Ph:Gr,aT:Zr}=r,_r={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(e){const{Err:t}=_r;if(e.length<2||2!==e[0])throw new t("Invalid signature integer tag");const r=e[1],n=e.subarray(2,r+2);if(!r||n.length!==r)throw new t("Invalid signature integer: wrong length");if(128&n[0])throw new t("Invalid signature integer: negative");if(0===n[0]&&!(128&n[1]))throw new t("Invalid signature integer: unnecessary leading zero");return{d:Gr(n),l:e.subarray(r+2)}},toSig(e){const{Err:t}=_r,r="string"==typeof e?Zr(e):e;if(!(r instanceof Uint8Array))throw new Error("ui8a expected");let n=r.length;if(n<2||48!=r[0])throw new t("Invalid signature tag");if(r[1]!==n-2)throw new t("Invalid signature: incorrect length");const{d:i,l:o}=_r._parseInt(r.subarray(2)),{d:s,l:a}=_r._parseInt(o);if(a.length)throw new t("Invalid signature: left bytes after parsing");return{r:i,s}},hexFromSig(e){const t=e=>8&Number.parseInt(e[0],16)?"00"+e:e,r=e=>{const t=e.toString(16);return 1&t.length?`0${t}`:t},n=t(r(e.s)),i=t(r(e.r)),o=n.length/2,s=i.length/2,a=r(o),c=r(s);return`30${r(s+o+4)}02${c}${i}02${a}${n}`}},Wr=BigInt(0),Yr=BigInt(1),Xr=(BigInt(2),BigInt(3));BigInt(4);function Jr(e){const t=function(e){const t=Dr(e);Sr(t,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:i}=t;if(r){if(!n.eql(i,n.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...t})}(e),{Fp:r}=t,n=t.toBytes||((e,t,n)=>{const i=t.toAffine();return xr(Uint8Array.from([4]),r.toBytes(i.x),r.toBytes(i.y))}),i=t.fromBytes||(e=>{const t=e.subarray(1);return{x:r.fromBytes(t.subarray(0,r.BYTES)),y:r.fromBytes(t.subarray(r.BYTES,2*r.BYTES))}});function o(e){const{a:n,b:i}=t,o=r.sqr(e),s=r.mul(o,e);return r.add(r.add(s,r.mul(e,n)),i)}if(!r.eql(r.sqr(t.Gy),o(t.Gx)))throw new Error("bad generator point: equation left != right");function s(e){return"bigint"==typeof e&&Wr<e&&e<t.n}function a(e){if(!s(e))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function c(e){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:i,n:o}=t;if(r&&"bigint"!=typeof e){if(e instanceof Uint8Array&&(e=lr(e)),"string"!=typeof e||!r.includes(e.length))throw new Error("Invalid key");e=e.padStart(2*n,"0")}let s;try{s="bigint"==typeof e?e:gr(mr("private key",e,n))}catch(t){throw new Error(`private key must be ${n} bytes, hex or bigint, not ${typeof e}`)}return i&&(s=Nr(s,o)),a(s),s}const u=new Map;function f(e){if(!(e instanceof h))throw new Error("ProjectivePoint expected")}class h{constructor(e,t,n){if(this.px=e,this.py=t,this.pz=n,null==e||!r.isValid(e))throw new Error("x required");if(null==t||!r.isValid(t))throw new Error("y required");if(null==n||!r.isValid(n))throw new Error("z required")}static fromAffine(e){const{x:t,y:n}=e||{};if(!e||!r.isValid(t)||!r.isValid(n))throw new Error("invalid affine point");if(e instanceof h)throw new Error("projective point not allowed");const i=e=>r.eql(e,r.ZERO);return i(t)&&i(n)?h.ZERO:new h(t,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(e){const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(h.fromAffine)}static fromHex(e){const t=h.fromAffine(i(mr("pointHex",e)));return t.assertValidity(),t}static fromPrivateKey(e){return h.BASE.multiply(c(e))}_setWindowSize(e){this._WINDOW_SIZE=e,u.delete(this)}assertValidity(){if(this.is0()){if(t.allowInfinityPoint&&!r.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:e,y:n}=this.toAffine();if(!r.isValid(e)||!r.isValid(n))throw new Error("bad point: x or y not FE");const i=r.sqr(n),s=o(e);if(!r.eql(i,s))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:e}=this.toAffine();if(r.isOdd)return!r.isOdd(e);throw new Error("Field doesn't support isOdd")}equals(e){f(e);const{px:t,py:n,pz:i}=this,{px:o,py:s,pz:a}=e,c=r.eql(r.mul(t,a),r.mul(o,i)),u=r.eql(r.mul(n,a),r.mul(s,i));return c&&u}negate(){return new h(this.px,r.neg(this.py),this.pz)}double(){const{a:e,b:n}=t,i=r.mul(n,Xr),{px:o,py:s,pz:a}=this;let c=r.ZERO,u=r.ZERO,f=r.ZERO,l=r.mul(o,o),d=r.mul(s,s),p=r.mul(a,a),g=r.mul(o,s);return g=r.add(g,g),f=r.mul(o,a),f=r.add(f,f),c=r.mul(e,f),u=r.mul(i,p),u=r.add(c,u),c=r.sub(d,u),u=r.add(d,u),u=r.mul(c,u),c=r.mul(g,c),f=r.mul(i,f),p=r.mul(e,p),g=r.sub(l,p),g=r.mul(e,g),g=r.add(g,f),f=r.add(l,l),l=r.add(f,l),l=r.add(l,p),l=r.mul(l,g),u=r.add(u,l),p=r.mul(s,a),p=r.add(p,p),l=r.mul(p,g),c=r.sub(c,l),f=r.mul(p,d),f=r.add(f,f),f=r.add(f,f),new h(c,u,f)}add(e){f(e);const{px:n,py:i,pz:o}=this,{px:s,py:a,pz:c}=e;let u=r.ZERO,l=r.ZERO,d=r.ZERO;const p=t.a,g=r.mul(t.b,Xr);let y=r.mul(n,s),w=r.mul(i,a),b=r.mul(o,c),m=r.add(n,i),x=r.add(s,a);m=r.mul(m,x),x=r.add(y,w),m=r.sub(m,x),x=r.add(n,o);let E=r.add(s,c);return x=r.mul(x,E),E=r.add(y,b),x=r.sub(x,E),E=r.add(i,o),u=r.add(a,c),E=r.mul(E,u),u=r.add(w,b),E=r.sub(E,u),d=r.mul(p,x),u=r.mul(g,b),d=r.add(u,d),u=r.sub(w,d),d=r.add(w,d),l=r.mul(u,d),w=r.add(y,y),w=r.add(w,y),b=r.mul(p,b),x=r.mul(g,x),w=r.add(w,b),b=r.sub(y,b),b=r.mul(p,b),x=r.add(x,b),y=r.mul(w,x),l=r.add(l,y),y=r.mul(E,x),u=r.mul(m,u),u=r.sub(u,y),y=r.mul(m,w),d=r.mul(E,d),d=r.add(d,y),new h(u,l,d)}subtract(e){return this.add(e.negate())}is0(){return this.equals(h.ZERO)}wNAF(e){return d.wNAFCached(this,u,e,(e=>{const t=r.invertBatch(e.map((e=>e.pz)));return e.map(((e,r)=>e.toAffine(t[r]))).map(h.fromAffine)}))}multiplyUnsafe(e){const n=h.ZERO;if(e===Wr)return n;if(a(e),e===Yr)return this;const{endo:i}=t;if(!i)return d.unsafeLadder(this,e);let{k1neg:o,k1:s,k2neg:c,k2:u}=i.splitScalar(e),f=n,l=n,p=this;for(;s>Wr||u>Wr;)s&Yr&&(f=f.add(p)),u&Yr&&(l=l.add(p)),p=p.double(),s>>=Yr,u>>=Yr;return o&&(f=f.negate()),c&&(l=l.negate()),l=new h(r.mul(l.px,i.beta),l.py,l.pz),f.add(l)}multiply(e){a(e);let n,i,o=e;const{endo:s}=t;if(s){const{k1neg:e,k1:t,k2neg:a,k2:c}=s.splitScalar(o);let{p:u,f}=this.wNAF(t),{p:l,f:p}=this.wNAF(c);u=d.constTimeNegate(e,u),l=d.constTimeNegate(a,l),l=new h(r.mul(l.px,s.beta),l.py,l.pz),n=u.add(l),i=f.add(p)}else{const{p:e,f:t}=this.wNAF(o);n=e,i=t}return h.normalizeZ([n,i])[0]}multiplyAndAddUnsafe(e,t,r){const n=h.BASE,i=(e,t)=>t!==Wr&&t!==Yr&&e.equals(n)?e.multiply(t):e.multiplyUnsafe(t),o=i(this,t).add(i(e,r));return o.is0()?void 0:o}toAffine(e){const{px:t,py:n,pz:i}=this,o=this.is0();null==e&&(e=o?r.ONE:r.inv(i));const s=r.mul(t,e),a=r.mul(n,e),c=r.mul(i,e);if(o)return{x:r.ZERO,y:r.ZERO};if(!r.eql(c,r.ONE))throw new Error("invZ was invalid");return{x:s,y:a}}isTorsionFree(){const{h:e,isTorsionFree:r}=t;if(e===Yr)return!0;if(r)return r(h,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:e,clearCofactor:r}=t;return e===Yr?this:r?r(h,this):this.multiplyUnsafe(t.h)}toRawBytes(e=!0){return this.assertValidity(),n(h,this,e)}toHex(e=!0){return lr(this.toRawBytes(e))}}h.BASE=new h(t.Gx,t.Gy,r.ONE),h.ZERO=new h(r.ZERO,r.ONE,r.ZERO);const l=t.nBitLength,d=function(e,t){const r=(e,t)=>{const r=t.negate();return e?r:t},n=e=>({windows:Math.ceil(t/e)+1,windowSize:2**(e-1)});return{constTimeNegate:r,unsafeLadder(t,r){let n=e.ZERO,i=t;for(;r>Mr;)r&Vr&&(n=n.add(i)),i=i.double(),r>>=Vr;return n},precomputeWindow(e,t){const{windows:r,windowSize:i}=n(t),o=[];let s=e,a=s;for(let e=0;e<r;e++){a=s,o.push(a);for(let e=1;e<i;e++)a=a.add(s),o.push(a);s=a.double()}return o},wNAF(t,i,o){const{windows:s,windowSize:a}=n(t);let c=e.ZERO,u=e.BASE;const f=BigInt(2**t-1),h=2**t,l=BigInt(t);for(let e=0;e<s;e++){const t=e*a;let n=Number(o&f);o>>=l,n>a&&(n-=h,o+=Vr);const s=t,d=t+Math.abs(n)-1,p=e%2!=0,g=n<0;0===n?u=u.add(r(p,i[s])):c=c.add(r(g,i[d]))}return{p:c,f:u}},wNAFCached(e,t,r,n){const i=e._WINDOW_SIZE||1;let o=t.get(e);return o||(o=this.precomputeWindow(e,i),1!==i&&t.set(e,n(o))),this.wNAF(i,o,r)}}}(h,t.endo?Math.ceil(l/2):l);return{CURVE:t,ProjectivePoint:h,normPrivateKeyToScalar:c,weierstrassEquation:o,isWithinCurveOrder:s}}function Qr(e){const t=function(e){const t=Dr(e);return Sr(t,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...t})}(e),{Fp:r,n}=t,i=r.BYTES+1,o=2*r.BYTES+1;function s(e){return Nr(e,n)}function a(e){return Kr(e,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:f,isWithinCurveOrder:h}=Jr({...t,toBytes(e,t,n){const i=t.toAffine(),o=r.toBytes(i.x),s=xr;return n?s(Uint8Array.from([t.hasEvenY()?2:3]),o):s(Uint8Array.from([4]),o,r.toBytes(i.y))},fromBytes(e){const t=e.length,n=e[0],s=e.subarray(1);if(t!==i||2!==n&&3!==n){if(t===o&&4===n){return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))}}throw new Error(`Point of length ${t} was invalid. Expected ${i} compressed bytes or ${o} uncompressed bytes`)}{const e=gr(s);if(!(Wr<(a=e)&&a<r.ORDER))throw new Error("Point is not on curve");const t=f(e);let i=r.sqrt(t);return 1==(1&n)!==((i&Yr)===Yr)&&(i=r.neg(i)),{x:e,y:i}}var a}}),l=e=>lr(wr(e,t.nByteLength));function d(e){return e>n>>Yr}const p=(e,t,r)=>gr(e.slice(t,r));class g{constructor(e,t,r){this.r=e,this.s=t,this.recovery=r,this.assertValidity()}static fromCompact(e){const r=t.nByteLength;return e=mr("compactSignature",e,2*r),new g(p(e,0,r),p(e,r,2*r))}static fromDER(e){const{r:t,s:r}=_r.toSig(mr("DER",e));return new g(t,r)}assertValidity(){if(!h(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!h(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(e){return new g(this.r,this.s,e)}recoverPublicKey(e){const{r:n,s:i,recovery:o}=this,u=m(mr("msgHash",e));if(null==o||![0,1,2,3].includes(o))throw new Error("recovery id invalid");const f=2===o||3===o?n+t.n:n;if(f>=r.ORDER)throw new Error("recovery id 2 or 3 invalid");const h=0==(1&o)?"02":"03",d=c.fromHex(h+l(f)),p=a(f),g=s(-u*p),y=s(i*p),w=c.BASE.multiplyAndAddUnsafe(d,g,y);if(!w)throw new Error("point at infinify");return w.assertValidity(),w}hasHighS(){return d(this.s)}normalizeS(){return this.hasHighS()?new g(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return pr(this.toDERHex())}toDERHex(){return _r.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return pr(this.toCompactHex())}toCompactHex(){return l(this.r)+l(this.s)}}const y={isValidPrivateKey(e){try{return u(e),!0}catch(e){return!1}},normPrivateKeyToScalar:u,randomPrivateKey:()=>{const e=qr(t.n);return function(e,t,r=!1){const n=e.length,i=kr(t),o=qr(t);if(n<16||n<o||n>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${n}`);const s=Nr(r?gr(e):yr(e),t-Or)+Or;return r?br(s,i):wr(s,i)}(t.randomBytes(e),t.n)},precompute:(e=8,t=c.BASE)=>(t._setWindowSize(e),t.multiply(BigInt(3)),t)};function w(e){const t=e instanceof Uint8Array,r="string"==typeof e,n=(t||r)&&e.length;return t?n===i||n===o:r?n===2*i||n===2*o:e instanceof c}const b=t.bits2int||function(e){const r=gr(e),n=8*e.length-t.nBitLength;return n>0?r>>BigInt(n):r},m=t.bits2int_modN||function(e){return s(b(e))},x=Er(t.nBitLength);function E(e){if("bigint"!=typeof e)throw new Error("bigint expected");if(!(Wr<=e&&e<x))throw new Error(`bigint expected < 2^${t.nBitLength}`);return wr(e,t.nByteLength)}function v(e,n,i=B){if(["recovered","canonical"].some((e=>e in i)))throw new Error("sign() legacy options not supported");const{hash:o,randomBytes:f}=t;let{lowS:l,prehash:p,extraEntropy:y}=i;null==l&&(l=!0),e=mr("msgHash",e),p&&(e=mr("prehashed msgHash",o(e)));const w=m(e),x=u(n),v=[E(x),E(w)];if(null!=y){const e=!0===y?f(r.BYTES):y;v.push(mr("extraEntropy",e))}const I=xr(...v),A=w;return{seed:I,k2sig:function(e){const t=b(e);if(!h(t))return;const r=a(t),n=c.BASE.multiply(t).toAffine(),i=s(n.x);if(i===Wr)return;const o=s(r*s(A+i*x));if(o===Wr)return;let u=(n.x===i?0:2)|Number(n.y&Yr),f=o;return l&&d(o)&&(f=function(e){return d(e)?s(-e):e}(o),u^=1),new g(i,f,u)}}}const B={lowS:t.lowS,prehash:!1},I={lowS:t.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(e,t=!0){return c.fromPrivateKey(e).toRawBytes(t)},getSharedSecret:function(e,t,r=!0){if(w(e))throw new Error("first arg must be private key");if(!w(t))throw new Error("second arg must be public key");return c.fromHex(t).multiply(u(e)).toRawBytes(r)},sign:function(e,r,n=B){const{seed:i,k2sig:o}=v(e,r,n),s=t;return Ir(s.hash.outputLen,s.nByteLength,s.hmac)(i,o)},verify:function(e,r,n,i=I){const o=e;if(r=mr("msgHash",r),n=mr("publicKey",n),"strict"in i)throw new Error("options.strict was renamed to lowS");const{lowS:u,prehash:f}=i;let h,l;try{if("string"==typeof o||o instanceof Uint8Array)try{h=g.fromDER(o)}catch(e){if(!(e instanceof _r.Err))throw e;h=g.fromCompact(o)}else{if("object"!=typeof o||"bigint"!=typeof o.r||"bigint"!=typeof o.s)throw new Error("PARSE");{const{r:e,s:t}=o;h=new g(e,t)}}l=c.fromHex(n)}catch(e){if("PARSE"===e.message)throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(u&&h.hasHighS())return!1;f&&(r=t.hash(r));const{r:d,s:p}=h,y=m(r),w=a(p),b=s(y*w),x=s(d*w),E=c.BASE.multiplyAndAddUnsafe(l,b,x)?.toAffine();return!!E&&s(E.x)===d},ProjectivePoint:c,Signature:g,utils:y}}function en(e){return{hash:e,hmac:(t,...r)=>E(e,t,g(...r)),randomBytes:m}}const tn=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),rn=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),nn=BigInt(1),on=BigInt(2),sn=(e,t)=>(e+t/on)/t;function an(e){const t=tn,r=BigInt(3),n=BigInt(6),i=BigInt(11),o=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),u=e*e*e%t,f=u*u*e%t,h=Tr(f,r,t)*f%t,l=Tr(h,r,t)*f%t,d=Tr(l,on,t)*u%t,p=Tr(d,i,t)*d%t,g=Tr(p,o,t)*p%t,y=Tr(g,a,t)*g%t,w=Tr(y,c,t)*y%t,b=Tr(w,a,t)*g%t,m=Tr(b,r,t)*f%t,x=Tr(m,s,t)*p%t,E=Tr(x,n,t)*u%t,v=Tr(E,on,t);if(!cn.eql(cn.sqr(v),e))throw new Error("Cannot find square root");return v}const cn=function(e,t,r=!1,n={}){if(e<=Pr)throw new Error(`Expected Field ORDER > 0, got ${e}`);const{nBitLength:i,nByteLength:o}=jr(e,t);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const s=Hr(e),a=Object.freeze({ORDER:e,BITS:i,BYTES:o,MASK:Er(i),ZERO:Pr,ONE:Or,create:t=>Nr(t,e),isValid:t=>{if("bigint"!=typeof t)throw new Error("Invalid field element: expected bigint, got "+typeof t);return Pr<=t&&t<e},is0:e=>e===Pr,isOdd:e=>(e&Or)===Or,neg:t=>Nr(-t,e),eql:(e,t)=>e===t,sqr:t=>Nr(t*t,e),add:(t,r)=>Nr(t+r,e),sub:(t,r)=>Nr(t-r,e),mul:(t,r)=>Nr(t*r,e),pow:(e,t)=>function(e,t,r){if(r<Pr)throw new Error("Expected power > 0");if(r===Pr)return e.ONE;if(r===Or)return t;let n=e.ONE,i=t;for(;r>Pr;)r&Or&&(n=e.mul(n,i)),i=e.sqr(i),r>>=Or;return n}(a,e,t),div:(t,r)=>Nr(t*Kr(r,e),e),sqrN:e=>e*e,addN:(e,t)=>e+t,subN:(e,t)=>e-t,mulN:(e,t)=>e*t,inv:t=>Kr(t,e),sqrt:n.sqrt||(e=>s(a,e)),invertBatch:e=>function(e,t){const r=new Array(t.length),n=t.reduce(((t,n,i)=>e.is0(n)?t:(r[i]=t,e.mul(t,n))),e.ONE),i=e.inv(n);return t.reduceRight(((t,n,i)=>e.is0(n)?t:(r[i]=e.mul(t,r[i]),e.mul(t,n))),i),r}(a,e),cmov:(e,t,r)=>r?t:e,toBytes:e=>r?br(e,o):wr(e,o),fromBytes:e=>{if(e.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${e.length}`);return r?yr(e):gr(e)}});return Object.freeze(a)}(tn,void 0,void 0,{sqrt:an}),un=function(e,t){const r=t=>Qr({...e,...en(t)});return Object.freeze({...r(t),create:r})}({a:BigInt(0),b:BigInt(7),Fp:cn,n:rn,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:e=>{const t=rn,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-nn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),i=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=r,s=BigInt("0x100000000000000000000000000000000"),a=sn(o*e,t),c=sn(-n*e,t);let u=Nr(e-a*r-c*i,t),f=Nr(-a*n-c*o,t);const h=u>s,l=f>s;if(h&&(u=t-u),l&&(f=t-f),u>s||f>s)throw new Error("splitScalar: Endomorphism failed, k="+e);return{k1neg:h,k1:u,k2neg:l,k2:f}}}},q);BigInt(0);un.ProjectivePoint;class fn extends qt{constructor({address:e}){super(`Address "${e}" is invalid.`,{metaMessages:["- Address must be a hex value of 20 bytes (40 hex characters).","- Address must match its checksum counterpart."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAddressError"})}}class hn extends Map{constructor(e){super(),Object.defineProperty(this,"maxSize",{enumerable:!0,configurable:!0,writable:!0,value:void 0}),this.maxSize=e}set(e,t){return super.set(e,t),this.maxSize&&this.size>this.maxSize&&this.delete(this.keys().next().value),this}}const ln=new TextEncoder;function dn(e,t={}){return"number"==typeof e||"bigint"==typeof e?function(e,t){const r=or(e,t);return yn(r)}(e,t):"boolean"==typeof e?function(e,t={}){const r=new Uint8Array(1);if(r[0]=Number(e),"number"==typeof t.size)return Jt(r,{size:t.size}),_t(r,{size:t.size});return r}(e,t):Yt(e)?yn(e,t):wn(e,t)}const pn={zero:48,nine:57,A:65,F:70,a:97,f:102};function gn(e){return e>=pn.zero&&e<=pn.nine?e-pn.zero:e>=pn.A&&e<=pn.F?e-(pn.A-10):e>=pn.a&&e<=pn.f?e-(pn.a-10):void 0}function yn(e,t={}){let r=e;t.size&&(Jt(r,{size:t.size}),r=_t(r,{dir:"right",size:t.size}));let n=r.slice(2);n.length%2&&(n=`0${n}`);const i=n.length/2,o=new Uint8Array(i);for(let e=0,t=0;e<i;e++){const r=gn(n.charCodeAt(t++)),i=gn(n.charCodeAt(t++));if(void 0===r||void 0===i)throw new qt(`Invalid byte sequence ("${n[t-2]}${n[t-1]}" in "${n}").`);o[e]=16*r+i}return o}function wn(e,t={}){const r=ln.encode(e);return"number"==typeof t.size?(Jt(r,{size:t.size}),_t(r,{dir:"right",size:t.size})):r}const[bn,mn,xn]=[[],[],[]],En=BigInt(0),vn=BigInt(1),Bn=BigInt(2),In=BigInt(7),An=BigInt(256),Sn=BigInt(113);for(let e=0,t=vn,r=1,n=0;e<24;e++){[r,n]=[n,(2*r+3*n)%5],bn.push(2*(5*n+r)),mn.push((e+1)*(e+2)/2%64);let i=En;for(let e=0;e<7;e++)t=(t<<vn^(t>>In)*Sn)%An,t&Bn&&(i^=vn<<(vn<<BigInt(e))-vn);xn.push(i)}const[Pn,On]=G(xn,!0),$n=(e,t,r)=>r>32?W(e,t,r):Z(e,t,r),zn=(e,t,r)=>r>32?Y(e,t,r):_(e,t,r);class Un extends y{constructor(e,t,r,i=!1,o=24){if(super(),this.blockLen=e,this.suffix=t,this.outputLen=r,this.enableXOF=i,this.rounds=o,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,n(r),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var s;this.state=new Uint8Array(200),this.state32=(s=this.state,new Uint32Array(s.buffer,s.byteOffset,Math.floor(s.byteLength/4)))}keccak(){!function(e,t=24){const r=new Uint32Array(10);for(let n=24-t;n<24;n++){for(let t=0;t<10;t++)r[t]=e[t]^e[t+10]^e[t+20]^e[t+30]^e[t+40];for(let t=0;t<10;t+=2){const n=(t+8)%10,i=(t+2)%10,o=r[i],s=r[i+1],a=$n(o,s,1)^r[n],c=zn(o,s,1)^r[n+1];for(let r=0;r<50;r+=10)e[t+r]^=a,e[t+r+1]^=c}let t=e[2],i=e[3];for(let r=0;r<24;r++){const n=mn[r],o=$n(t,i,n),s=zn(t,i,n),a=bn[r];t=e[a],i=e[a+1],e[a]=o,e[a+1]=s}for(let t=0;t<50;t+=10){for(let n=0;n<10;n++)r[n]=e[t+n];for(let n=0;n<10;n++)e[t+n]^=~r[(n+2)%10]&r[(n+4)%10]}e[0]^=Pn[n],e[1]^=On[n]}r.fill(0)}(this.state32,this.rounds),this.posOut=0,this.pos=0}update(e){s(this);const{blockLen:t,state:r}=this,n=(e=p(e)).length;for(let i=0;i<n;){const o=Math.min(t-this.pos,n-i);for(let t=0;t<o;t++)r[this.pos++]^=e[i++];this.pos===t&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state:e,suffix:t,pos:r,blockLen:n}=this;e[r]^=t,0!=(128&t)&&r===n-1&&this.keccak(),e[n-1]^=128,this.keccak()}writeInto(e){s(this,!1),i(e),this.finish();const t=this.state,{blockLen:r}=this;for(let n=0,i=e.length;n<i;){this.posOut>=r&&this.keccak();const o=Math.min(r-this.posOut,i-n);e.set(t.subarray(this.posOut,this.posOut+o),n),this.posOut+=o,n+=o}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return n(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(a(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(e){const{blockLen:t,suffix:r,outputLen:n,rounds:i,enableXOF:o}=this;return e||(e=new Un(t,r,n,o,i)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=i,e.suffix=r,e.outputLen=n,e.enableXOF=o,e.destroyed=this.destroyed,e}}const Ln=(e,t,r)=>b((()=>new Un(t,e,r))),Rn=Ln(1,136,32);function Nn(e,t){const r=t||"hex",n=Rn(Yt(e,{strict:!1})?dn(e):e);return"bytes"===r?n:rr(n)}function Fn(e,t){const r=t?`${t}${e.toLowerCase()}`:e.substring(2).toLowerCase(),n=Nn(wn(r),"bytes"),i=(t?r.substring(`${t}0x`.length):r).split("");for(let e=0;e<40;e+=2)n[e>>1]>>4>=8&&i[e]&&(i[e]=i[e].toUpperCase()),(15&n[e>>1])>=8&&i[e+1]&&(i[e+1]=i[e+1].toUpperCase());return`0x${i.join("")}`}const Tn=/^0x[a-fA-F0-9]{40}$/,Kn=new hn(8192);function Hn(e,{strict:t=!0}={}){if(Kn.has(e))return Kn.get(e);const r=!(!Tn.test(e)||e.toLowerCase()!==e&&t&&Fn(e)!==e);return Kn.set(e,r),r}const Cn="Ethereum Signed Message:\n";function jn(e){return"string"==typeof e[0]?kn(e):function(e){let t=0;for(const r of e)t+=r.length;const r=new Uint8Array(t);let n=0;for(const t of e)r.set(t,n),n+=t.length;return r}(e)}function kn(e){return`0x${e.reduce(((e,t)=>e+t.replace("0x","")),"")}`}function qn(e,t){const r="string"==typeof e?wn(e):e.raw instanceof Uint8Array?e.raw:dn(e.raw);return Nn(jn([wn(`${Cn}${r.length}`),r]),t)}function Mn({r:e,s:t,v:r,yParity:n}){const i=(()=>{if(27n===r||0===n)return"1b";if(28n===r||1===n)return"1c";throw new Error("Invalid v value")})();return`0x${new un.Signature(Qt(e),Qt(t)).toCompactHex()}${i}`}async function Vn({hash:e,privateKey:t}){const{r,s:n,recovery:i}=un.sign(e.slice(2),t.slice(2));return{r:rr(r),s:rr(n),v:i?28n:27n,yParity:i}}const Dn={ether:-9,wei:9};function Gn(e,t){let r=e.toString();const n=r.startsWith("-");n&&(r=r.slice(1)),r=r.padStart(t,"0");let[i,o]=[r.slice(0,r.length-t),r.slice(r.length-t)];return o=o.replace(/(0+)$/,""),`${n?"-":""}${i||"0"}${o?`.${o}`:""}`}function Zn(e,t="wei"){return Gn(e,Dn[t])}function _n(e){const t=Object.entries(e).map((([e,t])=>void 0===t||!1===t?null:[e,t])).filter(Boolean),r=t.reduce(((e,[t])=>Math.max(e,t.length)),0);return t.map((([e,t])=>`  ${`${e}:`.padEnd(r+1)}  ${t}`)).join("\n")}class Wn extends qt{constructor({v:e}){super(`Invalid \`v\` value "${e}". Expected 27 or 28.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidLegacyVError"})}}class Yn extends qt{constructor({transaction:e}){super("Cannot infer a transaction type from provided transaction.",{metaMessages:["Provided Transaction:","{",_n(e),"}","","To infer the type, either provide:","- a `type` to the Transaction, or","- an EIP-1559 Transaction with `maxFeePerGas`, or","- an EIP-2930 Transaction with `gasPrice` & `accessList`, or","- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or","- a Legacy Transaction with `gasPrice`"]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidSerializableTransactionError"})}}class Xn extends qt{constructor({storageKey:e}){super(`Size for storage key "${e}" is invalid. Expected 32 bytes. Got ${Math.floor((e.length-2)/2)} bytes.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidStorageKeySizeError"})}}function Jn(e){const{kzg:t}=e,r=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),n="string"==typeof e.blobs[0]?e.blobs.map((e=>yn(e))):e.blobs,i=[];for(const e of n)i.push(Uint8Array.from(t.blobToKzgCommitment(e)));return"bytes"===r?i:i.map((e=>ir(e)))}function Qn(e){const{kzg:t}=e,r=e.to??("string"==typeof e.blobs[0]?"hex":"bytes"),n="string"==typeof e.blobs[0]?e.blobs.map((e=>yn(e))):e.blobs,i="string"==typeof e.commitments[0]?e.commitments.map((e=>yn(e))):e.commitments,o=[];for(let e=0;e<n.length;e++){const r=n[e],s=i[e];o.push(Uint8Array.from(t.computeBlobKzgProof(r,s)))}return"bytes"===r?o:o.map((e=>ir(e)))}function ei(e){const{commitment:t,version:r=1}=e,n=e.to??("string"==typeof t?"hex":"bytes"),i=function(e,t){const r=t||"hex",n=q(Yt(e,{strict:!1})?dn(e):e);return"bytes"===r?n:rr(n)}(t,"bytes");return i.set([r],0),"bytes"===n?i:ir(i)}const ti=32,ri=4096,ni=ti*ri,ii=6*ni-1-1*ri*6,oi=1;class si extends qt{constructor({maxSize:e,size:t}){super("Blob size is too large.",{metaMessages:[`Max: ${e} bytes`,`Given: ${t} bytes`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BlobSizeTooLargeError"})}}class ai extends qt{constructor(){super("Blob data must not be empty."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"EmptyBlobError"})}}class ci extends qt{constructor({hash:e,size:t}){super(`Versioned hash "${e}" size is invalid.`,{metaMessages:["Expected: 32",`Received: ${t}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidVersionedHashSizeError"})}}class ui extends qt{constructor({hash:e,version:t}){super(`Versioned hash "${e}" version is invalid.`,{metaMessages:[`Expected: ${oi}`,`Received: ${t}`]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidVersionedHashVersionError"})}}class fi extends qt{constructor({offset:e}){super(`Offset \`${e}\` cannot be negative.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NegativeOffsetError"})}}class hi extends qt{constructor({length:e,position:t}){super(`Position \`${t}\` is out of bounds (\`0 < position < ${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"PositionOutOfBoundsError"})}}class li extends qt{constructor({count:e,limit:t}){super(`Recursive read limit of \`${t}\` exceeded (recursive read count: \`${e}\`).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"RecursiveReadLimitExceededError"})}}const di={bytes:new Uint8Array,dataView:new DataView(new ArrayBuffer(0)),position:0,positionReadCount:new Map,recursiveReadCount:0,recursiveReadLimit:1/0,assertReadLimit(){if(this.recursiveReadCount>=this.recursiveReadLimit)throw new li({count:this.recursiveReadCount+1,limit:this.recursiveReadLimit})},assertPosition(e){if(e<0||e>this.bytes.length-1)throw new hi({length:this.bytes.length,position:e})},decrementPosition(e){if(e<0)throw new fi({offset:e});const t=this.position-e;this.assertPosition(t),this.position=t},getReadCount(e){return this.positionReadCount.get(e||this.position)||0},incrementPosition(e){if(e<0)throw new fi({offset:e});const t=this.position+e;this.assertPosition(t),this.position=t},inspectByte(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectBytes(e,t){const r=t??this.position;return this.assertPosition(r+e-1),this.bytes.subarray(r,r+e)},inspectUint8(e){const t=e??this.position;return this.assertPosition(t),this.bytes[t]},inspectUint16(e){const t=e??this.position;return this.assertPosition(t+1),this.dataView.getUint16(t)},inspectUint24(e){const t=e??this.position;return this.assertPosition(t+2),(this.dataView.getUint16(t)<<8)+this.dataView.getUint8(t+2)},inspectUint32(e){const t=e??this.position;return this.assertPosition(t+3),this.dataView.getUint32(t)},pushByte(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushBytes(e){this.assertPosition(this.position+e.length-1),this.bytes.set(e,this.position),this.position+=e.length},pushUint8(e){this.assertPosition(this.position),this.bytes[this.position]=e,this.position++},pushUint16(e){this.assertPosition(this.position+1),this.dataView.setUint16(this.position,e),this.position+=2},pushUint24(e){this.assertPosition(this.position+2),this.dataView.setUint16(this.position,e>>8),this.dataView.setUint8(this.position+2,255&e),this.position+=3},pushUint32(e){this.assertPosition(this.position+3),this.dataView.setUint32(this.position,e),this.position+=4},readByte(){this.assertReadLimit(),this._touch();const e=this.inspectByte();return this.position++,e},readBytes(e,t){this.assertReadLimit(),this._touch();const r=this.inspectBytes(e);return this.position+=t??e,r},readUint8(){this.assertReadLimit(),this._touch();const e=this.inspectUint8();return this.position+=1,e},readUint16(){this.assertReadLimit(),this._touch();const e=this.inspectUint16();return this.position+=2,e},readUint24(){this.assertReadLimit(),this._touch();const e=this.inspectUint24();return this.position+=3,e},readUint32(){this.assertReadLimit(),this._touch();const e=this.inspectUint32();return this.position+=4,e},get remaining(){return this.bytes.length-this.position},setPosition(e){const t=this.position;return this.assertPosition(e),this.position=e,()=>this.position=t},_touch(){if(this.recursiveReadLimit===1/0)return;const e=this.getReadCount();this.positionReadCount.set(this.position,e+1),e>0&&this.recursiveReadCount++}};function pi(e,{recursiveReadLimit:t=8192}={}){const r=Object.create(di);return r.bytes=e,r.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength),r.positionReadCount=new Map,r.recursiveReadLimit=t,r}function gi(e){const{data:t,kzg:r,to:n}=e,i=e.blobs??function(e){const t=e.to??("string"==typeof e.data?"hex":"bytes"),r="string"==typeof e.data?yn(e.data):e.data,n=Xt(r);if(!n)throw new ai;if(n>ii)throw new si({maxSize:ii,size:n});const i=[];let o=!0,s=0;for(;o;){const e=pi(new Uint8Array(ni));let t=0;for(;t<ri;){const n=r.slice(s,s+(ti-1));if(e.pushByte(0),e.pushBytes(n),n.length<31){e.pushByte(128),o=!1;break}t++,s+=31}i.push(e)}return"bytes"===t?i.map((e=>e.bytes)):i.map((e=>ir(e.bytes)))}({data:t,to:n}),o=e.commitments??Jn({blobs:i,kzg:r,to:n}),s=e.proofs??Qn({blobs:i,commitments:o,kzg:r,to:n}),a=[];for(let e=0;e<i.length;e++)a.push({blob:i[e],commitment:o[e],proof:s[e]});return a}function yi(e,{dir:t="left"}={}){let r="string"==typeof e?e.replace("0x",""):e,n=0;for(let e=0;e<r.length-1&&"0"===r["left"===t?e:r.length-e-1].toString();e++)n++;return r="left"===t?r.slice(n):r.slice(0,r.length-n),"string"==typeof e?(1===r.length&&"right"===t&&(r=`${r}0`),`0x${r.length%2==1?`0${r}`:r}`):r}function wi(e,t="hex"){const r=bi(e),n=pi(new Uint8Array(r.length));return r.encode(n),"hex"===t?ir(n.bytes):n.bytes}function bi(e){return Array.isArray(e)?function(e){const t=e.reduce(((e,t)=>e+t.length),0),r=mi(t);return{length:t<=55?1+t:1+r+t,encode(n){t<=55?n.pushByte(192+t):(n.pushByte(247+r),1===r?n.pushUint8(t):2===r?n.pushUint16(t):3===r?n.pushUint24(t):n.pushUint32(t));for(const{encode:t}of e)t(n)}}}(e.map((e=>bi(e)))):function(e){const t="string"==typeof e?yn(e):e,r=mi(t.length),n=1===t.length&&t[0]<128?1:t.length<=55?1+t.length:1+r+t.length;return{length:n,encode(e){1===t.length&&t[0]<128?e.pushBytes(t):t.length<=55?(e.pushByte(128+t.length),e.pushBytes(t)):(e.pushByte(183+r),1===r?e.pushUint8(t.length):2===r?e.pushUint16(t.length):3===r?e.pushUint24(t.length):e.pushUint32(t.length),e.pushBytes(t))}}}(e)}function mi(e){if(e<256)return 1;if(e<65536)return 2;if(e<2**24)return 3;if(e<2**32)return 4;throw new qt("Length is too large.")}class xi extends qt{constructor({chainId:e}){super("number"==typeof e?`Chain ID "${e}" is invalid.`:"Chain ID is invalid."),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidChainIdError"})}}class Ei extends qt{constructor({cause:e,message:t}={}){const r=t?.replace("execution reverted: ","")?.replace("execution reverted","");super(`Execution reverted ${r?`with reason: ${r}`:"for an unknown reason"}.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"ExecutionRevertedError"})}}Object.defineProperty(Ei,"code",{enumerable:!0,configurable:!0,writable:!0,value:3}),Object.defineProperty(Ei,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/execution reverted/});class vi extends qt{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${Zn(t)} gwei`:""}) cannot be higher than the maximum allowed value (2^256-1).`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FeeCapTooHigh"})}}Object.defineProperty(vi,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/});Object.defineProperty(class extends qt{constructor({cause:e,maxFeePerGas:t}={}){super(`The fee cap (\`maxFeePerGas\`${t?` = ${Zn(t)}`:""} gwei) cannot be lower than the block base fee.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"FeeCapTooLow"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/});Object.defineProperty(class extends qt{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}is higher than the next one expected.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NonceTooHighError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too high/});Object.defineProperty(class extends qt{constructor({cause:e,nonce:t}={}){super([`Nonce provided for the transaction ${t?`(${t}) `:""}is lower than the current nonce of the account.`,"Try increasing the nonce or find the latest nonce with `getTransactionCount`."].join("\n"),{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NonceTooLowError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce too low|transaction already imported|already known/});Object.defineProperty(class extends qt{constructor({cause:e,nonce:t}={}){super(`Nonce provided for the transaction ${t?`(${t}) `:""}exceeds the maximum allowed nonce.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"NonceMaxValueError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/nonce has max value/});Object.defineProperty(class extends qt{constructor({cause:e}={}){super(["The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."].join("\n"),{cause:e,metaMessages:["This error could arise when the account does not have enough funds to:"," - pay for the total gas fee,"," - pay for the value to send."," ","The cost of the transaction is calculated as `gas * gas fee + value`, where:"," - `gas` is the amount of gas needed for transaction to execute,"," - `gas fee` is the gas fee,"," - `value` is the amount of ether to send to the recipient."]}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InsufficientFundsError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/insufficient funds/});Object.defineProperty(class extends qt{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction exceeds the limit allowed for the block.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"IntrinsicGasTooHighError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too high|gas limit reached/});Object.defineProperty(class extends qt{constructor({cause:e,gas:t}={}){super(`The amount of gas ${t?`(${t}) `:""}provided for the transaction is too low.`,{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"IntrinsicGasTooLowError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/intrinsic gas too low/});Object.defineProperty(class extends qt{constructor({cause:e}){super("The transaction type is not supported for this chain.",{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"TransactionTypeNotSupportedError"})}},"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/transaction type not valid/});class Bi extends qt{constructor({cause:e,maxPriorityFeePerGas:t,maxFeePerGas:r}={}){super([`The provided tip (\`maxPriorityFeePerGas\`${t?` = ${Zn(t)} gwei`:""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r?` = ${Zn(r)} gwei`:""}).`].join("\n"),{cause:e}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"TipAboveFeeCapError"})}}Object.defineProperty(Bi,"nodeMessage",{enumerable:!0,configurable:!0,writable:!0,value:/max priority fee per gas higher than max fee per gas|tip higher than fee cap/});function Ii(e,t,r,{strict:n}={}){return Yt(e,{strict:!1})?function(e,t,r,{strict:n}={}){Ai(e,t);const i=`0x${e.replace("0x","").slice(2*(t??0),2*(r??e.length))}`;n&&Si(i,t,r);return i}(e,t,r,{strict:n}):function(e,t,r,{strict:n}={}){Ai(e,t);const i=e.slice(t,r);n&&Si(i,t,r);return i}(e,t,r,{strict:n})}function Ai(e,t){if("number"==typeof t&&t>0&&t>Xt(e)-1)throw new Gt({offset:t,position:"start",size:Xt(e)})}function Si(e,t,r){if("number"==typeof t&&"number"==typeof r&&Xt(e)!==r-t)throw new Gt({offset:r,position:"end",size:Xt(e)})}function Pi(e){const{chainId:t,maxPriorityFeePerGas:r,maxFeePerGas:n,to:i}=e;if(t<=0)throw new xi({chainId:t});if(i&&!Hn(i))throw new fn({address:i});if(n&&n>2n**256n-1n)throw new vi({maxFeePerGas:n});if(r&&n&&r>n)throw new Bi({maxFeePerGas:n,maxPriorityFeePerGas:r})}function Oi(e){if(!e||0===e.length)return[];const t=[];for(let r=0;r<e.length;r++){const{address:n,storageKeys:i}=e[r];for(let e=0;e<i.length;e++)if(i[e].length-2!=64)throw new Xn({storageKey:i[e]});if(!Hn(n,{strict:!1}))throw new fn({address:n});t.push([n,i])}return t}function $i(e,t){const r=function(e){if(e.type)return e.type;if(void 0!==e.blobs||void 0!==e.blobVersionedHashes||void 0!==e.maxFeePerBlobGas||void 0!==e.sidecars)return"eip4844";if(void 0!==e.maxFeePerGas||void 0!==e.maxPriorityFeePerGas)return"eip1559";if(void 0!==e.gasPrice)return void 0!==e.accessList?"eip2930":"legacy";throw new Yn({transaction:e})}(e);return"eip1559"===r?function(e,t){const{chainId:r,gas:n,nonce:i,to:o,value:s,maxFeePerGas:a,maxPriorityFeePerGas:c,accessList:u,data:f}=e;Pi(e);const h=Oi(u),l=[rr(r),i?rr(i):"0x",c?rr(c):"0x",a?rr(a):"0x",n?rr(n):"0x",o??"0x",s?rr(s):"0x",f??"0x",h,...zi(e,t)];return kn(["0x02",wi(l)])}(e,t):"eip2930"===r?function(e,t){const{chainId:r,gas:n,data:i,nonce:o,to:s,value:a,accessList:c,gasPrice:u}=e;!function(e){const{chainId:t,maxPriorityFeePerGas:r,gasPrice:n,maxFeePerGas:i,to:o}=e;if(t<=0)throw new xi({chainId:t});if(o&&!Hn(o))throw new fn({address:o});if(r||i)throw new qt("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");if(n&&n>2n**256n-1n)throw new vi({maxFeePerGas:n})}(e);const f=Oi(c),h=[rr(r),o?rr(o):"0x",u?rr(u):"0x",n?rr(n):"0x",s??"0x",a?rr(a):"0x",i??"0x",f,...zi(e,t)];return kn(["0x01",wi(h)])}(e,t):"eip4844"===r?function(e,t){const{chainId:r,gas:n,nonce:i,to:o,value:s,maxFeePerBlobGas:a,maxFeePerGas:c,maxPriorityFeePerGas:u,accessList:f,data:h}=e;!function(e){const{blobVersionedHashes:t}=e;if(t){if(0===t.length)throw new ai;for(const e of t){const t=Xt(e),r=er(Ii(e,0,1));if(32!==t)throw new ci({hash:e,size:t});if(r!==oi)throw new ui({hash:e,version:r})}}Pi(e)}(e);let l=e.blobVersionedHashes,d=e.sidecars;if(e.blobs){const t="string"==typeof e.blobs[0]?e.blobs:e.blobs.map((e=>ir(e))),r=e.kzg,n=Jn({blobs:t,kzg:r}),i=Qn({blobs:t,commitments:n,kzg:r});l=function(e){const{commitments:t,version:r}=e,n=e.to??("string"==typeof t[0]?"hex":"bytes"),i=[];for(const e of t)i.push(ei({commitment:e,to:n,version:r}));return i}({commitments:n}),!1!==d&&(d=gi({blobs:t,commitments:n,proofs:i}))}const p=Oi(f),g=[rr(r),i?rr(i):"0x",u?rr(u):"0x",c?rr(c):"0x",n?rr(n):"0x",o??"0x",s?rr(s):"0x",h??"0x",p,a?rr(a):"0x",l??[],...zi(e,t)],y=[],w=[],b=[];if(d)for(let e=0;e<d.length;e++){const{blob:t,commitment:r,proof:n}=d[e];y.push(t),w.push(r),b.push(n)}return kn(["0x03",wi(d?[g,y,w,b]:g)])}(e,t):function(e,t){const{chainId:r=0,gas:n,data:i,nonce:o,to:s,value:a,gasPrice:c}=e;!function(e){const{chainId:t,maxPriorityFeePerGas:r,gasPrice:n,maxFeePerGas:i,to:o,accessList:s}=e;if(o&&!Hn(o))throw new fn({address:o});if(void 0!==t&&t<=0)throw new xi({chainId:t});if(r||i)throw new qt("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");if(n&&n>2n**256n-1n)throw new vi({maxFeePerGas:n});if(s)throw new qt("`accessList` is not a valid Legacy Transaction attribute.")}(e);let u=[o?rr(o):"0x",c?rr(c):"0x",n?rr(n):"0x",s??"0x",a?rr(a):"0x",i??"0x"];if(t){const e=(()=>{if(t.v>=35n){return(t.v-35n)/2n>0?t.v:27n+(35n===t.v?0n:1n)}if(r>0)return BigInt(2*r)+BigInt(35n+t.v-27n);const e=27n+(27n===t.v?0n:1n);if(t.v!==e)throw new Wn({v:t.v});return e})();u=[...u,rr(e),t.r,t.s]}else r>0&&(u=[...u,rr(r),"0x","0x"]);return wi(u)}(e,t)}function zi(e,t){const{r,s:n,v:i,yParity:o}=t??e;if(void 0===r)return[];if(void 0===n)return[];if(void 0===i&&void 0===o)return[];return["number"==typeof o?o?rr(1):"0x":0n===i?"0x":1n===i?rr(1):27n===i?"0x":rr(1),yi(r),yi(n)]}class Ui extends qt{constructor({expectedLength:e,givenLength:t,type:r}){super([`ABI encoding array length mismatch for type ${r}.`,`Expected length: ${e}`,`Given length: ${t}`].join("\n")),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiEncodingArrayLengthMismatchError"})}}class Li extends qt{constructor({expectedSize:e,value:t}){super(`Size of bytes "${t}" (bytes${Xt(t)}) does not match expected size (bytes${e}).`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiEncodingBytesSizeMismatchError"})}}class Ri extends qt{constructor({expectedLength:e,givenLength:t}){super(["ABI encoding params/values length mismatch.",`Expected length (params): ${e}`,`Given length (values): ${t}`].join("\n")),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"AbiEncodingLengthMismatchError"})}}class Ni extends qt{constructor({expectedSize:e,givenSize:t}){super(`Expected bytes${e}, got bytes${t}.`),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"BytesSizeMismatchError"})}}class Fi extends qt{constructor(e,{docsPath:t}){super([`Type "${e}" is not a valid encoding type.`,"Please provide a valid ABI type."].join("\n"),{docsPath:t}),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidAbiEncodingType"})}}class Ti extends qt{constructor(e){super([`Value "${e}" is not a valid array.`].join("\n")),Object.defineProperty(this,"name",{enumerable:!0,configurable:!0,writable:!0,value:"InvalidArrayError"})}}function Ki(e,t){if(e.length!==t.length)throw new Ri({expectedLength:e.length,givenLength:t.length});const r=function({params:e,values:t}){const r=[];for(let n=0;n<e.length;n++)r.push(Hi({param:e[n],value:t[n]}));return r}({params:e,values:t}),n=Ci(r);return 0===n.length?"0x":n}function Hi({param:e,value:t}){const r=function(e){const t=e.match(/^(.*)\[(\d+)?\]$/);return t?[t[2]?Number(t[2]):null,t[1]]:void 0}(e.type);if(r){const[n,i]=r;return function(e,{length:t,param:r}){const n=null===t;if(!Array.isArray(e))throw new Ti(e);if(!n&&e.length!==t)throw new Ui({expectedLength:t,givenLength:e.length,type:`${r.type}[${t}]`});let i=!1;const o=[];for(let t=0;t<e.length;t++){const n=Hi({param:r,value:e[t]});n.dynamic&&(i=!0),o.push(n)}if(n||i){const e=Ci(o);if(n){const t=or(o.length,{size:32});return{dynamic:!0,encoded:o.length>0?jn([t,e]):t}}if(i)return{dynamic:!0,encoded:e}}return{dynamic:!1,encoded:jn(o.map((({encoded:e})=>e)))}}(t,{length:n,param:{...e,type:i}})}if("tuple"===e.type)return function(e,{param:t}){let r=!1;const n=[];for(let i=0;i<t.components.length;i++){const o=t.components[i],s=Hi({param:o,value:e[Array.isArray(e)?i:o.name]});n.push(s),s.dynamic&&(r=!0)}return{dynamic:r,encoded:r?Ci(n):jn(n.map((({encoded:e})=>e)))}}(t,{param:e});if("address"===e.type)return function(e){if(!Hn(e))throw new fn({address:e});return{dynamic:!1,encoded:Wt(e.toLowerCase())}}(t);if("bool"===e.type)return function(e){if("boolean"!=typeof e)throw new qt(`Invalid boolean value: "${e}" (type: ${typeof e}). Expected: \`true\` or \`false\`.`);return{dynamic:!1,encoded:Wt(nr(e))}}(t);if(e.type.startsWith("uint")||e.type.startsWith("int")){return function(e,{signed:t}){return{dynamic:!1,encoded:or(e,{size:32,signed:t})}}(t,{signed:e.type.startsWith("int")})}if(e.type.startsWith("bytes"))return function(e,{param:t}){const[,r]=t.type.split("bytes"),n=Xt(e);if(!r){let t=e;return n%32!=0&&(t=Wt(t,{dir:"right",size:32*Math.ceil((e.length-2)/2/32)})),{dynamic:!0,encoded:jn([Wt(or(n,{size:32})),t])}}if(n!==parseInt(r))throw new Li({expectedSize:parseInt(r),value:e});return{dynamic:!1,encoded:Wt(e,{dir:"right"})}}(t,{param:e});if("string"===e.type)return function(e){const t=ar(e),r=Math.ceil(Xt(t)/32),n=[];for(let e=0;e<r;e++)n.push(Wt(Ii(t,32*e,32*(e+1)),{dir:"right"}));return{dynamic:!0,encoded:jn([Wt(or(Xt(t),{size:32})),...n])}}(t);throw new Fi(e.type,{docsPath:"/docs/contract/encodeAbiParameters"})}function Ci(e){let t=0;for(let r=0;r<e.length;r++){const{dynamic:n,encoded:i}=e[r];t+=n?32:Xt(i)}const r=[],n=[];let i=0;for(let o=0;o<e.length;o++){const{dynamic:s,encoded:a}=e[o];s?(r.push(or(t+i,{size:32})),n.push(a),i+=Xt(a)):r.push(a)}return jn([...r,...n])}const ji=/^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/,ki=/^(u?int)(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;function qi({domain:e}){return["string"==typeof e?.name&&{name:"name",type:"string"},e?.version&&{name:"version",type:"string"},"number"==typeof e?.chainId&&{name:"chainId",type:"uint256"},e?.verifyingContract&&{name:"verifyingContract",type:"address"},e?.salt&&{name:"salt",type:"bytes32"}].filter(Boolean)}function Mi(e){const{domain:t={},message:r,primaryType:n}=e,i={EIP712Domain:qi({domain:t}),...e.types};!function(e){const{domain:t,message:r,primaryType:n,types:i}=e,o=(e,t)=>{for(const r of e){const{name:e,type:n}=r,s=t[e],a=n.match(ki);if(a&&("number"==typeof s||"bigint"==typeof s)){const[e,t,r]=a;or(s,{signed:"int"===t,size:parseInt(r)/8})}if("address"===n&&"string"==typeof s&&!Hn(s))throw new fn({address:s});const c=n.match(ji);if(c){const[e,t]=c;if(t&&Xt(s)!==parseInt(t))throw new Ni({expectedSize:parseInt(t),givenSize:Xt(s)})}const u=i[n];u&&o(u,s)}};if(i.EIP712Domain&&t&&o(i.EIP712Domain,t),"EIP712Domain"!==n){const e=i[n];o(e,r)}}({domain:t,message:r,primaryType:n,types:i});const o=["0x1901"];return t&&o.push(function({domain:e,types:t}){return Vi({data:e,primaryType:"EIP712Domain",types:t})}({domain:t,types:i})),"EIP712Domain"!==n&&o.push(Vi({data:r,primaryType:n,types:i})),Nn(jn(o))}function Vi({data:e,primaryType:t,types:r}){return Nn(Di({data:e,primaryType:t,types:r}))}function Di({data:e,primaryType:t,types:r}){const n=[{type:"bytes32"}],i=[Gi({primaryType:t,types:r})];for(const o of r[t]){const[t,s]=_i({types:r,name:o.name,type:o.type,value:e[o.name]});n.push(t),i.push(s)}return Ki(n,i)}function Gi({primaryType:e,types:t}){const r=rr(function({primaryType:e,types:t}){let r="";const n=Zi({primaryType:e,types:t});n.delete(e);const i=[e,...Array.from(n).sort()];for(const e of i)r+=`${e}(${t[e].map((({name:e,type:t})=>`${t} ${e}`)).join(",")})`;return r}({primaryType:e,types:t}));return Nn(r)}function Zi({primaryType:e,types:t},r=new Set){const n=e.match(/^\w*/u)?.[0];if(r.has(n)||void 0===t[n])return r;r.add(n);for(const e of t[n])Zi({primaryType:e.type,types:t},r);return r}function _i({types:e,name:t,type:r,value:n}){if(void 0!==e[r])return[{type:"bytes32"},Nn(Di({data:n,primaryType:r,types:e}))];if("bytes"===r){return[{type:"bytes32"},Nn(n=`0x${(n.length%2?"0":"")+n.slice(2)}`)]}if("string"===r)return[{type:"bytes32"},Nn(rr(n))];if(r.lastIndexOf("]")===r.length-1){const i=r.slice(0,r.lastIndexOf("[")),o=n.map((r=>_i({name:t,type:i,types:e,value:r})));return[{type:"bytes32"},Nn(Ki(o.map((([e])=>e)),o.map((([,e])=>e))))]}return[{type:r},n]}function Wi(e){const t=rr(un.getPublicKey(e.slice(2),!1)),r=function(e){return Fn(`0x${Nn(`0x${e.substring(4)}`).substring(26)}`)}(t),n=function(e){if("string"==typeof e){if(!Hn(e,{strict:!1}))throw new fn({address:e});return{address:e,type:"json-rpc"}}if(!Hn(e.address,{strict:!1}))throw new fn({address:e.address});return{address:e.address,signMessage:e.signMessage,signTransaction:e.signTransaction,signTypedData:e.signTypedData,source:"custom",type:"local"}}({address:r,signMessage:async({message:t})=>async function({message:e,privateKey:t}){return Mn(await Vn({hash:qn(e),privateKey:t}))}({message:t,privateKey:e}),signTransaction:async(t,{serializer:r}={})=>async function(e){const{privateKey:t,transaction:r,serializer:n=$i}=e,i="eip4844"===r.type?{...r,sidecars:!1}:r,o=await Vn({hash:Nn(n(i)),privateKey:t});return n(r,o)}({privateKey:e,transaction:t,serializer:r}),signTypedData:async t=>async function(e){const{privateKey:t,...r}=e;return Mn(await Vn({hash:Mi(r),privateKey:t}))}({...t,privateKey:e})});return{...n,publicKey:t,source:"privateKey"}}function Yi(e,t={}){const r=kt(e);return function(e,{accountIndex:t=0,addressIndex:r=0,changeIndex:n=0,path:i}={}){const o=e.derive(i||`m/44'/60'/${t}'/${n}/${r}`);return{...Wi(rr(o.privateKey)),getHdKey:()=>o,source:"hd"}}(Ft.fromMasterSeed(r),t)}window.onDataCallback=async function(e,t){try{var r=Yi(t),n=await r.signMessage({message:e});window.ReactNativeWebView.postMessage(JSON.stringify({result:"success",signature:n}))}catch(e){window.ReactNativeWebView.postMessage(JSON.stringify({result:"failure",error:e.message}))}}})();